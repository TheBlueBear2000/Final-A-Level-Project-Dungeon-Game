CODE:



projects/final//game_main.py

def rungame(account_id, savegame_id, room, config, screen, player, player_loc, level, newlevel, last_room_screenshot): # Putting within a function so that it will be easier to implement into the main game later
    # Libraries
    import pygame
    import time

    # Local modules
    import classes.menu as menu_classes
    
    from classes.player import Player
    from classes.room import Room

    # Constants
    from classes.global_data import constants_structure, draw_text
    constants = constants_structure()
    
    # define game and GUI subwindows
    game_window = pygame.Surface((constants.GAME_WINDOW_SIZE), pygame.SRCALPHA)
    gui_window = pygame.Surface((constants.GUI_WINDOW_SIZE), pygame.SRCALPHA)
    
    # draw minimap image
    map_room_size = [20,20]
    map_joint_length = 10
    map_joint_width = 7
    level_layout = json.load(open(constants.FILE_PATH + f"data/account_games/{account_id}_games/{savegame_id}_levels/rooms_{level}/layout.json", 'r'))
    minimap = pygame.Surface(((len(level_layout[0]) * (map_room_size[0] + map_joint_length)) - map_joint_length,   (len(level_layout) * (map_room_size[1] + map_joint_length)) - map_joint_length), pygame.SRCALPHA)
    # draw squares
    for y, row in enumerate(level_layout):
        for x, item in enumerate(row):
            if item != 0:
                # squares
                pygame.draw.rect(minimap, (0,0,0), (x * (map_room_size[0] + map_joint_length), y * (map_room_size[1] + map_joint_length), *map_room_size))
                if room["id"] == item:
                    pygame.draw.circle(minimap, (255,255,255), ((x * (map_room_size[0] + map_joint_length)) + (map_room_size[0]//2), (y * (map_room_size[1] + map_joint_length))+ (map_room_size[1]//2)), map_room_size[0]//3)
                
                # lines
                doors = json.load(open(constants.FILE_PATH + f"data/account_games/{account_id}_games/{savegame_id}_levels/rooms_{level}/{item}.json", 'r'))["doors"]
                if doors["right"] is not None:
                    colour = (100,100,100)
                    if doors["right"]["complete"]:
                        colour = (0,0,0)
                    pygame.draw.rect(minimap, colour, ((x * (map_room_size[0] + map_joint_length)) + map_room_size[0], (y * (map_room_size[1] + map_joint_length)) + ((map_room_size[1]-map_joint_width)//2), map_joint_length, map_joint_width))
                if doors["down"] is not None:
                    colour = (100,100,100)
                    if doors["down"]["complete"]:
                        colour = (0,0,0)
                    pygame.draw.rect(minimap, colour, ((x * (map_room_size[0] + map_joint_length)) + ((map_room_size[0]-map_joint_width)//2), (y * (map_room_size[1] + map_joint_length)) + map_room_size[0], map_joint_width, map_joint_length))
    
    # get background
    background = pygame.Surface(constants.GAME_WINDOW_SIZE)
    image = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/underground_background.png").convert()
    background.blit(pygame.transform.scale(image, (image.get_width() * 2.5, image.get_height() * 2.5)), (0,0)) #pygame.transform.scale(image, square_size)
    

    # Used pygame docs: https://www.pygame.org/docs/
    


    # LOAD LEVEL AND ROOM
    room = Room(room, level, {"account_id": account_id, "savegame_id": savegame_id})
    
    #old_player_x_pos = player.x_pos
    #old_player_y_pos = player.y_pos
    #player_coord = [constants.GAME_WINDOW_SIZE[0]//2, constants.GAME_WINDOW_SIZE[1]//2]
    player_coord = [player.x_pos, player.y_pos]
    if player_loc == "right":
        player_coord[0] = room.location[0] + (constants.SQUARE_SIZE[0] * 1.4) - 75
    elif player_loc == "left":
        player_coord[0] = room.location[0] + room.size[0] - (constants.SQUARE_SIZE[0] * 1.4) - 75
    elif player_loc == "bottom":
        player_coord[1] = room.location[1] + (constants.SQUARE_SIZE[1] * 1.4) - 75
    elif player_loc == "top":
        player_coord[1] = room.location[1] + room.size[1] - (constants.SQUARE_SIZE[1] * 1.4) - 75
    #player_coord[0] -= 75
    #player_coord[1] -= 75
    player.teleport(*player_coord)
    
    if not newlevel:
        game_window = room.draw(game_window, constants.SQUARE_SIZE, config)
        rendering_order = sorted(room.get_rendering_list(), key=lambda item : item.get_rendering_row() )
        for item in rendering_order:
            game_window = item.draw(game_window)
            
        gui_window = player.draw_overlay_data(gui_window, room.location, (len(room.layout[0]) * constants.SQUARE_SIZE[0], len(room.layout[1]) * constants.SQUARE_SIZE[1]))  
        gui_window.blit(minimap, ((constants.GUI_WINDOW_SIZE[0] - minimap.get_width())//2, constants.GUI_WINDOW_SIZE[1] * 0.8))
        game_window = room.draw_over(game_window, constants.SQUARE_SIZE)
        from functions.loops.transition_animation import animation
        animation(screen, player_loc, game_window, last_room_screenshot, gui_window, background, player)
    
    
    
    player.reassess_keys(config["key_bindings"])
    

    processTime = 1
    
    frame = 0
    
    loop = True
    # Main game
    while loop:
        tick_start = time.time()
        
        from random import randint    
        
        # CHECK EVENTS
        events = pygame.event.get()
        for event in events:
            if event.type == pygame.QUIT:
                player.save(level, room.id)
                room.save()
                return False, "quit", game_window
                
            
        # PROCESS
        dead, room.living_items = player.move(config["key_bindings"], 
                    events, 
                    {"layout": room.layout, "location": room.location},
                    room.entities, 
                    room.living_items,
                    room.crates,
                    room.levers,
                    [*room.doors, *room.objective_doors],
                    room,
                    screen)
        if dead:
            player.health = player.max_health
            player.lives -= 1
            player.x_pos = constants.GAME_WINDOW_SIZE[0]//2 - 75
            player.y_pos = constants.GAME_WINDOW_SIZE[1]//2 - 75
            room.save()
            player.save(level, room.id)
            return True, None, game_window
        
        if player.collision_box["location"][0] <= room.location[0] + (constants.SQUARE_SIZE[0] * 0.6): # If leaving left
            room.save()
            player.save(level, room.id)
            return False, "left", game_window
        elif player.collision_box["location"][1] <= room.location[1] + (constants.SQUARE_SIZE[1] * 0.6): # If leaving top
            room.save()
            player.save(level, room.id)
            return False, "top", game_window
        elif player.collision_box["location"][0] >= room.location[0] + (len(room.layout[0]) * constants.SQUARE_SIZE[0]) - (constants.SQUARE_SIZE[0] * 0.6): # If leaving right
            room.save()
            player.save(level, room.id)
            return False, "right", game_window
        elif player.collision_box["location"][1] >= room.location[1] + (len(room.layout[1]) * constants.SQUARE_SIZE[1]) - (constants.SQUARE_SIZE[1] * 0.6): # If leaving bottom
            room.save()
            player.save(level, room.id)
            return False, "bottom", game_window
        
        room.update(player)
        
        for entity in room.entities:
            dead = entity.think(player, room.entities, room.crates, [*room.doors, *room.objective_doors], room, constants) # DEFINE ENTITIES AS ARRAY OF ALL ENTITIES BUT NOT PLAYER
            if dead:
                room.entities.remove(entity)
        
        for item in room.living_items:
            item.move(room.layout, room.location, constants)
            
        for button in room.buttons:
            button.update(player.collision_box, room.crates, room.entities)   
            
        
        if room.ladder is not None:
            if (room.ladder.player_proximity([player.collision_box["location"][i] + 
                                            (player.collision_box["size"][i]//2) for i in range(2)]) 
                <= constants.SQUARE_SIZE[0] // 3):
                print(f"level {level} complete")
                room.save()
                player.save(level, room.id)
                return False, "level_complete", game_window
        
        
        # RENDER
        game_window.blit(background, (0,0))
        
        game_window = room.draw(game_window, constants.SQUARE_SIZE, config)
        
        rendering_order = []
        rendering_order = room.get_rendering_list()
        rendering_order.append(player)
        
        rendering_order.sort( key=lambda item : item.get_rendering_row() )
        
        for item in rendering_order:
            game_window = item.draw(game_window)
        
        game_window = room.draw_over(game_window, constants.SQUARE_SIZE)
        
        gui_window = player.draw_overlay_data(gui_window, room.location, (len(room.layout[0]) * constants.SQUARE_SIZE[0], len(room.layout[1]) * constants.SQUARE_SIZE[1]))  
        
        #game_window = player.draw(game_window)
        
        gui_window.blit(minimap, ((constants.GUI_WINDOW_SIZE[0] - minimap.get_width())//2, constants.GUI_WINDOW_SIZE[1] * 0.8)) #(room.location[0] + room.size[0] + 100, 450))
        
        game_window = room.draw_icons(game_window, player)
        
        #game_window = player.draw(game_window)
        
        screen.blit(game_window,(0,0))
        
        
        
        
        
        screen.blit(gui_window,(constants.GAME_WINDOW_SIZE[0], 0) if constants.LANDSCAPE else (0, constants.GAME_WINDOW_SIZE[1]))
        
        if frame < 25 and newlevel:
            frame += 1
            temp_surface = pygame.Surface((constants.DEFAULT_SCREEN_SIZE), pygame.SRCALPHA)
            pygame.draw.rect(temp_surface, [50,50,50, 255 - (frame*10)], (0,0, *constants.DEFAULT_SCREEN_SIZE))
            draw_text(f"Level {level}", temp_surface, constants.TITLE_FONT, (constants.DEFAULT_SCREEN_SIZE[0]//2, constants.DEFAULT_SCREEN_SIZE[1]//2), (255,255,255, 255 - (frame*10)), "centre", "centre")
            screen.blit(temp_surface, (0,0))
            
        
        thefps = int((1 / processTime)*100)/100
        draw_text(f"FPS: {thefps}", screen, constants.SMALL_FONT, (10,10), (255,255,255), "left", "below")
        
        # flip() draws screen to display
        pygame.display.flip()

        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))
        processTime = time.time()-tick_start


import json
import pygame
def main_game(account_id, savegame_id, screen):
    
    print(f"running account {account_id} game {savegame_id}")
    
    #account_id = 1
    
    #pygame.init()
    #screen = pygame.display.set_mode((1000, 720))
    #pygame.display.set_caption('Dungeon Game')  
    
    from classes.global_data import constants_structure, draw_text
    constants = constants_structure()
    
    with open(constants.FILE_PATH + "data/accounts.json", 'r') as data_file:
            thedata = json.load(data_file)
            config = thedata[account_id - 1]["config"]
            #print(config["key_bindings"])
    
    level = -1 # 0
    level = 1
    
    
    playing = True
    while playing: # in game, between levels
        from classes.player import Player
        player = Player(level, account_id, savegame_id)
        
        room = json.load(open(constants.FILE_PATH + f"data/account_games/{account_id}_games/{savegame_id}_levels/rooms_{level}/{player.current_room}.json", 'r'))
        
        level_layout = json.load(open(constants.FILE_PATH + f"data/account_games/{account_id}_games/{savegame_id}_levels/rooms_{level}/layout.json", 'r'))
        # find the room coordinates
        for y, row in enumerate(level_layout):
            for x, item in enumerate(row):
                if item == player.current_room:
                    room_coord = [x, y]
                    break
        
        #player_loc = (constants.DEFAULT_SCREEN_SIZE[0]//2 + 60, constants.DEFAULT_SCREEN_SIZE[1]//2- 120)
        direction = "centre"
        
        dead = False
        newlevel = True
        last_room_screenshot = None
        while not dead: # in level, between rooms
            dead, direction, last_room_screenshot = rungame(account_id, savegame_id, room, config, screen, player, direction, level, newlevel, last_room_screenshot)
            newlevel = False
            if dead:
                break
            
            if direction == "left":
                room_coord[0] -= 1
            elif direction == "top":
                room_coord[1] -= 1
            elif direction == "right":
                room_coord[0] += 1
            elif direction == "bottom":
                room_coord[1] += 1
            elif direction == "quit":
                playing = False
                break
            else:
                level += 1
                break
            
            room_number = level_layout[room_coord[1]][room_coord[0]]
            
            
            room = json.load(open(constants.FILE_PATH + f"data/account_games/{account_id}_games/{savegame_id}_levels/rooms_{level}/{room_number}.json", 'r'))
            
        #player.save(level)



projects/final//compile_to_text.py

import os

file_string = "CODE:"
file_count = 0

directory = 'projects/final/'
for dirpath, dirnames, filenames in os.walk(directory):
    for filename in filenames:
        if filename.endswith('.py')  or  filename.endswith('.json'):
            with open(os.path.join(dirpath, filename)) as f:
                file_string += "\n\n\n\n" + dirpath + '/' + filename + "\n"
                file_string += f.read()
                file_count += 1
                #print(f.read())

file_string += f"\n\n\n\nTotal files: {file_count}\n"

#print(file_string)

with open("projects/prototypes/ver1/saved_text.txt", 'w') as f:
    f.write(file_string)






projects/final//main.py
# Libraries
import pygame
import time

# Used pygame docs: https://www.pygame.org/docs/
pygame.init()
screen = pygame.display.set_mode((1000, 720))
pygame.display.set_caption('Dungeon Game')

# Set up enviroment
# Local modules
import classes.menu as menu_classes
from functions.loops.create_account_loop import run as create_account
from functions.loops.log_in_loop import run as log_in


# Constants
from classes.global_data import constants_structure
constants = constants_structure()


defaultCharacterLog = {"mouse_down": False,
                "mouse_first_click": False
                }


# MENU OBJECTS
menu_buttons = [
    menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5), 
                        size=(600, 200), 
                        text="Log-In", 
                        response_function=log_in,
                        font=constants.TITLE_FONT),
    menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*4), 
                        size=(600, 200), 
                        text="Create Account", 
                        response_function=create_account,
                        font=constants.TITLE_FONT)
]


loop = True

# The menu where a user chooses between making a new account or logging into an existing one
while loop:
    tick_start = time.time()
    
    # FRAME CONSTANTS ONE
    mouse_pos = pygame.mouse.get_pos()
    
    
    # CHECK EVENTS
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            loop = False
            
        if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
            for button in menu_buttons:
                if button.under_pointer:
                    button.response_function(screen)
                else:
                    button.selected = False
            
            
            
            
    # PROCESS
    for button in menu_buttons:
        button.update(mouse_pos)
    
    # RENDER
    screen.fill("gray")
    for button in menu_buttons:
        screen = button.draw(screen)
    
    
    # flip() draws screen to display
    pygame.display.flip()

    # Pause remainder of tick
    time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))





projects/final/classes/global_data.py
import pygame
class constants_structure:
    def __init__(self):
        self.MENU_FPS = 15   
        #self.MENU_FPS = 0.5
        self.FILE_PATH = "projects/final/"
        self.INV_ITEM_SIZE = [80,80]
        self.LIVES_SIZE = [50, 50]
        
        self.DEFAULT_SCREEN_SIZE = pygame.display.get_window_size()
        
        self.GAME_WINDOW_SIZE = [min(*self.DEFAULT_SCREEN_SIZE) for i in range(2)]
        self.LANDSCAPE = self.DEFAULT_SCREEN_SIZE[0] > self.DEFAULT_SCREEN_SIZE[1]
        if self.LANDSCAPE:
            self.GUI_WINDOW_SIZE = [self.DEFAULT_SCREEN_SIZE[0] - self.GAME_WINDOW_SIZE[0], self.DEFAULT_SCREEN_SIZE[1]]
        else:
            self.GUI_WINDOW_SIZE = [self.DEFAULT_SCREEN_SIZE[0], self.DEFAULT_SCREEN_SIZE[1] - self.GAME_WINDOW_SIZE[1]]
            
        self.SQUARE_SIZE = [(min(*self.DEFAULT_SCREEN_SIZE) // 12) for i in range(2)]
            
        
        pygame.font.init()
        self.TITLE_FONT = pygame.font.Font(self.FILE_PATH + "project_lib/fonts/title.ttf", 80)
        self.NORMAL_FONT = pygame.font.Font(self.FILE_PATH + "project_lib/fonts/normal.ttf", 40)
        self.SMALL_FONT = pygame.font.Font(self.FILE_PATH + "project_lib/fonts/normal.ttf", 15)
        

def draw_text(text, surface, font, location, colour, h_alignment, v_alignment):
    rendered_text = font.render(text, True, colour)
    
    # find true location from alignment
    if h_alignment == "centre":
        location = (location[0] - (rendered_text.get_width()//2) ,  location[1])
    # alignment "left" changes nothing
    elif h_alignment == "right":
        location = (location[0] - rendered_text.get_width() ,  location[1])
        
    # vertical alignment
    if v_alignment == "centre":
        location = (location[0] ,  location[1] - (rendered_text.get_height()//2))
    # alignment "below" changes nothing
    elif v_alignment == "above":
        location = (location[0] ,  location[1] - rendered_text.get_height())

    # opacity
    if len(colour) > 3:
        rendered_text.set_alpha(colour[3])
        
    surface.blit(rendered_text, location)
    return surface



projects/final/classes/objective_icon.py

import pygame

class ObjectiveIndicator:
    def __init__(self, side, objective):
        self.side = side
        self.objective = objective
        
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        
        self.texture = temp_surface = pygame.Surface([1,1], pygame.SRCALPHA)
        self.description = []
        if objective["type"] == "kill_count":
            self.texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/icons/skull_and_crossbones.png").convert(), constants.SQUARE_SIZE)
            self.description = [f"Kill a total of {objective['num']}", "enemies to open this door"]
        elif objective["type"] == "local_kill_count":
            self.texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/icons/skull.png").convert(), constants.SQUARE_SIZE)
            self.description = [f"Kill {objective['num']} enemies in this", "room to open this door"]
        elif objective["type"] == "keyhole":
            self.texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/icons/key.png").convert(), constants.SQUARE_SIZE)
            self.description = [f"Open this door with a key", "of the matching colour"]
        elif objective["type"] == "powered":
            self.texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/icons/bolt.png").convert(), constants.SQUARE_SIZE)
            self.description = [f"Trigger an input", "of the matching colour"]
        
        if objective["colour"] is not None:
            temp_surface = pygame.Surface((self.texture.get_width(), self.texture.get_height()), pygame.SRCALPHA)
            temp_surface.blit(self.texture, (0,0))
            temp_surface.fill(objective["colour"], special_flags=pygame.BLEND_MULT)
            self.texture = temp_surface
        
        self.centre = [0,0]
        
        if self.side == "left":
            self.centre[0] = constants.SQUARE_SIZE[0] // 2
            self.centre[1] = constants.GAME_WINDOW_SIZE[1] // 2
        elif self.side == "right":
            self.centre[0] = constants.GAME_WINDOW_SIZE[0] - (constants.SQUARE_SIZE[0] // 2)
            self.centre[1] = constants.GAME_WINDOW_SIZE[1] // 2
        elif self.side == "up":
            self.centre[0] = constants.GAME_WINDOW_SIZE[0] // 2
            self.centre[1] = constants.SQUARE_SIZE[1] // 2 + (constants.SQUARE_SIZE[1] // 2)
        elif self.side == "down":
            self.centre[0] = constants.GAME_WINDOW_SIZE[0] // 2
            self.centre[1] = constants.GAME_WINDOW_SIZE[1] - (constants.SQUARE_SIZE[1] // 2)
            
        self.x_pos = self.centre[0] - (self.texture.get_width()//2)
        self.y_pos = self.centre[1] - (self.texture.get_height())
        
    def draw(self, screen, text):
        from classes.global_data import constants_structure, draw_text
        constants = constants_structure()
        
        temp_surface = pygame.Surface(constants.SQUARE_SIZE, pygame.SRCALPHA)
        temp_surface.blit(self.texture, [0,0])
        screen.blit(temp_surface, [self.x_pos, self.y_pos])
        
        draw_text(text, screen, constants.SMALL_FONT, (self.centre[0], self.centre[1] + (self.texture.get_height()//4)), (255,255,255), "centre", "centre")
        
        from math import sqrt
        mouse_pos = pygame.mouse.get_pos()
        if sqrt(((mouse_pos[0]-self.centre[0])**2) + ((mouse_pos[1]-self.centre[1])**2)) <= constants.SQUARE_SIZE[0] * 1.5:
            temp_surface = pygame.Surface((250, 30 * len(self.description)), pygame.SRCALPHA)
            temp_surface.blit(pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/menu/shadow.png").convert(), (250, 30 * len(self.description))), [0,0])
            
            v_pos = "centre"
            h_pos = "centre"
            if self.side == "left":
                h_pos = "left"
                screen.blit(temp_surface, (mouse_pos[0], mouse_pos[1] - 20))
            elif self.side == "right":
                h_pos = "right"
                screen.blit(temp_surface, (mouse_pos[0] - temp_surface.get_width(), mouse_pos[1] - 20))
            elif self.side == "up":
                v_pos = "below"
                screen.blit(temp_surface, (mouse_pos[0] - (temp_surface.get_width()//2), mouse_pos[1]-5))
            elif self.side == "down":
                v_pos = "above"
                screen.blit(temp_surface, (mouse_pos[0] - (temp_surface.get_width()//2), mouse_pos[1]-20))
            for i, text in enumerate(self.description):
                # draw at fixed pos instead, align accordingly
                draw_text(text, screen, constants.SMALL_FONT, (mouse_pos[0], mouse_pos[1] + (i*20)), (255,255,255), h_pos, v_pos)
        
        return screen



projects/final/classes/menu.py
import pygame
from classes.global_data import draw_text
from classes.global_data import constants_structure
constants = constants_structure()

def default_response_function():
    return

class button:
    def __init__(self, location, size, text, response_function=default_response_function, font=constants.NORMAL_FONT):
        self.location = location
        self.size = size
        self.text = text
        self.response_function = response_function
        self.font = font
        
        self.under_pointer = False
        
        ratio = (size[0]/size[1])
        self.texture = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/buttons/ratio1-{ratio}.png").convert()
        
    
        
    def update(self, mouse_pos, keyspressed=[]):
        if (mouse_pos[0] > self.location[0] and
            mouse_pos[1] > self.location[1] and
            mouse_pos[0] < self.location[0] + self.size[0] and
            mouse_pos[1] < self.location[1] + self.size[1] ): # If within button boundary
            self.under_pointer = True
        else:
            self.under_pointer = False
        
    def draw(self, screen, tickCount=None):
        # Draw button
        screen.blit(pygame.transform.scale(self.texture, self.size), self.location)
        
        # Shade if hovered over
        if self.under_pointer:
            temp_surface = pygame.Surface(self.size, pygame.SRCALPHA)               # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
            pygame.draw.rect(temp_surface, (0, 0, 0, 128), (0, 0, *self.size))
            screen.blit(temp_surface, self.location)
            
        # Add text
        screen = draw_text(self.text, screen, self.font, 
                            (self.location[0] + ((self.size[0])//2), self.location[1] + ((self.size[1])//2)),
                            (0,0,0),
                            "centre",
                            "centre")
        
        return screen
    
    
class textInputBox:
    def __init__(self, location, size, button_name, protected=False, font = constants.NORMAL_FONT):
        self.location = location
        self.size = size
        self.name = button_name
        self.protected = protected
        self.font = font
        
        self.selected = False
        self.content = ""
        
        ratio = (size[0]/size[1])
        self.texture = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/text_input/ratio1-{ratio}.png").convert()
        
    def response_function(self):
        self.selected = not self.selected # toggle selection
    
    def update(self, mouse_pos, keyspressed=[]):
        if (mouse_pos[0] > self.location[0] and
            mouse_pos[1] > self.location[1] and
            mouse_pos[0] < self.location[0] + self.size[0] and
            mouse_pos[1] < self.location[1] + self.size[1] ): # If within button boundary
            self.under_pointer = True
        else:
            self.under_pointer = False
            
            
            
        if self.selected:
            for key in keyspressed:
                if key == '\x08':
                    self.content = self.content[:-1]
                elif key == "\r":
                    self.selected = False
                elif len(self.content) <= 17:
                    self.content += key
        
    
            
    
    def draw(self, screen, tickCount=None):
        # Draw button
        screen.blit(pygame.transform.scale(self.texture, self.size), self.location)
        
        # Shade if hovered over
        if self.under_pointer or self.selected:
            if self.selected and not self.under_pointer:
                intensity = 64
            else:
                intensity = 128
            temp_surface = pygame.Surface(self.size, pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
            pygame.draw.rect(temp_surface, (0, 0, 0, intensity), (0, 0, *self.size))
            screen.blit(temp_surface, self.location)
            
        # Add text
        if self.content != "" or self.selected:
            if self.protected:
                protected_string = "*" * len(self.content)
                content = self.font.render(protected_string, True, (0, 0, 0))
            else:
                content = self.font.render(self.content, True, (0, 0, 0))
        else:
            content = self.font.render(self.name, True, (50, 50, 50))
        screen.blit(content, (self.location[0] + ((self.size[0] - content.get_width())//2), self.location[1] + ((self.size[1] - content.get_height())//2)))
        
        if tickCount % 16 < 8 and self.selected:
            pygame.draw.rect(screen, (0, 0, 0), (self.location[0] + (self.size[0] + content.get_width())//2 + 4, self.location[1] + 30, 7, 40))
        
        
        
        return screen
    
    
class displayedError:
    def __init__(self, error_message, start_tick):
        self.error_message = error_message
        self.start_tick = start_tick 
    
    def draw(self, screen):
        intensity = 128
        font = pygame.font.Font(constants.FILE_PATH + "project_lib/fonts/normal.ttf", 20)
        
        temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        content = font.render(self.error_message, True, (255, 50, 50, intensity) )
        temp_surface.blit(content, ((constants.DEFAULT_SCREEN_SIZE[0] - content.get_width())//2, 5))
        screen.blit(temp_surface, (0,0))
        
        return screen
    
    
class savegameButton:
    def __init__(self, location, size, savegame_display_details, game_data):
        self.location = location
        self.size = size
        self.savegame_display_details = savegame_display_details
        self.middle_font = pygame.font.Font(constants.FILE_PATH + "project_lib/fonts/normal.ttf", 30)
        
        self.game_data = game_data
        
        self.under_pointer = False
        
        ratio = (size[0]/size[1])
        self.texture = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/text_input/ratio1-{ratio}.png").convert() # Use text input button design
    
    def update(self, mouse_pos, keyspressed=[]):
        if (mouse_pos[0] > self.location[0] and
            mouse_pos[1] > self.location[1] and
            mouse_pos[0] < self.location[0] + self.size[0] and
            mouse_pos[1] < self.location[1] + self.size[1] ): # If within button boundary
            self.under_pointer = True
        else:
            self.under_pointer = False
            
    def response_function(self, screen):
        from functions.loops.savegame_options import open_savegame
        open_savegame(*self.game_data, self.savegame_display_details, screen)
        return
    
    def draw(self, screen, tickCount=None):
        # Draw button
        screen.blit(pygame.transform.scale(self.texture, self.size), self.location)
        
        # Shade if hovered over
        if self.under_pointer:
            temp_surface = pygame.Surface(self.size, pygame.SRCALPHA)               # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
            pygame.draw.rect(temp_surface, (0, 0, 0, 128), (0, 0, *self.size))
            screen.blit(temp_surface, self.location)
            
        # Add text
        info = [self.savegame_display_details["name"],
                "Level: " + str(self.savegame_display_details["level"]),
                "Last Saved: " + str(self.savegame_display_details["last_save"]),
                "Created: " + str(self.savegame_display_details["created"])]
        
        for i, line in enumerate(info):
            if i == 0:
                text = self.middle_font.render(line, True, (0, 0, 0))
                screen.blit(text, (self.location[0] + ((self.size[0] - text.get_width())//2), 
                                self.location[1] + (self.size[1]//2) + (self.size[1]//8 * (i-1)) - 20))
            else:
                text = constants.SMALL_FONT.render(line, True, (0, 0, 0))
                screen.blit(text, (self.location[0] + ((self.size[0] - text.get_width())//2), 
                                    self.location[1] + (self.size[1]//2) + (self.size[1]//8 * (i-1))))
            
        return screen



projects/final/classes/player.py
import pygame
from functions.algorithms.aoeScanner import aoeScanner
from functions.algorithms.item_lookup import lookup
from classes.items.living_item import LivingItem
from math import sqrt
from random import randint


# Multipliers to implement:
# Armour
# self.speed_multiplier
# self.mele_armour_multiplier
# self.ranged_armour_multiplier
# # Mele
# self.damage_multiplier
# self.attack_speed_multiplier
# self.mele_range_multiplier 
# # Ranged
# self.ranged_reload_multiplier
# # Charms
# self.max_health_multiplier
# self.regen_speed = 0 # How much is added every tick to the regen speed timer (when timer is more than 1, it adds 1 health and resets to 0). Items do not add regen by default. Only works for charms
# self.stamina_recharge_mulitplier

class Player:
    def __init__(self, level, account_id, savegame_id):
        # Constants
        import json
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        player_data = json.load(open(constants.FILE_PATH + f"data/account_games/{account_id}_games/{savegame_id}_levels/rooms_{level}/player.json", "r"))

        self.account_id = account_id
        self.savegame_id = savegame_id
        
        self.initiate_assets(constants)
        
        self.state = "idle"
        self.direction = player_data["direction"]
        
        self.lives = player_data["lives"]
        
        self.max_health = player_data["max_health"]
        self.health = player_data["health"]
        self.x_pos = player_data["x"] if player_data["x"] is not None else constants.GAME_WINDOW_SIZE[0]//2 - 75   #x if x is not None else player_data["x"]
        self.y_pos = player_data["y"] if player_data["y"] is not None else constants.GAME_WINDOW_SIZE[1]//2 - 75   #y if y is not None else player_data["y"]
        self.current_room = player_data["current_room"]
        self.movement_vector = [0,0]
        self.speed = player_data["speed"]
        self.push_pull_speed = player_data["push_pull_speed"]
        self.size = (150,150)
        self.sprinting = False
        self.push_speed_multiplier = 0.3
        self.pushing = False
        self.sprint_multiplier = 2
        self.max_sprint_stamina = player_data["max_sprint_stamina"]
        self.sprint_stamina = player_data["sprint_stamina"]
        self.max_boost_time = player_data["max_boost_time"]
        self.boost_cooldown = player_data["boost_cooldown"]
        self.boost_frame = 0
        self.boost_speed = player_data["boost_speed"]
        self.animation_frame_time = 0.1
        self.animation_cooldown = 0
        
        self.mele_reach = player_data["mele_reach"]
        self.mele_push_strength = player_data["mele_push_strength"]
        self.attack_damage = player_data["attack_damage"]
        self.attack_timer = 0
        self.max_attack_cooldown = player_data["max_attack_cooldown"]
        self.attack_cooldown = self.max_attack_cooldown
        
        self.team = "player"
        
        self.held_keys = {
            "up": False,
            "down": False,
            "left": False,
            "right": False,
            "sprint": False
        }
        
        self.collision_box = {"size": (48, 25),
                            "location": ((self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 40 + self.y_pos)}
        
        #self.inventory = [None, None, # main and offhand 0-1
        #                None, None, None, # Helmet, torso and legs 2-4
        #                None, None, None, # Line one 5-7
        #                None, None, None, # Line tw 8-10
        #                None, None, None,] # Line three 11-13
        inventory_data = player_data["inventory"]
        
        from functions.algorithms.item_lookup import lookup as i_lookup
        self.inventory = []
        for item in inventory_data:
            if item is not None:
                self.inventory.append(i_lookup(item["item"])(item["payload"]))
            else:
                self.inventory.append(None)
        
        
        self.inv_texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/inventory.png").convert(), (constants.INV_ITEM_SIZE[0] * 3, constants.INV_ITEM_SIZE[1] * 5))
        self.selected_inv_texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/inventory_highlighted.png").convert(), constants.INV_ITEM_SIZE)
        self.holding_main_hand = player_data["holding_main_hand"]
        
        self.lives_texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/icons/player_head.png").convert(), constants.LIVES_SIZE)
        
        self.side_bar_asset = pygame.image.load(constants.FILE_PATH + "project_lib/assets/menu/side_bar.png")
        
        self.get_square = lambda room : [int((self.collision_box["location"][0] - room.location[0])//constants.SQUARE_SIZE[0]),
                                        int((self.collision_box["location"][1] - room.location[1])//constants.SQUARE_SIZE[1])]
        
        #from classes.items.items import StickSword
        #self.inventory[0] = StickSword(None)
        
        # possible states: idle, run, sprint, boost, push, pull, attack, take_damage, death, fall
        self.change_state("idle")
        
        
        self.kills = player_data["kills"]
        
        
    def move(self, key_bindings, events, room_data, entities, living_items, crates, levers, doors, room, screen):
        if self.state == "death":
            if self.animation_frame == len(self.assets["death"])-1:
                return True, living_items
            else:
                return False, living_items

        
        throw_away_items = []
        
        if self.attack_cooldown < self.max_attack_cooldown:
            self.attack_cooldown += 1 * self.get_attack_speed_multiplier()
        
        #if self.attack_timer > 0:
        #    self.attack_timer -= 1
            
        started_movements = []
        ended_movements = []
        for event in events:
            if event.type == pygame.KEYDOWN:
                if key_bindings.get(str(event.key)) is not None: # key values are equal to the decimal ascii value of that key
                    started_movements.append(key_bindings[str(event.key)])
            if event.type == pygame.KEYUP:
                if key_bindings.get(str(event.key)) is not None: # key values are equal to the decimal ascii value of that key
                    ended_movements.append(key_bindings[str(event.key)])
            if event.type == pygame.MOUSEBUTTONDOWN:
                if key_bindings.get("L_CLICK") is not None:
                    started_movements.append(key_bindings["L_CLICK"])
            if event.type == pygame.MOUSEBUTTONUP:
                if key_bindings.get("L_CLICK") is not None:
                    started_movements.append(key_bindings["L_CLICK"])

        
        
        
        
        # Start togglable movements
        for movement in started_movements:
            if movement == "up":
                self.held_keys["up"] = True
            elif movement == "down":
                self.held_keys["down"] = True
            elif movement == "left":
                self.held_keys["left"] = True
            elif movement == "right":
                self.held_keys["right"] = True
                
            elif movement == "sprint":
                self.held_keys["sprint"] = True
                if self.sprint_stamina > 0:
                    self.sprinting = True
                    
            elif movement == "attack":
                if self.attack_cooldown >= self.max_attack_cooldown:
                    self.attack_cooldown = 0
                    attack_damage = self.attack_damage # Default
                    # calculate from weapon
                    if self.holding_main_hand and (self.inventory[0] != None):
                        attack_damage = self.attack_damage * self.inventory[0].damage_multiplier
                    elif (not self.holding_main_hand) and (self.inventory[1] != None):
                        attack_damage = self.attack_damage * self.inventory[1].damage_multiplier
                        
                    drops = self.attack(self, entities, room, attack_damage)
                    # handle drops from attack
                    for item in drops:
                        if item["name"] != None:
                            living_items.append(LivingItem(item["x"], item["y"], lookup(item["name"]["item"])(item["name"]["payload"]), [randint(-10,10), randint(-10,10)]))
                            
                
            # hand selection (boolean determines where in inventory array will be selected, since index 0 and 1 are the main and off hand respectively)
            elif movement == "switch_hand":
                self.holding_main_hand = not self.holding_main_hand
            elif movement == "main_hand":
                self.holding_main_hand = True
            elif movement == "off_hand":
                self.holding_main_hand = False
                
            # run screen buttons
            elif movement == "pause":
                from functions.loops.pause_screen import run as run_pause_screen
                run_pause_screen(screen, key_bindings)
                self.reassess_keys(key_bindings)
            elif movement == "inventory":
                from functions.loops.inventory import run as open_inventory
                self.inventory, throw_away_items = open_inventory(self.inventory, screen, key_bindings)
                self.reassess_keys(key_bindings)
            # Boost functionality
            elif movement == "boost":
                if self.boost_cooldown == self.max_boost_time  and  (self.held_keys["up"] or self.held_keys["down"] or self.held_keys["left"] or self.held_keys["right"]):
                    self.boost_cooldown = 0
                    self.boost_frame = 3
                    
            elif movement == "interact":
                # check for item pickup
                if len(living_items) > 0:
                    item = None
                    distance = 9999999999999
                    for l_item in living_items:
                        n_distance = sqrt((((l_item.x_pos + (l_item.size[0]//2)) - (self.collision_box["location"][0] + (self.collision_box["size"][0]//2)))  **2)  +
                                        (((l_item.y_pos + (l_item.size[1]//2)) - (self.collision_box["location"][1] + (self.collision_box["size"][1]//2)))  **2))
                        if n_distance < distance:
                            item = l_item
                            distance = n_distance
                        
                    if distance < 60:
                        living_items = self.pick_up(item, living_items)
                        break # break from interaction
                    
                # check for doors
                if len(doors) > 0:
                    door = None
                    distance = 9999999999999
                    for n_door in doors:
                        if n_door.manual or n_door.type == "keyhole":
                            n_distance = sqrt((((n_door.collision_box["location"][0] + (n_door.collision_box["size"][0]//2)) - (self.collision_box["location"][0] + (self.collision_box["size"][0]//2)))  **2)  +
                                            (((n_door.collision_box["location"][1] + (n_door.collision_box["size"][1]//2)) - (self.collision_box["location"][1] + (self.collision_box["size"][1]//2)))  **2))
                            if n_distance < distance:
                                door = n_door
                                distance = n_distance
                                
                        
                    if distance < 90:
                        if door.type == "keyhole":
                            if self.inventory[1-int(self.holding_main_hand)] != None:
                                if self.inventory[1-int(self.holding_main_hand)].type == "key":
                                    if self.inventory[1-int(self.holding_main_hand)].colour == door.colour:
                                        door.toggle_state()
                                        if door.side is not None:
                                            room.complete_objective(door.side)
                        else:
                            door.toggle_state()
                        break # break from interaction
                        
                # check for levers
                if len(levers) > 0:
                    lever = None
                    distance = 9999999999999
                    for n_lever in levers:
                        n_distance = sqrt((((n_lever.collision_box["location"][0] + (n_lever.collision_box["size"][0]//2)) - (self.collision_box["location"][0] + (self.collision_box["size"][0]//2)))  **2)  +
                                        (((n_lever.collision_box["location"][1] + (n_lever.collision_box["size"][1]//2)) - (self.collision_box["location"][1] + (self.collision_box["size"][1]//2)))  **2))
                        if n_distance < distance:
                            lever = n_lever
                            distance = n_distance
                        
                    if distance < 60:
                        lever.flicked = not lever.flicked # toggle
                        break # break from interaction
        
        # end movements
        for movement in ended_movements:
            if movement == "up":
                self.held_keys["up"] = False
            elif movement == "down":
                self.held_keys["down"] = False
            elif movement == "left":
                self.held_keys["left"] = False
            elif movement == "right":
                self.held_keys["right"] = False
            elif movement == "sprint":
                self.sprinting = False
                self.held_keys["sprint"] = False
                
                
        multiplier = self.get_speed_multiplier()
        if self.sprinting:
            multiplier = self.sprint_multiplier
            
        
        # calculate vector
        self.movement_vector = [0,0]
        if self.held_keys["up"]:
            self.movement_vector[1] -= self.speed * multiplier
        if self.held_keys["down"]:
            self.movement_vector[1] += self.speed * multiplier
        if self.held_keys["left"]:
            self.movement_vector[0] -= self.speed * multiplier
        if self.held_keys["right"]:
            self.movement_vector[0] += self.speed * multiplier
        self.check_direction()
        
        
        # adjust stamina
        if self.sprinting and self.sprint_stamina > 0 and (not self.pushing):
            self.sprint_stamina -= 1
        elif self.sprint_stamina < 45 and (not self.pushing):
            self.sprint_stamina += 1 * self.get_stamina_recharge_multiplier()
        
        if self.sprint_stamina == 0:
            self.sprinting = False
        
        # adjust boost cooldown
        if self.boost_cooldown < self.max_boost_time:
            self.boost_cooldown += 1
                    
                    
        moves = 1
        boosting = False
        if self.boost_frame > 0:
            boosting = True
            self.boost_frame -= 1 * self.get_stamina_recharge_multiplier()
            moves = self.boost_speed
            
        # CALCULATE MOVEMENT VECTOR
        speed = self.speed * self.get_speed_multiplier() # handle sprinting (replace later to account for pushing or non-sprinting states)
        if self.sprinting and not boosting:
            speed *= self.sprint_multiplier
        from functions.algorithms.getMovementVector import get_movement_vector
        self.movement_vector = get_movement_vector(speed, self.movement_vector)
        
        
        
        
        #if self.attack_timer == 0:
        from functions.algorithms.collision_detection import is_colliding, collision
        from classes.global_data import constants_structure
        constants = constants_structure()
        self.pushing = False
        for i in range(moves):
            self.collision_box["location"] = ((self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 23 + self.y_pos)
            # X
            projected_collision_box = self.collision_box
            for x_distance in range(abs(int(self.movement_vector[0]))):
                self.collision_box["location"] = ((self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 23 + self.y_pos)
                projected_collision_box = {
                    "size": projected_collision_box["size"],
                    "location": (projected_collision_box["location"][0] + (self.movement_vector[0]/abs(self.movement_vector[0])), projected_collision_box["location"][1])
                }
                if not is_colliding(projected_collision_box, room_data["layout"], room_data["location"], constants.SQUARE_SIZE): # wall collision
                    is_crate_collision = False
                    pushed_x = False
                    collided_door = False
                    for door in doors:
                        if collision([*projected_collision_box["location"], *projected_collision_box["size"]], [*door.collision_box["location"], *door.collision_box["size"]]):
                            collided_door = True
                            break
                    if not collided_door:
                        for crate in crates:
                            if collision([*projected_collision_box["location"], *projected_collision_box["size"]], [*crate.collision_box["location"], *crate.collision_box["size"]]):
                                is_crate_collision = True
                                if self.held_keys["sprint"]:
                                    self.pushing = True
                                    if crate.move("left" if self.movement_vector[0] < 0 else "right", self.push_speed_multiplier, room, crates, doors, entities, []):
                                        if not pushed_x:
                                            pushed_x = True
                                            self.x_pos += (self.movement_vector[0]/abs(self.movement_vector[0])) * self.push_speed_multiplier
                                #break
                    if not (is_crate_collision or collided_door):
                        self.x_pos += (self.movement_vector[0]/abs(self.movement_vector[0]))
                
            # Y
            projected_collision_box = self.collision_box
            for y_distance in range(abs(int(self.movement_vector[1]))):
                self.collision_box["location"] = ((self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 23 + self.y_pos)
                projected_collision_box = {
                    "size": projected_collision_box["size"],
                    "location": (projected_collision_box["location"][0], projected_collision_box["location"][1] + (self.movement_vector[1]/abs(self.movement_vector[1])))
                }
                if not is_colliding(projected_collision_box, room_data["layout"], room_data["location"], constants.SQUARE_SIZE):
                    #print("no y collision")
                    is_crate_collision = False
                    pushed_y = False
                    collided_door = False
                    for door in doors:
                        if collision([*projected_collision_box["location"], *projected_collision_box["size"]], [*door.collision_box["location"], *door.collision_box["size"]]):
                            collided_door = True
                            break
                    if not collided_door:
                        for crate in crates:
                            if collision([*projected_collision_box["location"], *projected_collision_box["size"]], [*crate.collision_box["location"], *crate.collision_box["size"]]):
                                is_crate_collision = True
                                if self.held_keys["sprint"]:
                                    self.pushing = True
                                    if crate.move("up" if self.movement_vector[1] < 0 else "down", self.push_speed_multiplier, room, crates, doors, entities, []):
                                        if not pushed_y:
                                            pushed_y = True
                                            self.y_pos += (self.movement_vector[1]/abs(self.movement_vector[1])) * self.push_speed_multiplier
                                #break
                    if not (is_crate_collision or collided_door):
                        self.y_pos += (self.movement_vector[1]/abs(self.movement_vector[1]))
            # CHANGE COLLISION BOX LOCATION TO BE PROJECTED LOCATION
        
        
        
        
        # calculate movement state change
        if (self.state in ["idle", "run"] or (self.attack_cooldown == self.max_attack_cooldown)) and not self.pushing: # check that the state shouldnt be anything else
            if self.movement_vector == [0,0] and not self.state == "idle":
                self.change_state("idle")
            elif self.movement_vector != [0,0] and not self.state == "run":
                self.change_state("run") # check for running state (called "run"
                
        elif self.pushing and self.state != "push":
            self.change_state("push")
            
                
        self.collision_box["location"] = ((self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 23 + self.y_pos)
        
        for item in throw_away_items:
            throwing_velocity = 10
            if self.direction == "right":
                throwing_direction = [throwing_velocity,0]
            elif self.direction == "left":
                throwing_direction = [-1 * throwing_velocity,0]
            elif self.direction == "up":
                throwing_direction = [0,-1 * throwing_velocity]
            elif self.direction == "down":
                throwing_direction = [0,throwing_velocity]
            living_items.append(LivingItem(self.collision_box["location"][0] + (self.collision_box["size"][0]//2) + randint(0,20)-10,
                                            self.collision_box["location"][1] + randint(0,20)-10,
                                            item,
                                            throwing_direction))
        
        return False, living_items # Not dead
    
    
    def get_damage_multiplier(self): # not including hand (that is dealt with seperately)
        multiplier = 1
        for i in range(3): # Charms
            if self.inventory[8+i] != None:
                multiplier *= self.inventory[8+i].damage_multiplier
        return multiplier
    
    def get_speed_multiplier(self):
        multiplier = 1
        for i in range(6): # Charms and armour
            if self.inventory[8+i] != None:
                multiplier *= self.inventory[8+i].speed_multiplier
        return multiplier
    
    def get_mele_armour_multiplier(self):
        multiplier = 1
        for i in range(6): # Charms and armour
            if self.inventory[8+i] != None:
                multiplier *= self.inventory[8+i].mele_armour_multiplier
        return multiplier
    
    #
    def get_ranged_armour_multiplier(self):
        multiplier = 1
        for i in range(6): # Charms and armour
            if self.inventory[8+i] != None:
                multiplier *= self.inventory[8+i].ranged_armour_multiplier
        return multiplier
    
    def get_attack_speed_multiplier(self): # not including hand (that is dealt with seperately)
        multiplier = 1
        for i in range(3): # Charms
            if self.inventory[8+i] != None:
                multiplier *= self.inventory[8+i].attack_speed_multiplier
        return multiplier
        
    # MELE RANGE ONLY COMES FROM WEAPON
    #def get_mele_range_multiplier(self): # not including hand (that is dealt with seperately)
    #    multiplier = 1
    #    for i in range(3): # Armour
    #        if self.inventory[8+i] != None:
    #            multiplier *= self.inventory[8+i].attack_speed_multiplier
    #    return multiplier
        
    #
    def get_ranged_reload_multiplier(self):
        multiplier = 1
        for i in range(3): # Charms
            if self.inventory[8+i] != None:
                multiplier *= self.inventory[8+i].ranged_reload_multiplier
        return multiplier
    #
    def get_max_health_multiplier(self):
        multiplier = 1
        for i in range(3): # Charms
            if self.inventory[8+i] != None:
                multiplier *= self.inventory[8+i].max_health_multiplier
        return multiplier
    #
    def get_regen_speed(self):
        speed = 0
        for i in range(3): # Charms
            if self.inventory[8+i] != None:
                multiplier += self.inventory[8+i].regen_speed
        return speed
    
    def get_stamina_recharge_multiplier(self):
        multiplier = 1
        for i in range(3): # Charms
            if self.inventory[8+i] != None:
                multiplier *= self.inventory[8+i].stamina_recharge_multiplier
        return multiplier
        

# self.attack_speed_multiplier
# self.mele_range_multiplier 
# # Ranged
# self.ranged_reload_multiplier
# # Charms
# self.max_health_multiplier
# self.regen_speed = 0 # How much is added every tick to the regen speed timer (when timer is more than 1, it adds 1 health and resets to 0). Items do not add regen by default. Only works for charms
# self.stamina_recharge_mulitplier

    def teleport(self, x, y):
        self.x_pos = x
        self.y_pos = y
        
    def reassess_keys(self, key_bindings):
        keys = pygame.key.get_pressed()
        for key in key_bindings:
            if key_bindings[key] in self.held_keys:
                self.held_keys[key_bindings[key]] = keys[int(key)]
            
    
    def change_state(self, new_state):
        self.state = new_state
        self.animation_frame = 0
    
    def check_direction(self):
        if self.movement_vector != [0,0]:
            if self.movement_vector[0] == 0:
                if self.movement_vector[1] < 0:
                    self.direction = "up"
                else:
                    self.direction = "down"
            if self.movement_vector[0] < 0:
                self.direction = "left"
            elif self.movement_vector[0] > 0:
                self.direction = "right"
    
    def pick_up(self, living_item, living_items):
        if None in self.inventory:
            for s, slot in enumerate(self.inventory):
                if slot == None:
                    self.inventory[s] = living_item.item 
                    for i, item in enumerate(living_items):
                        if living_item == item:
                            living_items.pop(i)
                            break
                    break
        return living_items
                
    def attack(self, player, entities, room, damage):
        from functions.algorithms.getMovementVector import get_movement_vector
        from classes.global_data import constants_structure
        constants = constants_structure()
        self.change_state("attack")
        self.attack_timer = 3
        damage *= self.get_damage_multiplier()
        
        multiplier = 1
        if self.inventory[(0 if self.holding_main_hand else 1)] != None:
            multiplier = self.inventory[(0 if self.holding_main_hand else 1)].mele_range_multiplier
        
        reach = self.mele_reach * multiplier
        
        range_vector = get_movement_vector(reach, self.movement_vector)
        attack_loc = [(self.collision_box["location"][0] + (self.collision_box["size"][0]//2)) + range_vector[0],
                        (self.collision_box["location"][1] + (self.collision_box["size"][1]//2)) + range_vector[1]]
        
        effectedEntities, effectedSquares, playerEffected = aoeScanner(attack_loc, entities, room, player, reach, constants, True)
        
        drops = []
        
        # entities
        for entity in effectedEntities:
            if entity.team != self.team:
                killed, entity_drops = entity.take_damage(damage) # returns true if entity is killed
                if killed:
                    self.kills += 1
                    room.kills += 1
                for drop in entity_drops:
                    drops.append({"name": drop, 
                                    "x": entity.collision_box["location"][0],
                                    "y": entity.collision_box["location"][1]})
                #entity_push = get_movement_vector(self.mele_push_strength, [attack_loc[0] - range_vector[0],
                #                                                            attack_loc[1] - range_vector[1]])
                #entity.move(entity_push, room, forced=True)
        
        for square in effectedSquares:
            square_obj = room.layout[square[1]][square[0]]
            if square_obj.breakable:
                square_drops = square_obj.take_damage(damage, room)
                for drop in square_drops:
                    drops.append({"name": drop, 
                                    "x": square[0]*constants.SQUARE_SIZE[0] + room.location[0],
                                    "y": square[1]*constants.SQUARE_SIZE[1] + room.location[1]})
        return drops
                
    def take_damage(self, damage, damage_type="mele"):
        self.change_state("take_damage")
        
        if damage_type == "mele":
            damage *= self.get_mele_armour_multiplier()
        elif damage_type == "ranged":
            damage *= self.get_ranged_armour_multiplier()
        
        self.health -= damage
        if self.health <= 0:
            self.die()
            
    def die(self):
        self.change_state("death")
        
        
    def save(self, level, room_id):
        import json
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        inventory_data = []
        for item in self.inventory:
            if item is not None:
                inventory_data.append(item.save())
            else:
                inventory_data.append(None)
            
        data = {
        "lives": self.lives,
        "max_health": self.max_health,
        "health": self.health,
        "x": self.x_pos,
        "y": self.y_pos,
        "current_room": room_id,
        "direction": self.direction,
        "speed": self.speed,
        "push_pull_speed": self.push_pull_speed,
        "max_sprint_stamina": self.max_sprint_stamina,
        "sprint_stamina": self.sprint_stamina,
        "max_boost_time": self.max_boost_time,
        "boost_cooldown": self.boost_cooldown,
        "boost_speed": self.boost_speed,

        "mele_reach": self.mele_reach,
        "mele_push_strength": self.mele_push_strength,
        "attack_damage": self.attack_damage,
        "max_attack_cooldown": self.max_attack_cooldown,

        "inventory": inventory_data,

        "holding_main_hand": self.holding_main_hand,

        "kills": self.kills
        }
        
        
        
        
        with open(constants.FILE_PATH + f"data/account_games/{self.account_id}_games/{self.savegame_id}_levels/rooms_{level}/player.json", 'w') as file:
            json_string = json.dumps(data)
            file.write(json_string)
    
    def get_rendering_row(self):
        return self.collision_box["location"][1]
    
    def draw(self, screen):
        
        #pygame.draw.rect(screen, (0, 0, 0), (self.x_pos, self.y_pos, 10,10))
        
        from classes.global_data import constants_structure, draw_text
        constants = constants_structure()
        
        FPS = constants.MENU_FPS * 2
        
        if (self.state == "idle" or
            self.state == "run" or
            self.state == "push" or
            self.state == "pull" or
            self.state == "attack"):
            animation = self.state + "_" + self.direction
            
        else:
            animation = self.state
            
        # select hand
        self.hand_texture = pygame.Surface((1,1), pygame.SRCALPHA)
        if self.holding_main_hand:
            if self.inventory[0] != None:
                item_texture = self.inventory[0].game_texture
        else:
            if self.inventory[1] != None:
                item_texture = self.inventory[1].game_texture
        if (self.holding_main_hand and self.inventory[0] != None) or ((not self.holding_main_hand) and self.inventory[1] != None):
            if self.state == "attack":
                item_texture = pygame.transform.rotate(item_texture, self.animation_frame * -60)
            # find orientation and size
            if self.direction == "left" or self.direction == "up":
                item_texture = pygame.transform.flip(item_texture, True, False)
            item_texture = pygame.transform.scale(item_texture, (self.size[0]//3, self.size[1]//3))
            # blit to location
            temp_surface = pygame.Surface(self.size, pygame.SRCALPHA)
            if self.direction == "left" or self.direction == "up":
                temp_surface.blit(item_texture, (15,50))
            else:
                temp_surface.blit(item_texture, ((self.size[0]//2)+10, 50))
            self.hand_texture = temp_surface
            screen.blit(temp_surface, (self.x_pos, self.y_pos))
            
            
            
        # Player
        
        
        
        self.animation_cooldown += 1
        if self.sprinting:
            self.animation_cooldown *= self.sprint_multiplier
        if self.animation_cooldown >= FPS // (1/self.animation_frame_time):
            self.animation_cooldown = 0
            self.animation_frame += 1
            
        
        if self.animation_frame >= len(self.assets[animation]):
            self.animation_frame = 0
        
        self.chosen_asset = self.assets[animation][self.animation_frame]
        
        temp_surface = pygame.Surface(self.size, pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        temp_surface.blit(pygame.transform.scale(self.chosen_asset, self.size),(0,0))
        screen.blit(temp_surface, (self.x_pos, self.y_pos))
        
        # # DRAW COLLISON BOX:
        # temp_surface = pygame.Surface(self.size, pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        # pygame.draw.rect(temp_surface, (255, 0, 0, 127), (0, 0, *self.collision_box["size"]))
        # screen.blit(temp_surface, self.collision_box["location"])
        
        return screen
    
    def draw_overlay_data(self, screen, room_location, room_size):
        from classes.global_data import constants_structure, draw_text
        constants = constants_structure()
        
        # Draw borders
        # left:
        #pygame.draw.rect(screen, (156, 163, 167), (0,0, room_location[0] - constants.SQUARE_SIZE[0], constants.DEFAULT_SCREEN_SIZE[1]))
        #pygame.draw.rect(screen, (156, 163, 167), (0,0, room_location[0] - constants.SQUARE_SIZE[0], constants.DEFAULT_SCREEN_SIZE[1]))
        temp_surface = pygame.Surface(constants.GUI_WINDOW_SIZE, pygame.SRCALPHA) 
        side_bar = self.side_bar_asset
        if not constants.LANDSCAPE:
            side_bar = pygame.transform.rotate(side_bar, 90)
        temp_surface.blit(pygame.transform.scale(side_bar, constants.GUI_WINDOW_SIZE), (0,0))
        #temp_surface.blit(pygame.transform.flip(temp_surface, True, False), (0,0))
        screen.blit(temp_surface, (0,0))
        
        # Sprint energy
        sprint_energy_location = [(constants.GUI_WINDOW_SIZE[0] - self.inv_texture.get_width())//2 + (self.inv_texture.get_width() // 4 * 3), 20 + self.inv_texture.get_height() + 100]
        sprint_energy_size = [self.inv_texture.get_width() // 2 - 40, 20]
        screen = draw_text("Sprint", screen, constants.SMALL_FONT, sprint_energy_location, (255,255,255), "centre", "below")
        # Black background
        pygame.draw.rect(screen, (0, 0, 0), (sprint_energy_location[0] - (sprint_energy_size[0]//2), sprint_energy_location[1] - sprint_energy_size[1] - 10, *sprint_energy_size))
        # Green fill
        bar_width = int(sprint_energy_size[0] * self.sprint_stamina / self.max_sprint_stamina)
        pygame.draw.rect(screen, (0, 255, 0), (sprint_energy_location[0] - (sprint_energy_size[0]//2), sprint_energy_location[1] - 30, 
                                                bar_width, sprint_energy_size[1]))
        
        # Boost energy
        boost_energy_location = [(constants.GUI_WINDOW_SIZE[0] - self.inv_texture.get_width())//2 + (self.inv_texture.get_width() // 4), 20 + self.inv_texture.get_height() + 100]
        boost_energy_size = [self.inv_texture.get_width() // 2 - 40, 20]
        screen = draw_text("Boost", screen, constants.SMALL_FONT, boost_energy_location, (255,255,255), "centre", "below")
        # Black background
        pygame.draw.rect(screen, (0, 0, 0), (boost_energy_location[0] - (boost_energy_size[0]//2), boost_energy_location[1] - boost_energy_size[1] - 10, *boost_energy_size))
        # Green fill
        bar_width = int(boost_energy_size[0] * self.boost_cooldown / self.max_boost_time)
        pygame.draw.rect(screen, (0, 255, 0), (boost_energy_location[0] - (boost_energy_size[0]//2), boost_energy_location[1] - 30, 
                                                bar_width, boost_energy_size[1]))
        
        
        # Health
        health_bar_location = [(constants.GUI_WINDOW_SIZE[0] - self.inv_texture.get_width())//2 + (self.inv_texture.get_width() // 2), 20 + self.inv_texture.get_height() + 40]
        health_bar_size = [self.inv_texture.get_width(), 20]
        screen = draw_text("Health", screen, constants.SMALL_FONT, health_bar_location, (255,255,255), "centre", "below")
        # Black background
        pygame.draw.rect(screen, (0, 0, 0), (health_bar_location[0] - (health_bar_size[0]//2), health_bar_location[1] - health_bar_size[1] - 10, *health_bar_size))
        # Green fill
        bar_width = int(health_bar_size[0] * self.health / self.max_health)
        pygame.draw.rect(screen, (0, 255, 0), (health_bar_location[0] - (health_bar_size[0]//2), health_bar_location[1] - health_bar_size[1] - 10, 
                                                bar_width, health_bar_size[1]))
        
        
        
        
        # INVENTORY
        inv_location = ((constants.GUI_WINDOW_SIZE[0] - self.inv_texture.get_width())//2, 20) #(room_location[0] + room_size[0] + 20, int((constants.DEFAULT_SCREEN_SIZE[1]//2) - (2.5*constants.INV_ITEM_SIZE[1])))
        temp_surface = pygame.Surface(constants.GUI_WINDOW_SIZE, pygame.SRCALPHA) 
        temp_surface.blit(self.inv_texture, inv_location)
        screen.blit(temp_surface, (0,0))
        if self.holding_main_hand:
            temp_surface.blit(self.selected_inv_texture, (inv_location[0] + 3, inv_location[1] + (constants.INV_ITEM_SIZE[1] * 4)))
        else:
            temp_surface.blit(self.selected_inv_texture, (inv_location[0] - 3 + (constants.INV_ITEM_SIZE[0] * 2), inv_location[1] + (constants.INV_ITEM_SIZE[1] * 4)))
        screen.blit(temp_surface, (0,0))
        
        if self.inventory[0] != None:
            # print("has mainhand")
            self.inventory[0].draw_inv(screen, (inv_location[0], inv_location[1] + (4*constants.INV_ITEM_SIZE[1])))
            #temp_surface.blit(pygame.transform.scale(self.inventory[0].inv_texture, constants.INV_ITEM_SIZE), (inv_location[0], inv_location[1] + (4*constants.INV_ITEM_SIZE[1])))
        
        #screen.blit(self.inv_square_texture, (inv_location[0] + (2*constants.INV_ITEM_SIZE[0]), inv_location[1] + (4*constants.INV_ITEM_SIZE[1])))
        if self.inventory[1] != None:
            self.inventory[1].draw_inv(screen, (inv_location[0] + (2*constants.INV_ITEM_SIZE[0]), inv_location[1] + (4*constants.INV_ITEM_SIZE[1])))
        
        for row in range(4):
            for item in range(3):
                item_i = 2 + (row * 3) + item
                #screen.blit(self.inv_square_texture, (inv_location[0] + (item*constants.INV_ITEM_SIZE[0]), inv_location[1] + (row*constants.INV_ITEM_SIZE[1])))
                if self.inventory[item_i] != None:
                    self.inventory[item_i].draw_inv(screen, (inv_location[0] + (item*constants.INV_ITEM_SIZE[0]), inv_location[1] + (row*constants.INV_ITEM_SIZE[1])))
        
        #screen.blit(temp_surface, (0,0))
        
        
        # LIVES
        
        temp_surface = pygame.Surface([self.lives * (constants.LIVES_SIZE[0] + 15), constants.LIVES_SIZE[1]], pygame.SRCALPHA) 
        
        for life in range(self.lives):
            temp_surface.blit(self.lives_texture, [life * (constants.LIVES_SIZE[0] + 15), 0])
        
        screen.blit(temp_surface, [53, 545])
            
        
        return screen
    
    def initiate_assets(self, constants):
        self.assets = {}
        #with open(constants.FILE_PATH + "project_lib/assets/player/main.png", 'r') as asset_file:
        
        
        master_texture = pygame.image.load(constants.FILE_PATH + "project_lib/assets/player/main.png").convert() # Use text input button design
        images = []
        for row in range(master_texture.get_height()//48):
            row_textures = []
            for image in range(master_texture.get_width()//48):
                texture_surface = pygame.Surface((48, 48))
                texture_surface.blit(master_texture, (0, 0), (48*image, 48*row, 48, 48))
                row_textures.append(texture_surface)
            images.append(row_textures)
            
        # Existing assets
        self.assets["idle_up"] = images[1][:8]
        self.assets["idle_down"] = images[0][:8]
        self.assets["run_up"] = images[3][:6]
        self.assets["run_down"] = images[2][:6]
        
        self.assets["attack_right"] = images[2][6:9]
        self.assets["attack_down"] = images[3][6:9]
        self.assets["attack_up"] = images[4][6:9]
        
        self.assets["push_right"] = images[4][:6]
        self.assets["pull_left"] = images[5][:6]
        
        self.assets["take_damage"] = images[5][6:9]
        
        self.assets["push_up"] = images[6][:4]
        self.assets["pull_up"] = images[7][:4]
        self.assets["pull_down"] = images[6][4:9]
        self.assets["push_down"] = images[7][4:9]
        
        self.assets["death"] = images[8][:5]
        self.assets["fall"] = images[9][:5]
        
        # Derived assets
        
        self.assets["idle_left"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["idle_down"]] # this line of code returns a flipped version of every frame of the animation
        self.assets["run_left"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["run_down"]]
        self.assets["attack_left"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["attack_right"]]
        self.assets["push_left"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["push_right"]]
        
        self.assets["idle_right"] = self.assets["idle_down"]
        self.assets["run_right"] = self.assets["run_down"]
        self.assets["pull_right"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["pull_left"]]

        # DRAW BOOST ANIMATION



projects/final/classes/entity.py


import pygame
from functions.algorithms.aoeScanner import aoeScanner

class Entity:
    def __init__(self, x, y, type, room_loc, drops):
        # Constants
        from classes.global_data import constants_structure
        constants = constants_structure()

        self.initiate_assets(type, constants)
        
        self.type = type
        self.state = "idle"
        self.direction = "down"
        
        self.x_pos = (x * constants.SQUARE_SIZE[0]) + room_loc[0] - 50
        self.y_pos = (y * constants.SQUARE_SIZE[1]) + room_loc[1] - 60
        #print(x, y)
        #print(self.x_pos, self.y_pos)
        
        self.movement_vector = [0,0]
        self.speed = 2
        self.size = (150,150)
        self.animation_frame_time = 0.1
        self.animation_cooldown = 0
        self.max_health = 5
        self.health = self.max_health
        self.mele_reach = 60
        self.attack_damage = 3
        self.attack_timer = 0
        self.team = None
        
        # path is an array of coordinates that lead to a destination, allowing navigation around corners
        #self.path = []
        
        
        self.collision_box = {"size": (48, 25),
                            "location": [(self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 40 + self.y_pos]}
        
        self.get_square = lambda room : [int((self.collision_box["location"][0] - room.location[0])//constants.SQUARE_SIZE[0]),
                                        int((self.collision_box["location"][1] - room.location[1])//constants.SQUARE_SIZE[1])]
        
        # possible states: idle, run, sprint, boost, push, pull, attack, take_damage, death, fall
        self.change_state("spawn")
        
        self.drops = self.calculate_drops(drops)
        
        
    def move(self, destination, room_data, crates, doors, forced = False):
        # path can either be algorithmic path to player, or path to random local location if entity is idle
        # CALCULATE MOVEMENT VECTOR
        if not forced:
            from functions.algorithms.getMovementVector import get_movement_vector
            self.movement_vector = get_movement_vector(self.speed, [destination[0] - self.collision_box["location"][0],  destination[1] - self.collision_box["location"][1]])
        else:
            self.movement_vector = destination
        # movement vector will be next travel coordinate
        # if [self.x_pos, self.y_pos] == self.path[0]:
        #     self.path.pop(0)
            
        # if self.path != []:
        #     from functions.algorithms.getMovementVector import get_movement_vector
        #     self.movement_vector = get_movement_vector(self.speed, self.path[0]) # destination is the 0th item of the path
        
        from functions.algorithms.collision_detection import is_colliding, collision
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        can_move = [False, False]
        self.collision_box["location"] = [(self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 23 + self.y_pos]
        
        
        
        # X
        projected_collision_box = {
            "size": self.collision_box["size"],
            "location": [self.collision_box["location"][0] + self.movement_vector[0], self.collision_box["location"][1]]
        }
        
        if not is_colliding(projected_collision_box, room_data.layout, room_data.location, constants.SQUARE_SIZE):
            can_move[0] = True
            
        for door in doors:
            if collision([*projected_collision_box["location"], *projected_collision_box["size"]], [*door.collision_box["location"], *door.collision_box["size"]]):
                can_move[0] = False
                
        for crate in crates:
            if collision([*projected_collision_box["location"], *projected_collision_box["size"]], [*crate.collision_box["location"], *crate.collision_box["size"]]):
                can_move[0] = False
                break
            
            
        # Y
        projected_collision_box = {
            "size": self.collision_box["size"],
            "location": [self.collision_box["location"][0], self.collision_box["location"][1] + self.movement_vector[1]]
        }
        if not is_colliding(projected_collision_box, room_data.layout, room_data.location, constants.SQUARE_SIZE):
            can_move[1] = True
        
        for door in doors:
            if collision([*projected_collision_box["location"], *projected_collision_box["size"]], [*door.collision_box["location"], *door.collision_box["size"]]):
                can_move[1] = False
                
        for crate in crates:
            if collision([*projected_collision_box["location"], *projected_collision_box["size"]], [*crate.collision_box["location"], *crate.collision_box["size"]]):
                can_move[1] = False
                break
        
        if can_move[0] and can_move[1]:
            self.x_pos += self.movement_vector[0]
            self.y_pos += self.movement_vector[1]
        elif can_move[0]:
            self.x_pos += (self.movement_vector[0]//abs(self.movement_vector[0])) * self.speed
        elif can_move[1]:
            self.y_pos += (self.movement_vector[1]//abs(self.movement_vector[1])) * self.speed
        
        # calculate animation state change
        #print(self.movement_vector)
        #if self.state in ["idle", "run"]: # check that the state shouldnt be anything else
        if self.movement_vector == [0,0] and not self.state == "idle":
            self.change_state("idle")
        elif self.movement_vector != [0,0] and not self.state == "run":
            self.change_state("run") # check for running state (called "run"
                
        self.check_direction()
                
        self.collision_box["location"] = [(self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 23 + self.y_pos]
        
    def push(self, direction, speed, room, crates, doors):
        from functions.algorithms.collision_detection import is_colliding, collision
        from classes.global_data import constants_structure
        constants = constants_structure()
        # must check if move can be done, and then carry it out. wether it can and has been done should be returned to the player
        
        # Will not push item right to edge, due to only moving at speed. 
        # Maybe implement system sothat if there is a collision, it checks 
        # every distance it could move between 1 and the speed so that it 
        # goes right to the edge. This will help with squeezing through thin gaps
        
        # self.collision_box = {"location": [self.x_pos, self.y_pos],
        #                 "size": constants.SQUARE_SIZE}
        
        if direction == "left":
            self.collision_box["location"][0] -= speed
        elif direction == "right":
            self.collision_box["location"][0] += speed
        elif direction == "up":
            self.collision_box["location"][1] -= speed
        elif direction == "down":
            self.collision_box["location"][1] += speed
        
        colliding = is_colliding(self.collision_box, room.layout, room.location, constants.SQUARE_SIZE)
        
        # Doors
        if not colliding:
            for door in doors:
                if collision([*self.collision_box["location"], *self.collision_box["size"]], [*door.collision_box["location"], *door.collision_box["size"]]):
                    colliding = True
                    break
        
        # Crates
        if not colliding:
            hit_crate = False
            for crate in crates:
                if collision([*self.collision_box["location"], *self.collision_box["size"]], 
                            [*crate.collision_box["location"], *crate.collision_box["size"]]):
                    hit_crate = True
                    colliding = True
                    # if crate.move(direction, speed, room, crates, moved_crates):
                    #     self.x_pos = self.collision_box["location"][0] - (self.width * 0.05)
                    #     self.y_pos = self.collision_box["location"][1] - (self.height //2)
                    # else: 
                    #     colliding = True
            if not hit_crate:
                if direction == "left" or direction == "right":
                    self.x_pos += speed * (-1 if direction == "left" else 1)
                else:
                    self.y_pos += speed * (-1 if direction == "up" else 1)
            
        self.collision_box["location"] = [(self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 23 + self.y_pos]
        
        return not colliding # can move
    
    def change_state(self, new_state):
        self.state = new_state
        self.animation_frame = 0
    
    def check_direction(self):
        if self.movement_vector != [0,0]:
            if self.movement_vector[0] == 0:
                if self.movement_vector[1] < 0:
                    self.direction = "up"
                else:
                    self.direction = "down"
            if self.movement_vector[0] < 0:
                self.direction = "left"
            elif self.movement_vector[0] > 0:
                self.direction = "right"
                
                
    def attack(self, player, entities, room):
        from functions.algorithms.getMovementVector import get_movement_vector
        from classes.global_data import constants_structure
        constants = constants_structure()
        self.change_state("attack")
        self.attack_timer = 3
        
        range_vector = get_movement_vector(self.mele_reach, self.movement_vector)
        attack_loc = [(self.collision_box["location"][0] + (self.collision_box["size"][0]//2)) + range_vector[0],
                        (self.collision_box["location"][1] + (self.collision_box["size"][1]//2)) + range_vector[1]]
        effectedEntities, effectedSquares, playerEffected = aoeScanner(attack_loc, entities, room, player, self.mele_reach, constants)
        
        # player
        if playerEffected and (self.team != player.team):
            player.take_damage(self.attack_damage)
        # entities
        for entity in effectedEntities:
            if entity.team != self.team:
                entity.take_damage(self.attack_damage)
        
    def take_damage(self, damage):
        self.change_state("take_damage")
        self.health -= damage
        if self.health <= 0:
            self.die()
            return True, self.drops
        return False, []
            
    def die(self):
        if self.state != "death":
            self.change_state("death")
            
    def calculate_drops(self, drops):
        from random import randint
        out_drops = []
        for set in drops: # for every seperate set of rolls
            set_drops = []
            for item in set["drops"]:
                for instance in range(item["chance"]):
                    payload = {}
                    if "payload" in item:
                        payload = item["payload"]
                    set_drops.append({"item": item["item"], "payload": payload}) # makes one long array with all possible choices
                    
            while len(set_drops) < set["total"]:
                set_drops.append(None) # complete list to length
                    
            for roll in range(set["rolls"]):
                out_drops.append(set_drops[randint(0, set["total"]-1)])
        return out_drops
            
            
    def save(self, room_loc):
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        data = {
            "name": self.type,
            "x": (self.x_pos + 50 - room_loc[0]) / constants.SQUARE_SIZE[0],
            "y": (self.y_pos + 60 - room_loc[1]) / constants.SQUARE_SIZE[1],
            "health": self.health
            }
        return data

    
        #self.x_pos = (x * constants.SQUARE_SIZE[0]) + room_loc[0] - 50
        #self.y_pos = (y * constants.SQUARE_SIZE[1]) + room_loc[1] - 60
        
    def get_rendering_row(self):
        return self.collision_box["location"][1]
        
    def draw(self, screen):
        
        #pygame.draw.rect(screen, (0, 0, 0), (self.x_pos, self.y_pos, 10,10))
        
        from classes.global_data import constants_structure, draw_text
        constants = constants_structure()
        
        FPS = constants.MENU_FPS * 2
        
        if (self.state == "idle" or
            self.state == "run" or
            self.state == "push" or
            self.state == "pull" or
            self.state == "attack"):
            animation = self.state + "_" + self.direction
            
        else:
            animation = self.state
            
        
        self.chosen_asset = self.assets[animation][self.animation_frame]
        
        temp_surface = pygame.Surface(self.size, pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        temp_surface.blit(pygame.transform.scale(self.chosen_asset, self.size),(0,0))
        screen.blit(temp_surface, (self.x_pos, self.y_pos))
        
        self.animation_cooldown += 1
    
        if self.animation_cooldown >= FPS // (1/self.animation_frame_time):
            self.animation_cooldown = 0
            self.animation_frame += 1
            
        
        if self.animation_frame == len(self.assets[animation]):
            self.animation_frame = 0
        
        
        # DRAW COLLISON BOX:
        # temp_surface = pygame.Surface(self.size, pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        # pygame.draw.rect(temp_surface, (255, 0, 0, 127), (0, 0, *self.collision_box["size"]))
        # screen.blit(temp_surface, self.collision_box["location"])
        
        
        # Draw details
        # Health bar
        if self.health != self.max_health:
            health_bar_location = [self.collision_box["location"][0] + (self.collision_box["size"][0]//2), self.collision_box["location"][1] + self.collision_box["size"][1] + 10]
            health_bar_size = [self.collision_box["size"][0], 5]
            # Black background
            pygame.draw.rect(screen, (0, 0, 0), (health_bar_location[0] - (health_bar_size[0]//2), health_bar_location[1] - health_bar_size[1] - 10, *health_bar_size))
            # Green fill
            bar_width = int(health_bar_size[0] * self.health / self.max_health)
            pygame.draw.rect(screen, (0, 255, 0), (health_bar_location[0] - (health_bar_size[0]//2), health_bar_location[1] - health_bar_size[1] - 10, 
                                                    bar_width, health_bar_size[1]))
        
        
        return screen
    
    def initiate_assets(self, type, constants):
        self.assets = {}
        #with open(constants.FILE_PATH + "project_lib/assets/player/main.png", 'r') as asset_file:
        
        
        master_texture = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/entities/{type}.png").convert() # Use text input button design
        images = []
        for row in range(master_texture.get_height()//48):
            row_textures = []
            for image in range(master_texture.get_width()//48):
                texture_surface = pygame.Surface((48, 48))
                texture_surface.blit(master_texture, (0, 0), (48*image, 48*row, 48, 48))
                row_textures.append(texture_surface)
            images.append(row_textures)
            
        # Existing assets
        self.assets["idle_up"] = images[1][:8]
        self.assets["idle_down"] = images[0][:8]
        self.assets["run_up"] = images[3][:6]
        self.assets["run_down"] = images[2][:6]
        
        self.assets["attack_right"] = images[2][6:9]
        self.assets["attack_down"] = images[3][6:9]
        self.assets["attack_up"] = images[4][6:9]
        
        self.assets["push_right"] = images[4][:6]
        self.assets["pull_left"] = images[5][:6]
        
        self.assets["take_damage"] = images[5][6:9]
        
        self.assets["push_up"] = images[6][:4]
        self.assets["pull_up"] = images[7][:4]
        self.assets["pull_down"] = images[6][4:9]
        self.assets["push_down"] = images[7][4:9]
        
        self.assets["death"] = images[8][:5]
        self.assets["fall"] = images[9][:5]
        
        # Derived assets
        
        self.assets["idle_left"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["idle_down"]] # this line of code returns a flipped version of every frame of the animation
        self.assets["run_left"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["run_down"]]
        self.assets["attack_left"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["attack_right"]]
        self.assets["push_left"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["push_right"]]
        
        self.assets["idle_right"] = self.assets["idle_down"]
        self.assets["run_right"] = self.assets["run_down"]
        self.assets["pull_right"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["pull_left"]]

        self.assets["spawn"] = images[8][:5]
        self.assets["spawn"].reverse()
        # DRAW BOOST ANIMATION



projects/final/classes/square.py
import copy
import pygame

class Square:
    def __init__(self, square, default, file_path, square_size, location, grid_loc):
        self.data = copy.deepcopy(default)
        for data in square:
            self.data[data] = square[data]
        
        
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        self.id = self.data["id"]
    
        self.collidable = self.data["collidable"]
        self.breakable = self.data["breakable"]
        self.health = self.data["strength"]
        
        self.grid_loc = grid_loc
        
        self.location = location
        self.x_pos = location[0]
        self.width = int(self.data["collision_size"][0] * constants.SQUARE_SIZE[0])
        self.y_pos = location[1]
        self.height = int(self.data["collision_size"][1] * constants.SQUARE_SIZE[1])
        
        self.collision_x = ((constants.SQUARE_SIZE[0] - self.width)//2) + self.x_pos
        self.collision_y = ((constants.SQUARE_SIZE[1] - self.height)//2) + self.y_pos
        
        texture_names = self.data["textures"]
        #size = constants.SQUARE_SIZE
        #if self.id == 1:
        #    size = [constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 1.5]
            
        self.textures = [pygame.transform.scale(pygame.image.load(file_path + f"project_lib/assets/squares/{texture_name}.png").convert(), square_size) for texture_name in texture_names]
            
        self.texture_pos = [constants.SQUARE_SIZE[0] * self.data["texture_pos"][0], constants.SQUARE_SIZE[1] * self.data["texture_pos"][1]]
    
    def get_rendering_row(self):
        return self.y_pos

    def draw(self, screen):
        if self.data["transparent"]:
            temp_surface = pygame.Surface([self.textures[0].get_width(), self.textures[0].get_height()], pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
            temp_surface.blit(self.textures[0],(0,0))
            screen.blit(temp_surface, (self.x_pos + self.texture_pos[0], self.y_pos + self.texture_pos[1]))
        else:
            screen.blit(self.textures[0], (self.x_pos + self.texture_pos[0], self.y_pos + self.texture_pos[1])) # only doing 0 for now, since there are no animations yet
                
        # collision box
        # if self.collidable:
        #     from classes.global_data import constants_structure
        #     constants = constants_structure()
        #     temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA)
        #     pygame.draw.rect(temp_surface, (255, 0, 0,127), (self.collision_x, self.collision_y, self.width, self.height))
        #     screen.blit(temp_surface, (0,0))
        
        
        return screen
    
    def calculate_drops(self):
        from random import randint
        drops = []
        for set in self.data["drops"]: # for every seperate set of rolls
            set_drops = []
            for item in set["drops"]:
                for instance in range(item["chance"]):
                    payload = {}
                    if "payload" in item:
                        payload = item["payload"]
                    set_drops.append({"item": item["item"], "payload": payload})
            while len(set_drops) < set["total"]:
                set_drops.append(None) # complete list to length
                    
            for roll in range(set["rolls"]):
                drops.append(set_drops[randint(0, set["total"]-1)])
        return drops
    
    def take_damage(self, damage, room):
        self.health -= damage
        drops = []
        if self.health <= 0:
            drops = self.destroy(room)
        return drops
    
    def destroy(self, room):
        import json
        from classes.square import Square
        from classes.global_data import constants_structure
        constants = constants_structure()
        squares_data = json.load(open(constants.FILE_PATH + "data/squares/squares_data.json", "r"))
        default_square = json.load(open(constants.FILE_PATH + "data/squares/default_square.json", "r"))
        
        drops = []
        # sort drops
        if self.data["has_drops"]:
            drops = self.calculate_drops()
        
        # do break
        room.layout[self.grid_loc[1]][self.grid_loc[0]] = Square(squares_data[0], default_square, constants.FILE_PATH, constants.SQUARE_SIZE, self.location, self.grid_loc)
        
        return drops
    
    def save(self):
        return self.id



projects/final/classes/item.py


import pygame

class Item:
    def __init__(self, type, payload=None):
        # Armour
        self.speed_multiplier = 1
        self.mele_armour_multiplier = 1
        self.ranged_armour_multiplier = 1
        # Mele
        self.damage_multiplier = 1
        self.attack_speed_multiplier = 1
        self.mele_range_multiplier = 1
        # Ranged
        self.ranged_reload_multiplier = 1
        # Charms
        self.max_health_multiplier = 1
        self.regen_speed = 0 # How much is added every tick to the regen speed timer (when timer is more than 1, it adds 1 health and resets to 0). Items do not add regen by default. Only works for charms
        self.stamina_recharge_multiplier = 1
        
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        self.sort = "generic"
        self.type = type
        self.payload = payload
        self.game_texture = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/items/{type}.png").convert()
        self.inv_texture = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/items/{type}.png").convert()
        
    
    def draw_inv(self, screen, location):
        
        from classes.global_data import constants_structure, draw_text
        constants = constants_structure()
        
        temp_surface = pygame.Surface(constants.INV_ITEM_SIZE, pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        temp_surface.blit(pygame.transform.scale(self.inv_texture, (constants.INV_ITEM_SIZE[0] - 24, constants.INV_ITEM_SIZE[1] - 24)),(12,12))
        screen.blit(temp_surface, location)
        
        return screen
        
        
    def save(self):
        return {
            "item": self.type, 
            "payload": None
            }
        



projects/final/classes/room.py
import json
import pygame

class Room:
    def __init__(self, data, level, game_data):
        from classes.square import Square
        from classes.special_squares.door import Door
        from classes.special_squares.mechanical_door import MechanicalDoor
        from classes.special_squares.objective_door import ObjectiveDoor
        from classes.entities.moveable_squares.crate import Crate
        from classes.special_squares.button import Button
        from classes.special_squares.lever import Lever
        from classes.special_squares.ladder import Ladder
        from classes.special_squares.keyhole_wall import Keyhole
        
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        self.account_id = game_data["account_id"]
        self.savegame_id = game_data["savegame_id"]
        
        self.level = level
        
        self.kills = 0
        
        # Squares
        
        self.layout = []
        self.doors = []
        self.crates = []
        self.buttons = []
        self.levers = []
        self.ladder = None
        
        squares_data = json.load(open(constants.FILE_PATH + "data/squares/squares_data.json", "r"))
        default_square = json.load(open(constants.FILE_PATH + "data/squares/default_square.json", "r"))
        
        self.size = [len(data["squares"][0]) * constants.SQUARE_SIZE[0], len(data["squares"]) * constants.SQUARE_SIZE[1]]
        self.location = ((constants.GAME_WINDOW_SIZE[0] - self.size[0]) // 2, (constants.GAME_WINDOW_SIZE[1] - self.size[1]) // 2) 
        
        for y, row in enumerate(data["squares"]):
            new_row = [None for i in range(len(row))]
            for x, square in enumerate(row):
                square_int = False
                if isinstance(square, int):
                    square_int = True
                if square_int  and  squares_data[square]["basic"]:
                    size = constants.SQUARE_SIZE
                    if "size" in squares_data[square]:
                        size = [constants.SQUARE_SIZE[0] * squares_data[square]["size"][0], constants.SQUARE_SIZE[1] * squares_data[square]["size"][1]]
                    new_row[x] = Square(squares_data[square], default_square, constants.FILE_PATH, size, [self.location[0] + (x * constants.SQUARE_SIZE[0]), self.location[1] + (y * constants.SQUARE_SIZE[1])], [x,y])

                else:
                    if isinstance(square, int):
                        square_name = squares_data[square]["name"]
                    else:
                        square_name = (squares_data[square["id"]]["name"])
                    
                    if square_name.endswith("door"):
                        # DOORS
                        new_row[x] = Square(squares_data[0], default_square, constants.FILE_PATH, constants.SQUARE_SIZE, [self.location[0] + (x * constants.SQUARE_SIZE[0]), self.location[1] + (y * constants.SQUARE_SIZE[1])], [x,y])
                        if square["pos"][1] == "t":
                            corner = "top_"
                        else:
                            corner = "bottom_"
                        if square["pos"][2] == "l":
                            corner += "left"
                        else:
                            corner += "right"
                            
                        if square_name.startswith("mechanical"):
                            self.doors.append(MechanicalDoor(x, y, corner, square["pos"][0], self.location, square["colour"], is_open=(square["open"] if "open" in square else False)))
                        
                        elif square_name.startswith("keyhole"):
                            self.doors.append(MechanicalDoor(x, y, corner, square["pos"][0], self.location, square["colour"], "keyhole", is_open=(square["open"] if "open" in square else False)))
                            
                        else:
                            self.doors.append(Door(x, y, corner, square["pos"][0], self.location))
                    
                    elif square_name.startswith("button"):
                        # BUTTONS
                        new_row[x] = Square(squares_data[0], default_square, constants.FILE_PATH, constants.SQUARE_SIZE, [self.location[0] + (x * constants.SQUARE_SIZE[0]), self.location[1] + (y * constants.SQUARE_SIZE[1])], [x,y])
                        self.buttons.append(Button(square["colour"], (x,y), self.location))
                    
                    elif square_name.startswith("lever"):
                        # LEVERS
                        new_row[x] = Square(squares_data[0], default_square, constants.FILE_PATH, constants.SQUARE_SIZE, [self.location[0] + (x * constants.SQUARE_SIZE[0]), self.location[1] + (y * constants.SQUARE_SIZE[1])], [x,y])
                        flicked = False
                        if "flicked" in square:
                            flicked = square["flicked"]
                        self.levers.append(Lever(square["colour"], flicked, (x,y), self.location))
                    
                    elif square_name == "crate":
                        # CRATE
                        new_row[x] = Square(squares_data[0], default_square, constants.FILE_PATH, constants.SQUARE_SIZE, [self.location[0] + (x * constants.SQUARE_SIZE[0]), self.location[1] + (y * constants.SQUARE_SIZE[1])], [x,y])
                        self.crates.append(Crate(x, y, self.location))
                    
                    elif square_name == "ladder":
                        # LADDER
                        new_row[x] = Square(squares_data[0], default_square, constants.FILE_PATH, constants.SQUARE_SIZE, [self.location[0] + (x * constants.SQUARE_SIZE[0]), self.location[1] + (y * constants.SQUARE_SIZE[1])], [x,y])
                        self.ladder = Ladder(x, y, self.location)
                    
                    elif square_name == "keyhole_wall":
                        # KEYHOLE
                        new_row[x] = Keyhole(x, y, self.location, square["colour"])
                        #self.crates.append(Crate(x, y, self.location))
                        
            
            self.layout.append(new_row)
            
        
        
        
        # Entities
        from functions.algorithms.item_lookup import lookup as i_lookup
        from functions.algorithms.entity_lookup import lookup as e_lookup
        self.entities = []
        self.living_items = []
        
        for entity in data["entities"]:
            entity_class = e_lookup(entity["name"])
            if entity["name"] == "crate":
                self.crates.append(entity_class(entity["x"], entity["y"], self.location))
                continue
            elif entity["name"] == "item": 
                self.living_items.append(entity_class(entity["x"], entity["y"], i_lookup(entity["item"])(entity["payload"])))
                continue
            health = -1
            if "health" in entity:
                health = entity["health"]
            drops = {}
            if "drops" in entity:
                drops = entity["drops"]
            self.entities.append(entity_class(entity["x"], entity["y"], health, self.location, drops))
            
        
        self.active_colours = {}
        for trigger in [*self.levers, *self.buttons]:
            self.active_colours[str(trigger.colour)] = False
            
        self.id = data["id"]
        self.objectives = data["doors"]
        
        # update the way that data["doors"] and self.gates works so that the value is either None, 
        # meaning no door, or a string that corresponds to an objective. The objectives can then 
        # be checked, and different doors should be designed that can only be opened by room objectives:
        
        # for objective in self.objectives:
        #     if self.objectives[objective] is not None:
        
        self.objective_doors = []
        self.objective_icons = []
        from classes.objective_icon import ObjectiveIndicator
        for objective in self.objectives:
            if self.objectives[objective] is not None:
                self.objective_icons.append(ObjectiveIndicator(objective, self.objectives[objective]))
                if not ("colour" in self.objectives[objective]):
                    self.objectives[objective]["colour"] = None
        
        non_navigable_air = Square(squares_data[7], default_square, constants.FILE_PATH, constants.SQUARE_SIZE, [self.location[0] + (x * constants.SQUARE_SIZE[0]), self.location[1] + (y * constants.SQUARE_SIZE[1])], [x,y])
        if self.objectives["left"] is not None:
            self.layout[len(self.layout)//2-1][0] = non_navigable_air
            self.layout[len(self.layout)//2][0] = non_navigable_air
            if self.objectives["left"]["type"] != "empty":
                self.objective_doors.append(self.objective_door_generate(self.objectives["left"]["type"], 0, len(self.layout)//2-1, "top_right", "v", self.objectives["left"]["colour"], "left"))
                self.objective_doors.append(self.objective_door_generate(self.objectives["left"]["type"], 0, len(self.layout)//2, "bottom_right", "v", self.objectives["left"]["colour"], "left"))
            
        if self.objectives["right"] is not None:
            self.layout[len(self.layout)//2-1][len(self.layout[0])-1] = non_navigable_air
            self.layout[len(self.layout)//2][len(self.layout[0])-1] = non_navigable_air
            if self.objectives["right"]["type"] != "empty":
                self.objective_doors.append(self.objective_door_generate(self.objectives["right"]["type"], len(self.layout[0])-1, len(self.layout)//2-1, "top_left", "v", self.objectives["right"]["colour"], "right"))
                self.objective_doors.append(self.objective_door_generate(self.objectives["right"]["type"], len(self.layout[0])-1, len(self.layout)//2, "bottom_left", "v", self.objectives["right"]["colour"], "right"))
            
        if self.objectives["up"] is not None:
            self.layout[0][len(self.layout[0])//2-1] = non_navigable_air
            self.layout[0][len(self.layout[0])//2] = non_navigable_air
            if self.objectives["up"]["type"] != "empty":
                self.objective_doors.append(self.objective_door_generate(self.objectives["up"]["type"], len(self.layout[0])//2-1, 0, "bottom_left", "h", self.objectives["up"]["colour"], "up"))
                self.objective_doors.append(self.objective_door_generate(self.objectives["up"]["type"], len(self.layout[0])//2, 0, "bottom_right", "h", self.objectives["up"]["colour"], "up"))
            
        if self.objectives["down"] is not None:
            self.layout[len(self.layout)-1][len(self.layout[0])//2-1] = non_navigable_air
            self.layout[len(self.layout)-1][len(self.layout[0])//2] = non_navigable_air
            if self.objectives["down"]["type"] != "empty":
                self.objective_doors.append(self.objective_door_generate(self.objectives["down"]["type"], len(self.layout[0])//2-1, len(self.layout)-1, "top_left", "h", self.objectives["down"]["colour"], "down"))
                self.objective_doors.append(self.objective_door_generate(self.objectives["down"]["type"], len(self.layout[0])//2, len(self.layout)-1, "top_right", "h", self.objectives["down"]["colour"], "down"))
                
        for door in self.objective_doors:
            if self.objectives[door.side]["complete"]:
                door.open()
            elif self.objectives[door.side]["type"] == "empty":
                self.complete_objective(door.side)
                
        
        
        
        #elif square_name.startswith("objective"):
        #   self.objective_doors.append(ObjectiveDoor(x, y, corner, square["pos"][0], self.location, square["objective"], square["colour"]))
        #   new_row[x] = Square(squares_data[7], default_square, constants.FILE_PATH, constants.SQUARE_SIZE, [self.location[0] + (x * constants.SQUARE_SIZE[0]), self.location[1] + (y * constants.SQUARE_SIZE[1])], [x,y])
            
        #for objective in data.doors:
        
        
        
    def objective_door_generate(self, objective_type, x, y, hinge_corner, starting_dir, colour=None, side = None):   
        if objective_type == "keyhole":
            from classes.special_squares.mechanical_door import MechanicalDoor
            return MechanicalDoor(x, y, hinge_corner, starting_dir, self.location, colour, "keyhole", side)
        elif objective_type == "powered":
            from classes.special_squares.mechanical_door import MechanicalDoor
            return MechanicalDoor(x, y, hinge_corner, starting_dir, self.location, colour, objective_side = side)
        else:
            from classes.special_squares.objective_door import ObjectiveDoor
            return ObjectiveDoor(x, y, hinge_corner, starting_dir, self.location, colour, side)
        
        
    def complete_objective(self, objective_side):
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        # set objective to complete
        self.objectives[objective_side]["complete"] = True
        
        if objective_side == "left":
            objective_opposite = "right"
        elif objective_side == "right":
            objective_opposite = "left"
        elif objective_side == "up":
            objective_opposite = "down"
        else:
            objective_opposite = "up"
        
        level_layout = json.load(open(constants.FILE_PATH + f"data/account_games/{self.account_id}_games/{self.savegame_id}_levels/rooms_{self.level}/layout.json", 'r'))
        
        # find next room
        next_room_id = None
        for y, row in enumerate(level_layout):
            for x, item in enumerate(row):
                if item == self.id:
                    if objective_side == "left":
                        next_room_id = level_layout[y][x-1]
                    elif objective_side == "right":
                        next_room_id = level_layout[y][x+1]
                    elif objective_side == "up":
                        next_room_id = level_layout[y-1][x]
                    elif objective_side == "down":
                        next_room_id = level_layout[y+1][x]
                
        # update next room
        
        with open(constants.FILE_PATH + f"data/account_games/{self.account_id}_games/{self.savegame_id}_levels/rooms_{self.level}/{next_room_id}.json", 'r') as file:
            data = json.load(file)
        data["doors"][objective_opposite]["complete"] = True
            
        with open(constants.FILE_PATH + f"data/account_games/{self.account_id}_games/{self.savegame_id}_levels/rooms_{self.level}/{next_room_id}.json", 'w') as file:
            json_string = json.dumps(data)
            file.write(json_string)
        
        # open doors
        for door in self.objective_doors:
            if door.side == objective_side:
                door.open()
    
    def update(self, player):
        for colour in self.active_colours:
            self.active_colours[colour] = False
        
        for lever in self.levers:
            if lever.flicked:
                self.active_colours[str(lever.colour)] = True
        for button in self.buttons:
            if not button.state_up:
                self.active_colours[str(button.colour)] = True
                
        for door in self.doors:
            if not door.manual and door.type == "button":
                if str(door.colour) in self.active_colours:
                    if self.active_colours[str(door.colour)]:
                        door.open()
                    else:
                        door.close()
                    #door.open = self.active_colours[str(door.colour)]
                    
                    
        # Special door objectives
        for objective in self.objectives:
            if self.objectives[objective] is not None:
                if not self.objectives[objective]["complete"]:
                    # Kill count:
                    if self.objectives[objective]["type"] == "kill_count":
                        if player.kills >= self.objectives[objective]["num"]:
                            self.complete_objective(objective)
                            
                    elif self.objectives[objective]["type"] == "local_kill_count":
                        if self.kills >= self.objectives[objective]["num"]:
                            self.complete_objective(objective)
                            
                    # No enemies:
                    # if self.objectives[objective]["type"] == "kill_count":
                    #     if player.kills >= self.objectives[objective]["num"]:
                    #         self.complete_objective(objective)
                    
                    # Powered
                    elif self.objectives[objective]["type"] == "powered":
                        if self.active_colours[str(self.objectives[objective]["colour"])]:
                            self.complete_objective(objective)
                    
                    # Keyhole is done elsewhere
                
        
    
    def save(self):
        data = {"id": self.id,
                "doors": self.objectives}
        
        # basic squares
        squares = []
        for y, row in enumerate(self.layout):
            new_row = []
            for x, square in enumerate(row):
                new_row.append(square.save())
            squares.append(new_row)
        # overlay buttons, levers and doors
        for lever in self.levers:
            squares[lever.grid_location[1]][lever.grid_location[0]] = lever.save()
        for button in self.buttons:
            squares[button.grid_location[1]][button.grid_location[0]] = button.save()
        for door in self.doors:
            squares[door.grid_location[1]][door.grid_location[0]] = door.save()
        
        # ladder
        if self.ladder is not None:
            squares[self.ladder.grid_coords[1]][self.ladder.grid_coords[0]] = 10
        
        data["squares"] = squares
        
        # entities
        entities = []
        
        for entity in self.entities:
            entities.append(entity.save(self.location))
            
        for crate in self.crates:
            entities.append(crate.save(self.location))
            
        for item in self.living_items:
            entities.append(item.save(self.location))
        
        data["entities"] = entities
        
        
        from classes.global_data import constants_structure
        constants = constants_structure()
        print("saving to: " + constants.FILE_PATH + f"data/account_games/{self.account_id}_games/{self.savegame_id}_levels/rooms_{self.level}/{self.id}.json")
        with open(constants.FILE_PATH + f"data/account_games/{self.account_id}_games/{self.savegame_id}_levels/rooms_{self.level}/{self.id}.json", 'w') as file:
            json_string = json.dumps(data)
            file.write(json_string)
            #json.dump(data, file, indent=4)
            
    def get_rendering_list(self):
        rendering_list = []
        for row in self.layout:
            for item in row:
                rendering_list.append(item)
        rendering_list += [*self.buttons, *self.levers, *self.doors, *self.objective_doors, *self.entities, *self.living_items, *self.crates]
        if self.ladder is not None:
            rendering_list.append(self.ladder)
            
        return(rendering_list)
            
    
    def draw(self, screen, square_size, config):
        from classes.global_data import constants_structure
        constants = constants_structure()
        # draw base, later should calculate connected textures too
        # will also need extra room layout later to extablish different squares
        #print(self.location[0]-constants.SQUARE_SIZE[0])
        #tunnels
        tunnel = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/menu/tunnel_h.png").convert(), (square_size[0] * 3, square_size[1] * 4.5))
        if self.objectives["right"] is not None:
            screen.blit(tunnel, (self.location[0] + self.size[0], (constants.GAME_WINDOW_SIZE[1] - tunnel.get_height())//2 - (constants.SQUARE_SIZE[1]//4)))
        if self.objectives["left"] is not None:
            screen.blit(tunnel, (self.location[0] - tunnel.get_width(), (constants.GAME_WINDOW_SIZE[1] - tunnel.get_height())//2 - (constants.SQUARE_SIZE[1]//4)))
            
        tunnel = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/menu/tunnel_v.png").convert(), (square_size[0] * 4, square_size[1] * 3.5))
        #if self.objectives["down"] is not None:
        #    screen.blit(tunnel, ((constants.GAME_WINDOW_SIZE[0] - tunnel.get_width())//2,  self.location[1] + self.size[1] - (constants.SQUARE_SIZE[1]//4)))
        if self.objectives["up"] is not None:
            screen.blit(tunnel, ((constants.GAME_WINDOW_SIZE[0] - tunnel.get_width())//2,  self.location[1] - tunnel.get_height()))
        
        # base
        for y, row in enumerate(self.layout):
            for x, square in enumerate(row):
                texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/squares/ground.png").convert(), square_size)
                screen.blit(texture, (self.location[0] + (square_size[0] * x), self.location[1] + (square_size[1] * y)))
                #screen.blit(self.textures[0], (x_loc, y_loc))
        
        
        # draw squares
        for y, row in enumerate(self.layout):
            for x, square in enumerate(row):
                screen = square.draw(screen)
        
        
        # for button in self.buttons:
        #     screen = button.draw(screen)
        # for lever in self.levers:
        #     screen = lever.draw(screen)
        # for door in [*self.doors, *self.objective_doors]:
        #     screen = door.draw(screen)
            
        # for entity in self.entities:
        #     screen = entity.draw(screen, config["max_FPS"])
        
        # for item in self.living_items:
        #     screen = item.draw(screen)
        
        # for crate in self.crates:
        #     screen = crate.draw(screen)
            
        # if self.ladder is not None:
        #     screen = self.ladder.draw(screen)
        
        
        return screen
    
    def draw_over(self, screen, square_size):
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        tunnel = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/menu/tunnel_v.png").convert(), (square_size[0] * 4, square_size[1] * 3.5))
        
        if self.objectives["down"] is not None:
            screen.blit(tunnel, ((constants.GAME_WINDOW_SIZE[0] - tunnel.get_width())//2,  self.location[1] + self.size[1] - (constants.SQUARE_SIZE[1]//2)))
    
        return screen
    
    def draw_icons(self, screen, player):
        
        
        for icon in self.objective_icons:
            text = ""
            if self.objectives[icon.side]["type"] == "kill_count":
                text = f"{min(self.objectives[icon.side]['num'], player.kills)}/{self.objectives[icon.side]['num']}"
            elif self.objectives[icon.side]["type"] == "local_kill_count":
                text = f"{min(self.objectives[icon.side]['num'], self.kills)}/{self.objectives[icon.side]['num']}"
            elif self.objectives[icon.side]["type"] == "keyhole":
                text = "LOCKED"
                if self.objectives[icon.side]["complete"]:
                    text = "UNLOCKED"
            elif self.objectives[icon.side]["type"] == "powered":
                text = "OFF"
                if self.objectives[icon.side]["complete"]:
                    text = "ON"
            screen = icon.draw(screen, text)
        return screen
        
    
    



projects/final/classes/special_squares/keyhole_wall.py

import pygame

class Keyhole:
    def __init__(self, x, y, room_loc, colour):
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        self.grid_pos = [x,y]
        self.x_pos = (constants.SQUARE_SIZE[0] * x) + room_loc[0]
        self.y_pos = (constants.SQUARE_SIZE[1] * y) + room_loc[1]
        self.collision_x = self.x_pos
        self.collision_y = self.y_pos
        
        self.width = constants.SQUARE_SIZE[0]
        self.height = constants.SQUARE_SIZE[1]
        
        self.colour = colour
        self.collidable = True
        self.breakable = False
        
        #self.texture = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/rock.png").convert()
        
        base = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/rock.png").convert()
        temp_surface = pygame.Surface((base.get_width(), base.get_height()), pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        temp_surface.blit(base, (0,0))
        self.texture = temp_surface
        
        temp_surface = pygame.Surface((self.texture.get_width(), self.texture.get_height()), pygame.SRCALPHA)
        temp_surface.blit(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/keyhole_wall.png").convert(), (0,0))
        temp_surface.fill(colour, special_flags=pygame.BLEND_MULT)
        self.texture.blit(temp_surface, (0,0)) 
        
        self.texture = pygame.transform.scale(self.texture, (constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 1.5))
        
        self.draw_loc = [0, -0.5 * constants.SQUARE_SIZE[1]]
        
        
    def save(self):
        return {"id": 12,
                "colour": self.colour}
        
    def get_rendering_row(self):
        return self.y_pos
        
    def draw(self, screen):
        
        temp_surface = pygame.Surface((self.texture.get_width(), self.texture.get_height()), pygame.SRCALPHA)
        temp_surface.blit(self.texture, (0,0))
        
        screen.blit(temp_surface, (self.x_pos + self.draw_loc[0], self.y_pos + self.draw_loc[1]))
        
        return screen



projects/final/classes/special_squares/lever.py

import pygame

class Lever:
    def __init__(self, colour, flicked, location, room_loc):
        from classes.global_data import constants_structure;
        constants = constants_structure()
        #self.textures = {"up": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/plain_button_up.png").convert(), constants.SQUARE_SIZE),
        #                "down": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/plain_button_down.png").convert(), constants.SQUARE_SIZE)}
        self.textures = {}
        
        for texture in ["flicked", "unflicked"]:
            base = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/plain_lever_{texture}.png").convert()
            temp_surface = pygame.Surface((base.get_width(), base.get_height()), pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
            temp_surface.blit(base, (0,0))
            temp_surface.fill(colour, special_flags=pygame.BLEND_MULT)
            self.textures[texture] = temp_surface
            temp_surface = pygame.Surface((base.get_width(), base.get_height()), pygame.SRCALPHA)
            temp_surface.blit(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/plain_lever_{texture}_rim.png").convert(), (0,0))
            self.textures[texture].blit(temp_surface, (0,0)) 

        # 
        #self.textures["up"].fill(colour, special_flags=pygame.BLEND_MULT)
        #self.textures["down"].fill(colour, special_flags=pygame.BLEND_MULT)
        
        
        # location comes as grid coordinate
        self.grid_location = location
        self.x_pos = (location[0] * constants.SQUARE_SIZE[0]) + room_loc[0]
        self.y_pos = (location[1] * constants.SQUARE_SIZE[1]) + room_loc[1]
        self.collision_box = {"size": (constants.SQUARE_SIZE[0] * 0.9, constants.SQUARE_SIZE[1] * 0.9),
                            "location": [self.x_pos + constants.SQUARE_SIZE[0] * 0.05, self.y_pos + constants.SQUARE_SIZE[1] * 0.05]}
        
        self.colour = colour
        self.flicked = flicked
        
        
    # def update(self, player_collision_box, crates, enemies):
    #     from functions.algorithms.collision_detection import collision
    #     self.state_up = True # start by assuming false
        
    #     if collision([*player_collision_box["location"], *player_collision_box["size"]], [*self.collision_box["location"], *self.collision_box["size"]]):
    #         self.state_up = False
    #     else:
    #         for crate in crates:
    #             if collision([*crate.collision_box["location"], *crate.collision_box["size"]], [*self.collision_box["location"], *self.collision_box["size"]]):
    #                 self.state_up = False
    #                 break
    #         if self.state_up == True:
    #             for enemy in enemies:
    #                 if collision([*enemy.collision_box["location"], *enemy.collision_box["size"]], [*self.collision_box["location"], *self.collision_box["size"]]):
    #                     self.state_up = False
    #                     break
    
    def save(self):
        data = {"id": 6,
                "colour": self.colour,
                "flicked": self.flicked}
        return data
    
    def get_rendering_row(self):
        return self.y_pos
    
    def draw(self, screen):
        from classes.global_data import constants_structure;
        constants = constants_structure()
        temp_surface = pygame.Surface(constants.SQUARE_SIZE, pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        
        if self.flicked:
            temp_surface.blit(pygame.transform.scale(self.textures["flicked"], constants.SQUARE_SIZE),(0,0))
        else:
            temp_surface.blit(pygame.transform.scale(self.textures["unflicked"], constants.SQUARE_SIZE),(0,0))
        
        #temp_surface.fill(self.colour, special_flags=pygame.BLEND_MULT)
        
        screen.blit(temp_surface, (self.x_pos, self.y_pos))
        
        return screen



projects/final/classes/special_squares/button.py

import pygame

class Button:
    def __init__(self, colour, location, room_loc):
        from classes.global_data import constants_structure;
        constants = constants_structure()
        #self.textures = {"up": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/plain_button_up.png").convert(), constants.SQUARE_SIZE),
        #                "down": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/plain_button_down.png").convert(), constants.SQUARE_SIZE)}
        self.textures = {}
        
        for texture in ["up", "down"]:
            base = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/plain_button_{texture}.png").convert()
            temp_surface = pygame.Surface((base.get_width(), base.get_height()), pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
            temp_surface.blit(base, (0,0))
            temp_surface.fill(colour, special_flags=pygame.BLEND_MULT)
            self.textures[texture] = temp_surface
            temp_surface = pygame.Surface((base.get_width(), base.get_height()), pygame.SRCALPHA)
            temp_surface.blit(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/plain_button_{texture}_rim.png").convert(), (0,0))
            self.textures[texture].blit(temp_surface, (0,0)) 

        # 
        #self.textures["up"].fill(colour, special_flags=pygame.BLEND_MULT)
        #self.textures["down"].fill(colour, special_flags=pygame.BLEND_MULT)
        
        
        # location comes as grid coordinate
        self.grid_location = location
        self.x_pos = (location[0] * constants.SQUARE_SIZE[0]) + room_loc[0]
        self.y_pos = (location[1] * constants.SQUARE_SIZE[1]) + room_loc[1]
        self.collision_box = {"size": (constants.SQUARE_SIZE[0] * 0.9, constants.SQUARE_SIZE[1] * 0.9),
                            "location": [self.x_pos + constants.SQUARE_SIZE[0] * 0.05, self.y_pos + constants.SQUARE_SIZE[1] * 0.05]}
        
        self.colour = colour
        self.state_up = True
        
        
    def update(self, player_collision_box, crates, enemies):
        from functions.algorithms.collision_detection import collision
        self.state_up = True # start by assuming false
        
        if collision([*player_collision_box["location"], *player_collision_box["size"]], [*self.collision_box["location"], *self.collision_box["size"]]):
            self.state_up = False
        else:
            for crate in crates:
                if collision([*crate.collision_box["location"], *crate.collision_box["size"]], [*self.collision_box["location"], *self.collision_box["size"]]):
                    self.state_up = False
                    break
            if self.state_up == True:
                for enemy in enemies:
                    if collision([*enemy.collision_box["location"], *enemy.collision_box["size"]], [*self.collision_box["location"], *self.collision_box["size"]]):
                        self.state_up = False
                        break
    
    def save(self):
        data = {"id": 5,
                "colour": self.colour}
        return data
    
    def get_rendering_row(self):
        return self.y_pos
    
    def draw(self, screen):
        from classes.global_data import constants_structure;
        constants = constants_structure()
        temp_surface = pygame.Surface(constants.SQUARE_SIZE, pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        
        if self.state_up:
            temp_surface.blit(pygame.transform.scale(self.textures["up"], constants.SQUARE_SIZE),(0,0))
        else:
            temp_surface.blit(pygame.transform.scale(self.textures["down"], constants.SQUARE_SIZE),(0,0))
        
        #temp_surface.fill(self.colour, special_flags=pygame.BLEND_MULT)
        
        screen.blit(temp_surface, (self.x_pos, self.y_pos))
        
        return screen



projects/final/classes/special_squares/door.py

import pygame

class Door:
    def __init__(self, x, y, hinge_corner, starting_dir, room_location, door_type=""):
        # x and y are grid coordinates
        
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        self.grid_location = [x,y]
        x = (x * constants.SQUARE_SIZE[0]) + room_location[0]
        y = (y * constants.SQUARE_SIZE[1]) + room_location[1]
        self.starting_dir = starting_dir
        
        # state is 'h' or 'v'
        self.state = starting_dir
        self.corner = hinge_corner
        self.is_open = False
        
        self.x_pos = x
        self.y_pos = y
        
        self.textures = {"h": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/{door_type}door_right.png").convert(), constants.SQUARE_SIZE),
                        "v": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/{door_type}door_up.png").convert(), (constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 2))}
        
        
        
        # also account for hitboxes !!
        # hinge corner values: bottom_left, bottom_right, top_left, top_right
        
        self.collision_boxes = {
            "h": {"size": (constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 0.1),  "location": [x, y + (constants.SQUARE_SIZE[1] * 0.9)]},
            "v": {"size": (constants.SQUARE_SIZE[0] * 0.1, constants.SQUARE_SIZE[1]),  "location": [x, y]}
        }
        
        self.collision_box = self.collision_boxes[starting_dir]
        
        if hinge_corner == "bottom_right":
            self.collision_boxes["v"]["location"][0] = x + (constants.SQUARE_SIZE[0] * 0.9)
            self.textures["h"] = pygame.transform.flip(self.textures["h"], True, False)
            #self.textures["v"] = pygame.transform.flip(self.textures["v"], True, False)
            
            
        elif hinge_corner == "top_left":
            self.collision_boxes["h"]["location"][1] = y
            temp_surface = pygame.Surface((constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 2), pygame.SRCALPHA)
            temp_surface.blit(self.textures["h"], (0,0))
            self.textures["h"] = temp_surface
            
            
        elif hinge_corner == "top_right":
            self.collision_boxes["h"]["location"][1] = y
            self.collision_boxes["v"]["location"][0] = x + (constants.SQUARE_SIZE[0] * 0.9)
            self.textures["h"] = pygame.transform.flip(self.textures["h"], True, False)
            #self.textures["v"] = pygame.transform.flip(self.textures["v"], True, False)
            
            temp_surface = pygame.Surface((constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 2), pygame.SRCALPHA)
            temp_surface.blit(self.textures["h"], (0,0))
            self.textures["h"] = temp_surface
            
        self.manual = True
        self.type = "manual"
        
    def toggle_state(self):
        self.is_open = not self.is_open
        if self.state == "v":
            self.state = "h"
            self.collision_box = self.collision_boxes["h"]
        else:
            self.state = "v"
            self.collision_box = self.collision_boxes["v"]
            
            
    def open(self):
        if self.starting_dir == self.state:
            self.is_open = True
            if self.state == "v":
                self.state = "h"
                self.collision_box = self.collision_boxes["h"]
            else:
                self.state = "v"
                self.collision_box = self.collision_boxes["v"]
    
    def close(self):
        if self.starting_dir != self.state:
            self.is_open = False
            self.state = self.starting_dir
            self.collision_box = self.collision_boxes[self.starting_dir]
            
            
    def save(self):
        pos = self.state
        pos += self.corner[0]
        if "left" in self.corner:
            pos += "l"
        else:
            pos += "r"
            
        data = {"id": 3,
                "pos": pos}
        return data
    
    def get_rendering_row(self):
        return self.collision_box["location"][1]
        
    def draw(self, screen):
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        if self.state == 'v':
            temp_surface = pygame.Surface((self.textures["v"].get_width(), self.textures["v"].get_height()), pygame.SRCALPHA)
            temp_surface.blit(self.textures["v"], (0,0))
            if self.corner.find("right") != -1:
                screen.blit(temp_surface, (self.x_pos + (constants.SQUARE_SIZE[1] * 0.65), self.y_pos - constants.SQUARE_SIZE[1]))
            else:
                screen.blit(temp_surface, (self.x_pos - (constants.SQUARE_SIZE[1] * 0.15), self.y_pos - constants.SQUARE_SIZE[1]))
            #screen.blit(self.textures['v'], (self.x_pos, self.y_pos - constants.SQUARE_SIZE[1]))

        elif self.state == 'h':
            temp_surface = pygame.Surface((self.textures["h"].get_width(), self.textures["h"].get_height()), pygame.SRCALPHA)
            temp_surface.blit(self.textures["h"], (0,0))
            if self.corner.find("top") != -1:
                screen.blit(temp_surface, (self.x_pos, self.y_pos - int(constants.SQUARE_SIZE[1] * 0.7)))
            else:
                screen.blit(temp_surface, (self.x_pos, self.y_pos))
            #screen.blit(self.textures['h'], (self.x_pos, self.y_pos))
        
        
        return screen



projects/final/classes/special_squares/objective_door.py
import pygame
from classes.special_squares.door import Door

class ObjectiveDoor(Door):
    def __init__(self, x, y, hinge_corner, starting_dir, room_location, colour=None, side = None):
        from classes.global_data import constants_structure
        constants = constants_structure()
        Door.__init__(self, x, y, hinge_corner, starting_dir, room_location, "objective_")
        
        self.manual = False
        self.colour = colour
        self.side = side
        self.starting_dir = starting_dir
        
        #self.textures = {"h": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/squares/objective_door_right.png").convert(), constants.SQUARE_SIZE),
        #                "v": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/squares/objective_door_up.png").convert(), (constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 2))}
        
        if colour is not None:
            overlay_textures = {"h": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/squares/objective_door_right_overlay.png").convert(), constants.SQUARE_SIZE),
                                "v": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/squares/objective_door_up_overlay.png").convert(), (constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 2))}
        
            for texture in overlay_textures:
                temp_surface = pygame.Surface((overlay_textures[texture].get_width(), overlay_textures[texture].get_height()), pygame.SRCALPHA)
                temp_surface.blit(overlay_textures[texture], (0,0))
                temp_surface.fill(colour, special_flags=pygame.BLEND_MULT)
                temp_surface_2 = pygame.Surface((self.textures[texture].get_width(), self.textures[texture].get_height()), pygame.SRCALPHA)
                temp_surface_2.blit(self.textures[texture], (0,0))
                temp_surface_2.blit(temp_surface, (0,0))
                self.textures[texture] = temp_surface_2
        
    def save(self):
        pos = self.state
        pos += self.corner[0]
        if "left" in self.corner:
            pos += "l"
        else:
            pos += "r"
            
        data = {"id": 9,
                "pos": pos,
                "colour": self.colour}
        return data
        



projects/final/classes/special_squares/mechanical_door.py


import pygame
from classes.special_squares.door import Door

class MechanicalDoor(Door):
    def __init__(self, x, y, hinge_corner, starting_dir, room_location, colour, door_type = "button", objective_side = None, is_open = False):
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        Door.__init__(self, x, y, hinge_corner, starting_dir, room_location)
        self.type = door_type
        self.side = objective_side
        self.manual = False
        self.colour = colour
        self.is_open = is_open
        self.starting_dir = starting_dir
        if is_open:
            self.starting_dir = "v"
            if starting_dir == "v":
                self.starting_dir = "h"
            
        
        
        self.textures = {"h": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/squares/mechanical_door_right_base.png").convert(), constants.SQUARE_SIZE),
                        "v": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/squares/mechanical_door_up_base.png").convert(), (constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 2))}
        
        overlay_textures = {"h": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/mechanical_door_right_overlay_{self.type}.png").convert(), constants.SQUARE_SIZE),
                        "v": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/mechanical_door_up_overlay_{self.type}.png").convert(), (constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 2))}
        
        for texture in overlay_textures:
            temp_surface = pygame.Surface((overlay_textures[texture].get_width(), overlay_textures[texture].get_height()), pygame.SRCALPHA)
            temp_surface.blit(overlay_textures[texture], (0,0))
            temp_surface.fill(colour, special_flags=pygame.BLEND_MULT)
            temp_surface_2 = pygame.Surface((self.textures[texture].get_width(), self.textures[texture].get_height()), pygame.SRCALPHA)
            temp_surface_2.blit(self.textures[texture], (0,0))
            temp_surface_2.blit(temp_surface, (0,0))
            self.textures[texture] = temp_surface_2
        
        
            
    def save(self):
        pos = self.state
        pos += self.corner[0]
        if "left" in self.corner:
            pos += "l"
        else:
            pos += "r"
            
        id = 11
        if self.type == "button":
            id = 8
            
        data = {"id": id,
                "pos": pos,
                "open": self.is_open,
                "colour": self.colour}
        return data
        
    



projects/final/classes/special_squares/ladder.py

import pygame

class Ladder:
    def __init__(self, x, y, room_loc):
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        self.texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/ladder.png").convert(), constants.SQUARE_SIZE)
        
        self.grid_coords = (x, y)
        self.x_pos = (x * constants.SQUARE_SIZE[0]) + room_loc[0]
        self.y_pos = (y * constants.SQUARE_SIZE[1]) + room_loc[1]
    
    def player_proximity(self, player_loc):
        from math import sqrt
        return sqrt(((player_loc[0] - self.x_pos - (self.texture.get_width()//2))**2) + ((player_loc[1] - self.y_pos - (self.texture.get_height()//2))**2))
        
    def get_rendering_row(self):
        return self.y_pos
        
    def draw(self, screen):
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        temp_surface = pygame.Surface((constants.SQUARE_SIZE), pygame.SRCALPHA)
        temp_surface.blit(self.texture, [0,0])
        screen.blit(temp_surface, (self.x_pos, self.y_pos))
        
        return screen



projects/final/classes/items/living_item.py


import pygame
from functions.algorithms.collision_detection import is_colliding

class LivingItem:
    def __init__(self, x, y, item, velocity=[0,0]):
        # item is instance when created, but when loaded is object
        self.item = item
        
        self.x_pos = x
        self.y_pos = y
        self.size = (40,40)
        self.velocity = velocity
        # hitbox is the same width but only the bottom half of height. This is derived from location and size
        
        
    def move(self, room_layout, room_location, constants):
        DECELERATION = 1
        
        hitbox = {"size": [self.size[0],self.size[1]//2],
                            "location": [self.x_pos,self.y_pos]}
        
        if not is_colliding({"size": [self.size[0],self.size[1]//2],
                            "location": [self.x_pos + self.velocity[0], self.y_pos]}, 
                            room_layout, room_location, constants.SQUARE_SIZE):
            self.x_pos += self.velocity[0]
        if not is_colliding({"size": [self.size[0],self.size[1]//2],
                            "location": [self.x_pos, self.y_pos + self.velocity[1]]}, 
                            room_layout, room_location, constants.SQUARE_SIZE):
            self.y_pos += self.velocity[1]
        
        if self.velocity[0] < 0:
            self.velocity[0] += DECELERATION
        elif self.velocity[0] > 0:
            self.velocity[0] -= DECELERATION
        
        if self.velocity[1] < 0:
            self.velocity[1] += DECELERATION
        elif self.velocity[1] > 0:
            self.velocity[1] -= DECELERATION
            
    def save(self, room_loc):
        #from classes.global_data import constants_structure
        #constants = constants_structure()
        data = {
            "name": "item",
            "x": self.x_pos,
            "y": self.y_pos,
            "item": self.item.type,
            "payload": self.item.payload
        }
        
        return data
    
    def get_rendering_row(self):
        return self.y_pos
        
    def draw(self, screen):
        temp_surface = pygame.Surface(self.size, pygame.SRCALPHA)
        # shadow
        pygame.draw.rect(temp_surface, (0, 0, 0, 128), (0, self.size[1]//8*7, self.size[0], self.size[1]//8))
        temp_surface.blit(pygame.transform.scale(self.item.game_texture, self.size), (0,0))
        
        # texture
        screen.blit(temp_surface, (self.x_pos, self.y_pos))
        
        
        # text
        #sqrt((((l_item.x_pos + (l_item.size[0]//2)) - (self.collision_box["location"][0] + (self.collision_box["size"][0]//2)))  **2)  +
        #                                (((l_item.y_pos + (l_item.size[1]//2)) - (self.collision_box["location"][1] + (self.collision_box["size"][1]//2)))  **2))
        
        return screen



projects/final/classes/items/items.py


import pygame
from classes.item import Item


# ARMOUR
# Wooden Armour
class WoodenHelmet(Item):
    def __init__(self, payload):
        
        self.type = "wood_head"
        self.name = "Wooden Helmet"
        
        Item.__init__(self, self.type)
        
        self.sort = "helmet"
        
        self.speed_multiplier = 0.9
        self.mele_armour_multiplier = 0.95
        
class WoodenChestplate(Item):
    def __init__(self, payload):
        
        self.type = "wood_chest"
        self.name = "Wooden Chestplate"
        
        Item.__init__(self, self.type)
        
        self.sort = "chestplate"
        
        self.speed_multiplier = 0.85
        self.mele_armour_multiplier = 0.9
        
class WoodenBoots(Item):
    def __init__(self, payload):
        
        self.type = "wood_feet"
        self.name = "Wooden Boots"
        
        Item.__init__(self, self.type)
        
        self.sort = "boots"
        
        self.speed_multiplier = 0.9
        self.mele_armour_multiplier = 0.95

# Chainmail Armour
class ChainmailHelmet(Item):
    def __init__(self, payload):
        
        self.type = "chain_head"
        self.name = "Chainmail Helmet"
        
        Item.__init__(self, self.type)
        
        self.sort = "helmet"
        
        self.speed_multiplier = 0.85
        self.mele_armour_multiplier = 0.97
        self.ranged_armour_multiplier = 0.95
        
class ChainmailChestplate(Item):
    def __init__(self, payload):
        
        self.type = "chain_chest"
        self.name = "Chainmail Chestplate"
        
        Item.__init__(self, self.type)
        
        self.sort = "chestplate"
        
        self.speed_multiplier = 0.8
        self.mele_armour_multiplier = 0.95
        self.ranged_armour_multiplier = 0.92
        
class ChainmailBoots(Item):
    def __init__(self, payload):
        
        self.type = "chain_feet"
        self.name = "Chainmail Boots"
        
        Item.__init__(self, self.type)
        
        self.sort = "boots"
        
        self.speed_multiplier = 0.85
        self.mele_armour_multiplier = 0.97
        self.ranged_armour_multiplier = 0.95
        
# Iron Armour
class IronHelmet(Item):
    def __init__(self, payload):
        
        self.type = "metal_head"
        self.name = "Iron Helmet"
        
        Item.__init__(self, self.type)
        
        self.sort = "helmet"
        
        self.speed_multiplier = 0.8
        self.mele_armour_multiplier = 0.9
        self.ranged_armour_multiplier = 0.83
        
class IronChestplate(Item):
    def __init__(self, payload):
        
        self.type = "metal_chest"
        self.name = "Iron Chestplate"
        
        Item.__init__(self, self.type)
        
        self.sort = "chestplate"
        
        self.speed_multiplier = 0.7
        self.mele_armour_multiplier = 0.85
        self.ranged_armour_multiplier = 0.75
        
class IronBoots(Item):
    def __init__(self, payload):
        
        self.type = "metal_feet"
        self.name = "Iron Boots"
        
        Item.__init__(self, self.type)
        
        self.sort = "boots"
        
        self.speed_multiplier = 0.8
        self.mele_armour_multiplier = 0.9
        self.ranged_armour_multiplier = 0.8
        

# WEAPONS
class StickSword(Item):
    def __init__(self, payload):
        
        self.type = "stick"
        self.name = "Stick"
        
        Item.__init__(self, self.type)
        
        self.sort = "mele"
        
        self.damage_multiplier = 2
        
class LongSword(Item):
    def __init__(self, payload):
        
        self.type = "long_sword"
        self.name = "Long Sword"
        
        Item.__init__(self, self.type)
        
        self.sort = "mele"
        
        self.damage_multiplier = 3.5
        self.attack_speed_multiplier = 0.9
        self.mele_range_multiplier = 1.2

class Axe(Item):
    def __init__(self, payload):
        
        self.type = "metal_axe"
        self.name = "Axe"
        
        Item.__init__(self, self.type)
        
        self.sort = "mele"
        
        self.damage_multiplier = 5
        self.attack_speed_multiplier = 0.5
        self.mele_range_multiplier = 1.2
        
class Dagger(Item):
    def __init__(self, payload):
        
        self.type = "dagger"
        self.name = "Dagger"
        
        Item.__init__(self, self.type)
        
        self.sort = "mele"
        
        self.damage_multiplier = 2.5
        self.attack_speed_multiplier = 2.5
        self.mele_range_multiplier = 0.7
        
class Mace(Item):
    def __init__(self, payload):
        
        self.type = "mace"
        self.name = "Mace"
        
        Item.__init__(self, self.type)
        
        self.sort = "mele"
        
        self.damage_multiplier = 2
        self.attack_speed_multiplier = 0.75
        self.mele_range_multiplier = 2

class Key(Item):
    def __init__(self, payload):
        
        self.type = "key"
        self.name = "Key"
        self.colour = payload["colour"]
        
        Item.__init__(self, self.type, payload)
        
        self.sort = "tool"
        
        #from classes.global_data import constants_structure
        #constants = constants_structure()
        #self.game_texture = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/items/{type}.png").convert()
        #self.inv_texture = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/items/{type}.png").convert()
        temp_surface = pygame.Surface((self.inv_texture.get_width(), self.inv_texture.get_height()), pygame.SRCALPHA)
        temp_surface.blit(self.inv_texture, (0,0))
        temp_surface.fill(self.colour, special_flags=pygame.BLEND_MULT)
        self.inv_texture = temp_surface
        self.game_texture = temp_surface
    
    def save(self):
        return {
            "item": self.type, 
            "payload": {"colour": self.colour}
            }
        



projects/final/classes/entities/enemy.py


from classes.entity import Entity
import functions.algorithms.a_star_pathfind as path_finding
from math import sqrt

class Enemy(Entity):
    def __init__(self, x, y, type, room_loc, drops):
        Entity.__init__(self, x, y, type, room_loc, drops)
        self.player_memory = 0
        self.max_player_memory = 45
        self.run_speed = 4
        self.walk_speed = 2
        self.idle_destination = []
        self.team = "enemy"
        self.attack_damage = 5
        self.max_attack_cooldown = 30
        self.attack_cooldown = self.max_attack_cooldown
        self.attack_frame = 0
        self.player_remembered_location = [x, y] # temporary, till replaced
        
    def think(self, player, entities, crates, doors, room, constants):
        
        if self.state == "death":
            if self.animation_frame == len(self.assets["death"])-1:
                return True
            else:
                return False
        if self.state == "spawn":
            if self.animation_frame == len(self.assets["spawn"])-1:
                self.change_state("idle")
            return False
        
    
        # Priority: hunt player, idle
        self.location = self.collision_box["location"]
        player_location = player.collision_box["location"]
        
        #if not room.layout[player.get_square(room)[1]][player.get_square(room)[0]].collidable:
            
        from functions.algorithms.a_star_pathfind import path_possible
        
        
        # Hunt player if player is within line of sight or has been within 30 ticks
        # player memory:
        LOS_result = path_finding.line_of_sight([self.location[0] + (self.collision_box["size"][0]//2), self.location[1] + (self.collision_box["size"][1]//2)], player_location, room, constants, [*crates, *doors])
        if LOS_result == "possible":
            if path_possible(self.get_square(room), player.get_square(room), room.layout): # check if path to player possible
                self.player_remembered_location = player_location # if it is, update memory. If it is not, then memory will not be updated and will therefore be the same
            self.speed = self.run_speed
            self.player_memory = self.max_player_memory
            # check if path to player is possible. if it is, run algorithm, otherwise run algorithm to last remembered location
            #print (player.get_square(room))
        elif self.player_memory > 0:
            self.speed = self.walk_speed
            self.player_memory -= 1
        
        # if player is being hunted
        if self.player_memory > 0:
            
            if self.attack_cooldown >= 0:
                self.attack_cooldown -= 1
            
            if (self.attack_cooldown <= 0) and (sqrt(((self.x_pos - player.x_pos)**2) + ((self.y_pos - player.y_pos)**2)) < 45):
                self.attack(player, entities, room)
                self.attack_cooldown = self.max_attack_cooldown
            
            if self.attack_timer == 0:
                
                # Find path to player. I may implement system to reduce use of this algorithm by 
                # only updating it every few ticks unless within closer range of the player
                #print(self.player_remembered_location)
                #print(player_location)
                #print()
                self.path_to_player = path_finding.a_star(self.location, self.player_remembered_location, room, self.collision_box["size"], crates, doors) 
                
                #print(self.path_to_player)
                if len(self.path_to_player) > 1:
                    self.move(self.path_to_player[1], room, crates, doors)
                else:
                    self.move(self.player_remembered_location, room, crates, doors)
            else:
                self.attack_timer -= 1
            
            # continue code

        else: # idle
            self.speed = self.walk_speed
            
            # ADD PASSIVE WALKING
            
            self.move(self.location, room, crates, doors)
            
            
        return False
            
            
        





projects/final/classes/entities/moveable_squares/crate.py

from classes.entity import Entity
from classes.global_data import constants_structure

import pygame


class Crate(Entity):
    def __init__(self, x, y, room_loc):
        # x and y are grid locations, not coordinates (they will be translated shortly)
        constants = constants_structure()
        self.texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/entities/crate.png").convert(), constants.SQUARE_SIZE)
        
        
        self.x_pos = (x * constants.SQUARE_SIZE[0]) + room_loc[0]
        self.y_pos = (y * constants.SQUARE_SIZE[1])+ room_loc[1]
        self.width = constants.SQUARE_SIZE[0]
        self.height = constants.SQUARE_SIZE[1]
        self.size = [self.width, self.height]
        
        self.collision_box = {"location": [self.x_pos + (self.width * 0.05), self.y_pos + (self.height //2)],
                                "size": [constants.SQUARE_SIZE[0] * 0.9, constants.SQUARE_SIZE[1]//2]}
        #self.collision_box = {"location": [self.x_pos, self.y_pos],
        #                    "size": constants.SQUARE_SIZE}
        
        
    def move(self, direction, speed, room, crates, doors, entities, moved_crates = []):
        from functions.algorithms.collision_detection import is_colliding, collision
        constants = constants_structure()
        # must check if move can be done, and then carry it out. wether it can and has been done should be returned to the player
        
        # Will not push item right to edge, due to only moving at speed. 
        # Maybe implement system sothat if there is a collision, it checks 
        # every distance it could move between 1 and the speed so that it 
        # goes right to the edge. This will help with squeezing through thin gaps
        
        # self.collision_box = {"location": [self.x_pos, self.y_pos],
        #                 "size": constants.SQUARE_SIZE}
        moved_crates.append(self)
        
        
        if direction == "left":
            self.collision_box["location"][0] -= speed
        elif direction == "right":
            self.collision_box["location"][0] += speed
        elif direction == "up":
            self.collision_box["location"][1] -= speed
        elif direction == "down":
            self.collision_box["location"][1] += speed
        
        colliding = is_colliding(self.collision_box, room.layout, room.location, constants.SQUARE_SIZE)
        # MAKE PUSH ALGORITHM CHAINABLE
        if not colliding:
            for crate in crates:
                if not crate in moved_crates:
                    if collision([*self.collision_box["location"], *self.collision_box["size"]], 
                                [*crate.collision_box["location"], *crate.collision_box["size"]]):
                        if not crate.move(direction, speed, room, crates, entities, moved_crates):
                            colliding = True
            
            if not colliding:
                for door in doors:
                    if collision([*self.collision_box["location"], *self.collision_box["size"]], [*door.collision_box["location"], *door.collision_box["size"]]):
                        colliding = True
                            
            if not colliding:
                for entity in entities:
                    if collision([*self.collision_box["location"], *self.collision_box["size"]], 
                                    [*entity.collision_box["location"], *entity.collision_box["size"]]):
                        if not entity.push(direction, speed, room, crates, doors):
                            colliding = True
            # If still not colliding, carry out movement
            if not colliding:
                self.x_pos = self.collision_box["location"][0] - (self.width * 0.05)
                self.y_pos = self.collision_box["location"][1] - (self.height //2)
            
        self.collision_box = {"location": [self.x_pos + (self.width * 0.05), self.y_pos + (self.height //2)],
                                "size": [constants.SQUARE_SIZE[0] * 0.9, constants.SQUARE_SIZE[1]//2]}
        
        return not colliding # can move
        
    
    def save(self, room_loc):
        constants = constants_structure()
        
        data = {
            "name": "crate",
            "x": (self.x_pos - room_loc[0]) / constants.SQUARE_SIZE[0],
            "y": (self.y_pos - room_loc[1]) / constants.SQUARE_SIZE[1]
        }
        
        return data
    
    def get_rendering_row(self):
        return self.collision_box["location"][1]
        
    def draw(self, screen):
        temp_surface = pygame.Surface([self.width, self.height], pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        temp_surface.blit(pygame.transform.scale(self.texture, [self.width, self.height]),(0,0))
        
        # collision box
        # pygame.draw.rect(temp_surface, (255, 0, 0, 127), (self.collision_box["location"][0] - self.x_pos, self.collision_box["location"][1] - self.y_pos, *self.collision_box["size"]))
        
        screen.blit(temp_surface, (self.x_pos, self.y_pos))
        return screen



projects/final/classes/entities/enemies/goblin.py

from classes.entities.enemy import Enemy
from classes.global_data import constants_structure
from random import randint

class Goblin(Enemy):
    def __init__(self, x, y, health, room_loc, drops = {}):
        Enemy.__init__(self, x, y, "goblin", room_loc, drops)
        import json
        constants = constants_structure()
        # Extract data
        data = json.load(open(constants.FILE_PATH + "data/entities/enemies/goblin.json", "r"))
        self.max_health = data["health"]
        
        self.health = health
        if health == -1: # -1 means default
            self.health = self.max_health
            
        self.walk_speed = data["walk_speed"]
        self.run_speed = data["run_speed"]
        self.max_player_memory = randint(data["max_player_memory_range"][0], data["max_player_memory_range"][1])
        self.size = data["size"]
        self.collision_box["size"] = data["collision_box_size"]
        self.team = data["team"]
        self.mele_reach = data["mele_reach"]
        self.attack_damage = data["attack_damage"]
        self.max_attack_cooldown = data["attack_cooldown"]
        
        



projects/final/functions/algorithms/delete_savegame.py


import json
import shutil

def delete_savegame(account_id, savegame_id):
    
    from classes.global_data import constants_structure
    constants = constants_structure()
    
    
    # edit games
    with open(constants.FILE_PATH + "data/accounts.json", 'r') as accountsDB:
        accountsDBJson = json.load(accountsDB)
        
    for i, account in enumerate(accountsDBJson):
        if account["UUID"] == account_id:
            for j, savegame in enumerate(account["savegames"]):
                if savegame["display_details"]["id"] == savegame_id:
                    accountsDBJson[i]["savegames"].pop(j)
                    break
        
    with open(constants.FILE_PATH + "data/accounts.json", 'w') as accountsDB:
        #accountsDB.seek(0)
        json.dump(accountsDBJson, accountsDB, indent=4)
        accountsDB.close()
        
        
    # delete files
    shutil.rmtree(constants.FILE_PATH + f"data/account_games/{account_id}_games/{savegame_id}_levels")
    




projects/final/functions/algorithms/getMovementVector.py


def get_movement_vector(speed, directionVector):
    if directionVector == [0,0]:
        return directionVector
    # Calculate direction vector distance
    from math import sqrt
    directionDistance = sqrt((directionVector[0] ** 2) + 
			                 (directionVector[1] ** 2))

    # Calculate multiplier
    multiplier = speed / directionDistance
    
    movementVector = [directionVector[0] * multiplier, 
		      directionVector[1] * multiplier]

    return movementVector




#getMovementVector = lambda speed, directionVector : [distance * (speed / (sqrt((directionVector[0] ** 2) + (directionVector[1] ** 2))))  for distance in directionVector]






projects/final/functions/algorithms/hashPassword.py



def hashPassword(password):
    # Put the first and last two letters in the middle of the password
    # AppleSeed337 -> AppleSAp37eed337
    password = password[:len(password)//2] + password[:2] + password[-2:] + password[len(password)//2:]

    # Put the product of all the numbers in the password at the start of it
    # AppleSeed337 -> 63AppleSeed337
    passwordCharacters = list(password)
    product = 1
    for character in passwordCharacters:
        if character.isdigit():	
            product *= int(character)
    password = str(product) + password

    # Reduce the ascii value of each of the characters by 10
    # AppleSeed337 -> 7ffb[I[[Z))-
    passwordCharacters = list(password)
    passwordCharacters = [chr(ord(character) - 10) for character in passwordCharacters]
    password = "".join(passwordCharacters)

    # Add a salt of "Xj8/" to the end of the password
    # AppleSeed337 -> AppleSeed337Xj8/
    password += "Xj8/"

    # Move the last letter to the front of the password for the the ascii 
    # total of the password number divided and rounded by 100 of turns
    # AppleSeed337 -> pleSeed337Ap
    asciiTotal = sum([ord(character) for character in password])
    for i in range(asciiTotal // 100):
        password = password[len(password)-1] + password[:-1]

    # Alternate the first and last letters of the password, moving inwards 
    # (if there are an odd number of letters, add a P to the end to make it even)
    # AppleSeed337 - > A7p3p3ldeeSe
    if len(password) % 2 != 0:
        password = password + "P"	
        tempPassword = ""
        for i in range(len(password)//2):
            tempPassword += password[i] + password[-i]

    # Overall, the password is very scrambled:
    # AppleSeed337 -> AppleSAp37eed337 -> 1323AppleSAp37eed337 -> ')()7ffb[I7f)-[[Z))- 
    # -> ')()7ffb[I7f)-[[Z))-Xj8/ -> ')()7ffb[I7f)-[[Z))-Xj8/ -> [I7f)-[[Z))-Xj8/')()7ffb 
    # -> [bIf7ff7))-([)['Z/)8)j-X
    
    return password






projects/final/functions/algorithms/collision_detection.py


def is_colliding(player, room_collidables, room_coordinates, square_size):
    
    player_grid_x = int((player["location"][0] - room_coordinates[0]) // square_size[0])
    player_grid_y = int((player["location"][1] - room_coordinates[1]) // square_size[1])
    if player_grid_y < len(room_collidables)-1:
        player_surroundings = [ room_collidables[player_grid_y][player_grid_x: player_grid_x + 2],
                                room_collidables[player_grid_y + 1][player_grid_x: player_grid_x + 2]]
    else:
        player_surroundings = [room_collidables[player_grid_y][player_grid_x: player_grid_x + 2]]
        
    
    x1 = player["location"][0]
    y1 = player["location"][1]
    x1_end = player["size"][0]
    y1_end = player["size"][1]
    
    for row in player_surroundings:
        for square in row:
            if square.collidable is False:
                continue
            x2 = square.collision_x
            y2 = square.collision_y
            x2_end = square.width
            y2_end = square.height
            
            if collision([x1, y1, x1_end, y1_end],  [x2, y2, x2_end, y2_end]):
                return True
            
    #print("not collision")
    return False
    
    
def collision(square_1, square_2):
    x1 = square_1[0]
    y1 = square_1[1]
    x1_end = x1 + square_1[2]
    y1_end = y1 + square_1[3]
    
    x2 = square_2[0]
    y2 = square_2[1]
    x2_end = x2 + square_2[2]
    y2_end = y2 + square_2[3]
    
    sorted_xs = [x1,x1_end, x2,x2_end]
    sorted_xs.sort()
    # check that both bounding boxes are not next to eachother
    if not (sorted_xs == [x1,x1_end, x2,x2_end] or sorted_xs == [x2,x2_end, x1,x1_end]): 
        sorted_ys = [y1,y1_end, y2,y2_end]
        sorted_ys.sort()
        # check that both bounding boxes are not vertically adjasent to eachother
        if not (sorted_ys == [y1,y1_end, y2,y2_end] or sorted_ys == [y2,y2_end, y1,y1_end]): 
            #print("collision")
            #print("collision between: \n", square_1, ",\n", square_2, "\n\n")
            return True

    return False



projects/final/functions/algorithms/log_in.py
import pygame
import json

from functions.algorithms.hashPassword import hashPassword
from classes.global_data import constants_structure
constants = constants_structure()


def do_log_in(username, password):
    hashed_password = hashPassword(password)
    
    with open(constants.FILE_PATH + "data/accounts.json", 'r') as accountsFile:
        accounts = json.load(accountsFile)
        
    for account in accounts:
        if account["username"] == username   and   account["hashed_password"] == hashed_password: # Main login check
            return {"returnType": 1,
                    "account_details": account}
    # if at this point, the account does not exist
    return {"returnType": -1,
            "returnMessage": "Sorry, your username or password is incorrect"}



projects/final/functions/algorithms/entity_lookup.py


def lookup(name):
    the_class = None
    if name == "goblin":
        from classes.entities.enemies.goblin import Goblin
        the_class = Goblin
    
    elif name == "crate":
        from classes.entities.moveable_squares.crate import Crate
        the_class = Crate

    elif name == "item":
        from classes.items.living_item import LivingItem
        the_class = LivingItem
        
        
    return the_class






projects/final/functions/algorithms/account_creation.py
import pygame
import json

from functions.algorithms.hashPassword import hashPassword
from classes.global_data import constants_structure
constants = constants_structure()

def addAccount(inputUsername, inputPassword, inputPasswordOne, inputDisplayName, inputImageURL):
    # PASSWORD VALIDATION
    # Passwords match
	if inputPassword != inputPasswordOne:
		return {"returnType": -1, 
				"returnMessage": "Passwords do not match"}

    # Password too short
	elif len(inputPassword) < 8:
		return {"returnType": -1,
				"returnMessage": "Password is too short (min 8)"}

    # Password too long
	elif len(inputPassword) > 30:
		return {"returnType": -1,
				"returnMessage": "Password is too long (max 30)"}
    
    # Password does not have digit
	elif not any(char.isdigit() for char in inputPassword):
		return {"returnType": -1,
				"returnMessage": "Password needs to contain a digit"}

    # Password does not have lowercase character
	elif not any(char.islower() for char in inputPassword):
		return {"returnType": -1,
				"returnMessage": "Password needs to contain a lowercase character"}

    # Password does not have uppercase character
	elif not any(char.isupper() for char in inputPassword):
		return {"returnType": -1,
				"returnMessage": "Password needs to contain an uppercase character"}




    # USERNAME VALIDATION
    # Username too short
	elif len(inputUsername) < 3:
		return {"returnType": -1,
				"returnMessage": "Username is too short (min 3)"}

    # Username too long
	elif len(inputUsername) > 16:
		return {"returnType": -1,
				"returnMessage": "Username is too long (max 16)"}

    # Username contains special characters
	elif any(not(c.isalpha() or c.isdigit()) for c in inputUsername):
		return {"returnType": -1,
				"returnMessage": "Usernames cannot contain special characters (only A-Z, a-z and 0-9)"}

    # Username already exists (also gather current highest UUID)
	highestUUID = 0
	for account in json.load(open(constants.FILE_PATH + "data/accounts.json", 'r')):
		highestUUID = max(highestUUID, account["UUID"])
		if account["username"] == inputUsername:
			return {"returnType": -1,
				"returnMessage": "Username already in use"}





    # If the code has made it to this point, then the password is valid and the username is not already being used
    # Create the account structure and add it to the database

	account = { "UUID": 	highestUUID + 1,
		"username": 		inputUsername,
		"hashed_password": 	hashPassword(inputPassword),
		"display_name":		inputDisplayName,
		"profileImage":		inputImageURL,
		"config":			json.load(open(constants.FILE_PATH + "data/default_config.json")),
		"savegames":		[]}

	accountsDB = open(constants.FILE_PATH + "data/accounts.json", 'r+') 
	accountsDBJson = json.load(accountsDB)
	accountsDBJson.append(account)
	accountsDB.seek(0)
	json.dump(accountsDBJson, accountsDB, indent=4)
	accountsDB.close()

	return {"returnType": 1,
			"returnMessage": "Successfully saved",
			"account_details": account}
	







projects/final/functions/algorithms/aoeScanner.py

from math import sqrt
from classes.global_data import constants_structure

def aoeScanner(origin, entities, room, player, reach, constants, isPlayer = False):
    constants = constants_structure()
    # Python lambda statement to determine if coordinates are within 
    # the radius distance of the origin coordinates
    isInRange = (lambda x, y, the_reach : sqrt(((origin[0] - x) ** 2) + 
		((origin[1] - y) ** 2)) <= the_reach)


    # Start with entities
    effectedEntities = []
    for entity in entities:
        if isInRange(entity.collision_box["location"][0] + (entity.collision_box["size"][0]//2), 
                    entity.collision_box["location"][1] + (entity.collision_box["size"][1]//2), reach):
            effectedEntities.append(entity)

    # Squares
    effectedSquares = []
    for y in range(len(room.layout)):
        for x in range(len(room.layout[y])):
            # squares check with less reach
            if (isInRange((x * constants.SQUARE_SIZE[0]) + room.location[0], (y * constants.SQUARE_SIZE[1]) + room.location[1], reach - 20) or # top left
                isInRange((x * constants.SQUARE_SIZE[0]) + room.location[0] + constants.SQUARE_SIZE[0], (y * constants.SQUARE_SIZE[1]) + room.location[1], reach - 20) or # top right
                isInRange((x * constants.SQUARE_SIZE[0]) + room.location[0], (y * constants.SQUARE_SIZE[1]) + room.location[1] + constants.SQUARE_SIZE[1], reach - 20) or # bottom left
                isInRange((x * constants.SQUARE_SIZE[0]) + room.location[0] + constants.SQUARE_SIZE[0], (y * constants.SQUARE_SIZE[1]) + room.location[1] + constants.SQUARE_SIZE[1], reach - 20)):  # bottom right
                effectedSquares.append([x,y])

    # Player
    playerEffected = False
    if (isInRange(player.collision_box["location"][0] + (player.collision_box["size"][0]//2), 
                    player.collision_box["location"][1] + (player.collision_box["size"][1]//2), reach) 
                    and not isPlayer):
        playerEffected = True

    return effectedEntities, effectedSquares, playerEffected










projects/final/functions/algorithms/a_star_pathfind.py
from math import sqrt
from copy import deepcopy

def a_star(start, end, room, hitbox_size, crates, doors):
    from classes.global_data import constants_structure
    constants = constants_structure()
    # at this point, room squares are either 0 for non-collidable or 1 for collidable

    # self is the enemy, since the function is contained by the enemy class
    # room is the room layout, a 2d array of squares
    # end is the coordinates of the player (2 item array of floats for x and y coordinates)
    
    # I will be implementing a variation of the A* pathfinding algorithm that operates
    # on a 2d grid, where the nodes look as per the attatched diagram (fig 3.1)
    # DRAW DIAGRAM ^
    
    # This algorithm will be used to generate a vague path, and then another algorithm will be ran which smooths the path out
    # It does this by splitting the path into straight horizontal and/or vertical parts
    # It then creates a point at the center of where these parts connect
    # This results in direct travel between two points, rather than a path being very rough and jaggedy
    # This then becomes a straight line from the player to that node
    # The algorithm is then repeated, with that new node as the target, until the enemy has a direct view of a node, at which point the shortest path has been found
    # This algorithm is not very efficient, but it provides a very good result
    # On large scale, this algorithm can look rough and inefficient, but on a small scale it should work smoothly
    # Taken from: https://gamedev.stackexchange.com/questions/81593/a-star-pathfinding-and-discrete-smooth-positions
    # ^ MAKE REFERENCE
    
    
    # end = [int(coord + 0.5) for coord in end] # Rounds both coordinates to the nearest whole number. But this might make the enemy go past the player since it will look at the top left corner
    # Rounds the coordinates to a whole number, but whichever is closest to the enemy, to prevent the algorithm searching past the player
    #real_end = end
    #real_start = start
    #print("start: ", start)
    #print("end:   ", end)
    raw_start = deepcopy(start)
    raw_end = deepcopy(end)
    end = [int((end[0] - ((constants.GAME_WINDOW_SIZE[0] - room.size[0])//2)) // constants.SQUARE_SIZE[0]), int((end[1] - ((constants.GAME_WINDOW_SIZE[1] - room.size[1])//2)) // constants.SQUARE_SIZE[1])]
    start = [int((start[0] - ((constants.GAME_WINDOW_SIZE[0] - room.size[0])//2)) // constants.SQUARE_SIZE[0]), int((start[1] - ((constants.GAME_WINDOW_SIZE[1] - room.size[1])//2)) // constants.SQUARE_SIZE[1])]
    #end = [(int(coord) if coord < start[i] else int(coord + 1)) for i, coord in enumerate(end)] 
    #print("start after translation:  ", start)
    
    #print()
    
    # A* algorithm:
    # Same expression as above, to find the closest rounding to the player from the enemy
    #pathStartingCoordinates = [(int(coord) if coord < end[i] else int(coord + 1)) for i, coord in enumerate(start)]
    pathStartingCoordinates = start
    currentNode = pathStartingCoordinates
    pathLength = 0
    path = [pathStartingCoordinates]
    failed_coordinates = []
    while currentNode != end:
        # Check all nodes around currentNode
        nextNodes = []
        pathLength += 1
        for check in [[-1,0], [1,0], [0,-1], [0,1]]:
            projected_node = [currentNode[0] + check[0], currentNode[1] + check[1]]
            projected_node_tuple = tuple(projected_node)

            if projected_node_tuple in failed_coordinates:
                continue
            
            if (projected_node[0] < 0 or
                projected_node[0] > len(room.layout[0]) or
                projected_node[1] < 0 or
                projected_node[1] > len(room.layout)):
                continue # Dont check past room boundries
                
            if (room.layout[projected_node[1]][projected_node[0]].collidable):
                #print("hit collidable at: " + str(projected_node))
                continue # Dont check collidable nodes
            
            # use pythagoras to find the direct distance between the node and the player location
            nodeHeuristic = sqrt(((projected_node[0] - end[0]) ** 2) +
                                    ((projected_node[1] - end[1]) ** 2))      
            
            nextNodes.append({"value": nodeHeuristic + pathLength,
                                "location": projected_node})
            
        # Compare nodes and find next node 
        #print("start to end:     ", start, " ", end)
        if len(nextNodes) == 0: # if hit a dead end
            if len(path) == 0:
                # No more nodes to backtrack, path is not possible
                return None
            if len(path) == 1:
                return [raw_start, raw_end]
            # Remove the last node from the path
            lastNode = path.pop()
            pathLength -= 1
            failed_coordinates.append(tuple(currentNode))
            currentNode = path[-1]
            
            #for check in [[-1,0], [1,0], [0,-1], [0,1]]:
            #    projected_node_tuple = tuple([currentNode[0] + check[0], currentNode[1] + check[1]])
            #    if projected_node_tuple in failed_coordinates and not (projected_node_tuple == lastNode_tuple or projected_node_tuple == path[-2]):
            #        failed_coordinates.remove(projected_node_tuple)
        else:

            closestNode = nextNodes[0]
            for node in nextNodes[1:]:
                closestNode = closestNode if closestNode["value"] < node["value"] else node # Set the closest node to whichever node has the smallest value
            
            # add node to list, and begin searching from it
            #print("start node is: " + str(pathStartingCoordinates))
            #print("end node is: " + str(end))
            #print("adding: " + str(closestNode["location"]))
            #print()
            path.append(closestNode["location"])
            currentNode = closestNode["location"]
            
            failed_coordinates.append(tuple(currentNode))
    
    # Post A* algorithm:    
    
    if len(path) == 1:
        return [raw_start, raw_end]
    
    # find shortcuts in the path
    # from the start of the path, traverse every node and work from the end to find one that is next to it
    new_shortcut = True
    new_path = path
    while new_shortcut:
        path = new_path
        new_shortcut = False
        for i, node in enumerate(path):
            backwards_path = path[i + 2:]
            backwards_path.reverse()
            for back_i, back_node in enumerate(backwards_path):
                # check surroundings
                for check in [[-1,0], [1,0], [0,-1], [0,1]]:
                    projected_node_tuple = tuple([node[0] + check[0], node[1] + check[1]])
                    if projected_node_tuple == tuple(back_node):
                        new_path = path[:i+1] + path[len(path)-back_i-1:]
                        new_shortcut = i != len(path) - back_i
    path = new_path
    
    
    
    
    # Now smooth path into minimum number of points, allowing overlap#
    # Do this by starting at first node, and working backwards from last node until there is direct line of sight (will require line of sight function)
    # Then put the further line of sight node next to the start node in a new faster path
    # repeat again, starting from the new furthest node, until there is line of sight to the end location
    
    #   print(path)
    
    #path[0] = real_start
    #path[-1] = real_end
    
    #path = [real_start] + deepcopy(path)[1:-2] + [real_end]
    
    new_path = [path[0]]
    current_node = path[0]
    backwards_path = deepcopy(path)
    backwards_path.reverse()
    #print("current node: ", current_node)
    #print(len(path))
    #print(len(path)-1)
    #print(path)
    continue_loop = True
    while current_node != path[-1] and continue_loop:
        #print("end node: ", path[-1])
        #print("check")
        for i, node in enumerate(backwards_path):
            if node == current_node:
                if path.index(currentNode) == len(path)-1:
                    continue_loop = False
                    break
                else:
                    new_path.append(path[path.index(currentNode)+1])
                    current_node = path[path.index(currentNode)+1]
                    break
            #print("checking line of sight from ", current_node, " to ", node)
            if line_of_sight([(current_node[0] * constants.SQUARE_SIZE[0]) + room.location[0] + (constants.SQUARE_SIZE[0]//2), (current_node[1] * constants.SQUARE_SIZE[1]) + room.location[1] + (constants.SQUARE_SIZE[1]//2)], 
                            [(node[0] * constants.SQUARE_SIZE[0]) + room.location[0]  + constants.SQUARE_SIZE[0]//2, (node[1] * constants.SQUARE_SIZE[1]) + room.location[1] + constants.SQUARE_SIZE[1]//2], 
                            room, constants, [*crates, *doors], hitbox_size) == "possible":
                #print("there is line of sight from ", current_node, " to ", node)
                #print("end node is ", path[-1])
                new_path.append(node)
                current_node = node
                break
        
            # handle if there is no line of sight between two adjasent nodes
        
    path = new_path
    
        
        
    path = [[((node[0]+0.5) * constants.SQUARE_SIZE[0]) + room.location[0], 
            ((node[1]+0.5) * constants.SQUARE_SIZE[1]) + room.location[1]]  for node in path]
    
    #print(path)
    #print(real_start)
    #print(real_end)
    #print()
    #path = [real_start] + deepcopy(path)[1:-2] + [real_end]
    return path
    # currentBox = []
    # currentDirectionVector = [int(path[0][0] - pathStartingCoordinates[0]), int(path[0][1] - pathStartingCoordinates[1])]

    # for i, node in enumerate(path[:-1]):
    #     nextCurrentDirectionVector = [int(path[i+1][0] - path[i][0]), int(path[i+1][1] - path[i][1])]
    #     if nextCurrentDirectionVector != currentDirectionVector:
    #         switchPoints.append([])   




def line_of_sight(start, end, room, constants, collidables, hitbox_size=[2,2]):
    from functions.algorithms.getMovementVector import get_movement_vector
    from functions.algorithms.collision_detection import is_colliding, collision
    # use a raytracing algorithm to check every few pixels directly between the two nodes
    check = start
    total_vector = [end[0] - start[0], end[1] - start[1]]
    vector = get_movement_vector(3 , total_vector)
    #print("checking from ", start, " to ", end, " with vector ", vector)
    #vector = [-1 * vector[0], -1 * vector[1]]
    #print(sqrt(((check[0]-end[0])**2) + ((check[1]-end[1])**2)))
    while sqrt(((check[0]-end[0])**2) + ((check[1]-end[1])**2)) > 5:
    #while check != end:
        #print(check)
        #print("start: ", start)
        #print("end: ", end)
        #print("total vector: ", total_vector)
        #print("vector: ", vector)
        #print("checking: ", check)
        #check_coords = [(check[0] * constants.SQUARE_SIZE[0]) + room.location[0], (check[1] * constants.SQUARE_SIZE[1]) + room.location[1]]
        
        for collidable in collidables:
            if collision([check[0] - (hitbox_size[0]//2),  check[1] - (hitbox_size[1]//2), *hitbox_size], [*collidable.collision_box["location"], *collidable.collision_box["size"]]):
                return "collidable"

        if is_colliding({"size": hitbox_size, "location": [check[0] - (hitbox_size[0]//2),  check[1] - (hitbox_size[1]//2)]}, room.layout, room.location, constants.SQUARE_SIZE):
            return "wall"
        check = [check[0] + vector[0], check[1] + vector[1]]
        
        #import pygame
        #pygame.draw.rect(screen, (0, 0, 0), (check[0], check[1], 10, 10))
        #print("next location: ", check)
    return "possible" #, screen

def path_possible(loc1, loc2, room_layout):
    # loc1 and 2 as grid coordinates
    
    # searches every square to see if path is possible
    
    current_loc = []
    next_locs = [loc1]
    used_locs = []
    
    while len(next_locs) > 0:
        current_loc = next_locs.pop(0)
        for relative in [[1,0], [-1,0], [0, 1], [0,-1]]:
            to_search = [current_loc[0] + relative[0],  current_loc[1] + relative[1]]
            if to_search[0] >= 0 and to_search[1] >= 0 and to_search[0] < len(room_layout[0]) and to_search[1] < len(room_layout):
                if not (room_layout[to_search[1]][to_search[0]].collidable  or  to_search in used_locs):
                    if loc2 == to_search:
                        return True
                    used_locs.append(to_search)
                    next_locs.append(to_search)
    return False
    





# ALGORITHM CANT FIND PLAYER WHEN PLAYER IS IN COLLIDABLE OBJECT, EVEN WHEN PLAYER IS NOT ACTUALLY COLLIDING WITH IT'S HITBOX. FIND A WAY TO FIX THIS

# SOLUTION: implement line of sight into initial A* algorithm, in order to skip through collidables:
# ISSUE: this will not work when the collidable is in the middle of a path, eg a fence

# SOLUTION: add another boolean for impassable collidables
# ISSUE: if you are within bounding box of non-full, impassable collidable like a fence, then the original issue will occur

# SOLUTION: add booleans for impassable directions (left fences cant be passed left, right fences cant be passed right)
# ISSUE: what do we do with corner fences. If they are both, the original issue will occcur. If they are neither, the algorithm will go through them

# SOLUTION: call all non full collisables as empty. then reassess path afterwards and check line of sight between every node. If it is broken, continue the algorithm from the previous node with the node that was full blacklisted
# ISSUE: all nodes are collidable if approached from 45 degrees. this means that even nodes with tiny collision boxes will be blacklisted even though they are technically passable

# SOLUTION: if player is in collidable, keep track of last non-collidable square and go there instead. Then use line of sight to try to get to the player when within smaller range (1 square)
# ISSUE: very complicated 

# SOLUTION: instead of using grid, use every pixel. This way the algorithm can also navigate around impassable entities such as crates which will not be on layout grid but will be on entity arrays
# ISSUES: may be very inefficient

# SOLUTION: reassess the process for creating collision boxes

# SOLUTION: check line of sight when 1 square away from the player. if there is no line of sight, backstep and blacklist square that cannot see player (sothat path will try to get different angle on the player   )


# SOLUTION: use fill algorithm to check if a path to the player exists. If it doesnt, use remembered last location instead
# now same issue exists but the other way around, where enemy cannot get out of collidable object. 
#   solution: assume that initial location is non collidable, and treat it as such
# that is not the issue. the issue is that when there is only a start and an end, and it's line of sight is blocked while the player is in a collidable, it cannot find alternative routes

# checkpoint testing determined the issue is to do with the initial a* algorithm itself (maybe cant break out of collidable?)

# turns out the issue is with the original algorithm. It is getting stuck in a corner cornered by its own tail. This means that it keeps switching between the surrounding nodes, finding a dead end, backtracing, and then repeating that with another direction till it returns to the last problem
# fixed the issue by removing the code that removes things from the unusable squre list. not sure why i was removing things from there anyway. now it has to backstep till it finds a path

# back to issue to do with line of sight within a square i think. the checkpoint 2 is now the one getting caught
# the issue is not to do with the line of sight algorithm, but the way it is triggered. there is a while loop that keeps triggering it. i will investigate why the loop doesnt break
# it is getting stuck for reason mentioned earlier. The code is unable to find a line of sight between two nodes that are next to eachother, since one is collidable



projects/final/functions/algorithms/item_lookup.py


def lookup(name):
    the_class = None
    if name == "stick":
        from classes.items.items import StickSword
        the_class = StickSword
        
    elif name == "wood_head":
        from classes.items.items import WoodenHelmet
        the_class = WoodenHelmet
    elif name == "wood_chest":
        from classes.items.items import WoodenChestplate
        the_class = WoodenChestplate
    elif name == "wood_feet":
        from classes.items.items import WoodenBoots
        the_class = WoodenBoots
        
    elif name == "chain_head":
        from classes.items.items import ChainmailHelmet
        the_class = ChainmailHelmet
    elif name == "chain_chest":
        from classes.items.items import ChainmailChestplate
        the_class = ChainmailChestplate
    elif name == "chain_feet":
        from classes.items.items import ChainmailBoots
        the_class = ChainmailBoots
        
    elif name == "metal_head":
        from classes.items.items import IronHelmet
        the_class = IronHelmet
    elif name == "metal_chest":
        from classes.items.items import IronChestplate
        the_class = IronChestplate
    elif name == "metal_feet":
        from classes.items.items import IronBoots
        the_class = IronBoots
        
    elif name == "long_sword":
        from classes.items.items import LongSword
        the_class = LongSword
    elif name == "metal_axe":
        from classes.items.items import Axe
        the_class = Axe
    elif name == "dagger":
        from classes.items.items import Dagger
        the_class = Dagger
    elif name == "mace":
        from classes.items.items import Mace
        the_class = Mace
        
    elif name == "key":
        from classes.items.items import Key
        the_class = Key
        
    return the_class



projects/final/functions/algorithms/new_savegame.py

def load_new_savegame(constants, game_id, name="Untitled Savegame"):
    from json import load
    from datetime import datetime
    now = datetime.now()
    
    with open(constants.FILE_PATH + "data/default_savegame.json", "r") as default_file:
        default_json = load(default_file)
        
    default_json["display_details"]["name"] = name
    default_json["display_details"]["id"] = game_id
    default_json["display_details"]["last_save"] = now.strftime("%d/%m/%Y, %H:%M")
    default_json["display_details"]["created"] = now.strftime("%d/%m/%Y")
    
    print("created new savegame called \"" + name + "\"")
    return default_json





def entry_loop(screen, account_details):
    print("creating new savegame")
    
    # Libraries
    import pygame
    import time
    from json import load, dump
    import shutil
    
    # Local modules
    import classes.menu as menu_classes
    from classes.global_data import draw_text
    from classes.global_data import constants_structure
    # Constants
    constants = constants_structure()

    over_screen_size = (constants.DEFAULT_SCREEN_SIZE[0]*0.8, constants.DEFAULT_SCREEN_SIZE[1]*0.8)
    over_screen = pygame.Surface(over_screen_size) 
    background_texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/buttons/ratio1-2.0.png").convert(), over_screen_size) # Use text input button design
    over_screen.blit(background_texture, (0,0))

    # MENU OBJECTS
    menu_buttons = [
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*5), 
                            size=(600, 100), 
                            text="Create Savegame", 
                            response_function=load_new_savegame,
                            font=constants.TITLE_FONT),
        menu_classes.textInputBox(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*3),
                            size=(600,100),
                            button_name="Name"),
        menu_classes.button(location=(constants.DEFAULT_SCREEN_SIZE[0]*0.1 + 10, constants.DEFAULT_SCREEN_SIZE[1]*0.1 + 10), 
                            size=(150, 50), 
                            text="Back")
        
    ]
    
    # shade over menu
    temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA) 
    pygame.draw.rect(temp_surface, (0, 0, 0, 80), (0, 0, *constants.DEFAULT_SCREEN_SIZE))
    screen.blit(temp_surface, (0,0))
    
    
    
    loop = True
    tickCount = 0
    while loop:
        tick_start = time.time()
        tickCount += 1
        keysPressed = []
        
        # FRAME CONSTANTS ONE
        mouse_pos = pygame.mouse.get_pos()
        
        # CHECK EVENTS
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                loop = False
                
            if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
                if menu_buttons[2].under_pointer:
                    return
                
                elif menu_buttons[0].under_pointer:
                    
                    # update account
                    
                    game_id = account_details["savegames"][len(account_details["savegames"])-1]["display_details"]["id"] + 1 # automatically makes the ID 1 larger than the largest ID saved (which will always be the last one)
                    account_details["savegames"].append(load_new_savegame(constants, game_id, menu_buttons[1].content))
                    # resave account - TURN THIS INTO SAVE FUNCTION WHEN ACCOUNT OBJECT IS CREATED
                    with open(constants.FILE_PATH + "data/accounts.json", 'r+') as accountsDB:
                        accountsDBJson = load(accountsDB)
                        for i, account in enumerate(accountsDBJson):
                            if account["UUID"] == account_details["UUID"]:
                                accountsDBJson[i] = account_details
                        accountsDB.seek(0)
                        dump(accountsDBJson, accountsDB, indent=4)
                        accountsDB.close()
                        
                        
                    # create files
                    
                    shutil.copytree(constants.FILE_PATH + f"data/account_games/default_games/default_levels",  # source
                                    constants.FILE_PATH + f"data/account_games/{account_details['UUID']}_games/{game_id}_levels")  # destination
                    return
                
                elif menu_buttons[1].under_pointer:
                    menu_buttons[1].response_function()
                else:
                    menu_buttons[1].selected = False
                
            if event.type == pygame.KEYDOWN:
                keysPressed.append(event.unicode)
        
        # PROCESS
        for button in menu_buttons:
            button.update(mouse_pos, keysPressed)
        
        # RENDER
        screen.blit(over_screen, (constants.DEFAULT_SCREEN_SIZE[0]*0.1, constants.DEFAULT_SCREEN_SIZE[1]*0.1))
        
        #over_screen.fill("gray")
        #over_screen.blit(background_texture, (0,0))
        
        for button in menu_buttons:
            screen = button.draw(screen, tickCount)
        
        screen = draw_text("New Savegame", screen, constants.TITLE_FONT, 
                            (constants.DEFAULT_SCREEN_SIZE[0]//2, (constants.DEFAULT_SCREEN_SIZE[1]-over_screen_size[1])//2 + 70),
                            (0,0,0),
                            "centre", "centre")
        
        # flip() draws screen to display
        pygame.display.flip()

        # Pause remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))
        



projects/final/functions/loops/options.py
def run(screen, account_details):
    print("opened options")
    
    # Libraries
    import pygame
    import time

    # Local modules
    import classes.menu as menu_classes
    from classes.global_data import constants_structure
    # Constants
    constants = constants_structure()


    # MENU OBJECTS
    menu_buttons = [
        menu_classes.button(location=(10,10), 
                            size=(150, 50), 
                            text="Back",
                            font=constants.NORMAL_FONT)
    ]

    
    loop = True
    while loop:
        tick_start = time.time()
        
        # FRAME CONSTANTS ONE
        mouse_pos = pygame.mouse.get_pos()
        
        # CHECK EVENTS
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                loop = False
                
            if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
                if menu_buttons[0].under_pointer:
                    return
        
        # PROCESS
        for button in menu_buttons:
            button.update(mouse_pos)
        
        # RENDER
        screen.fill("gray")
        for button in menu_buttons:
            screen = button.draw(screen)
        
        
        # flip() draws screen to display
        pygame.display.flip()

        # Pause remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))
        



projects/final/functions/loops/main_menu.py
def run(screen, account_details):
    print("Logged into account with UUID " + str(account_details["UUID"]) + 
        "\nAccount username is " + account_details["username"])
    
    # Libraries
    import pygame
    import time

    # Local modules
    import classes.menu as menu_classes
    from functions.loops.savegames import run as savegames
    from functions.loops.options import run as options
    from functions.loops.credits import run as game_credits
    from classes.global_data import constants_structure
    # Constants
    constants = constants_structure()


    # MENU OBJECTS
    menu_buttons = [
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*3), 
                            size=(600, 100), 
                            text="Savegames", 
                            response_function=savegames,
                        font=constants.TITLE_FONT),
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*4), 
                            size=(600, 100), 
                            text="Options", 
                            response_function=options,
                        font=constants.TITLE_FONT),
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*5), 
                            size=(600, 100), 
                            text="Credits", 
                            response_function=game_credits,
                        font=constants.TITLE_FONT),
        menu_classes.button(location=(10,10), 
                            size=(300, 50), 
                            text="Log Out")
        
    ]



    
    loop = True
    while loop:
        tick_start = time.time()
        
        # FRAME CONSTANTS ONE
        mouse_pos = pygame.mouse.get_pos()
        
        # CHECK EVENTS
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                loop = False
                
            if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
                for button in menu_buttons:
                    if button.under_pointer:
                        if button == menu_buttons[3]:
                            return
                        button.response_function(screen, account_details)
                    else:
                        button.selected = False
        
        # PROCESS
        for button in menu_buttons:
            button.update(mouse_pos)
        
        # RENDER
        screen.fill("gray")
        for button in menu_buttons:
            screen = button.draw(screen)
            
        content = constants.TITLE_FONT.render("Main Menu", True, (0,0,0))
        screen.blit(content,((constants.DEFAULT_SCREEN_SIZE[0]-content.get_width())//2, int((constants.DEFAULT_SCREEN_SIZE[1]-200)//5*1.5)))
        
        # flip() draws screen to display
        pygame.display.flip()

        # Pause remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))
        



projects/final/functions/loops/pause_screen.py

def run(screen, key_bindings):
    import pygame
    import time
    from classes.global_data import constants_structure, draw_text
    constants = constants_structure()
    
    
    temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
    temp_surface.fill((100,100,100,100))
    screen.blit(temp_surface, [0,0])
        
        
    loop = True
    while loop:
        tick_start = time.time()
        
        # FRAME CONSTANTS ONE
        mouse_pos = pygame.mouse.get_pos()
        
        
        # CHECK EVENTS
        events = pygame.event.get()
        for event in events:
            if event.type == pygame.QUIT:
                loop = False
            if event.type == pygame.KEYDOWN:
                if key_bindings.get(str(event.key)) == "pause":
                    loop = False
            #if event.type == pygame.KEYDOWN:
                
        
        # RENDER
        
        screen = draw_text("Game Paused", screen, constants.TITLE_FONT, [constants.DEFAULT_SCREEN_SIZE[0]//2, constants.DEFAULT_SCREEN_SIZE[1]//3], (0,0,0), "centre", "above")
        pause_key = "P" # update to take key from keybindings
        screen = draw_text(f"Press {pause_key} to unpause", screen, constants.NORMAL_FONT, [constants.DEFAULT_SCREEN_SIZE[0]//2, constants.DEFAULT_SCREEN_SIZE[1]//3], (0,0,0), "centre", "below")
        #pygame.draw.rect(temp_surface, (255, 0, 0, 63), (0, 0, 60, 60))
        #screen.fill("gray")
        
        
        # flip() draws screen to display
        pygame.display.flip()

        # Pause remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))
    
    return



projects/final/functions/loops/savegames.py
def run(screen, account_details):
    print("opened savegames")
    
    
    # COULD ADD:
    # - scroller bar for savegames
    # - delete savegame button, with confirmation screen
    # - rename savegame button
    
    # Libraries
    import pygame
    import time

    # Local modules
    import classes.menu as menu_classes
    from classes.global_data import draw_text
    from classes.global_data import constants_structure
    import functions.algorithms.new_savegame
    # Constants
    constants = constants_structure()

    only_refreshing = True
    while only_refreshing: # Allows the page to be refreshed later so that the a savegame can be added to the list when it is created
        # MENU OBJECTS
        index = -1
        savegame_buttons = []
        savegame_button_size = (400, 200)
        for i, savegame in enumerate(account_details["savegames"]):
            if i%2 == 0:
                x_loc = (constants.DEFAULT_SCREEN_SIZE[0]//2) - savegame_button_size[0] - 5
            else:
                x_loc = (constants.DEFAULT_SCREEN_SIZE[0]//2) + 5
            savegame_buttons.append(menu_classes.savegameButton(location=( x_loc, 150 + ((len(savegame_buttons)//2) * (savegame_button_size[1] + 15)) ), 
                                                                size=savegame_button_size, 
                                                                savegame_display_details=savegame["display_details"],
                                                                game_data=[account_details["UUID"], savegame["display_details"]["id"]]))
            index = i
        
        index += 1
        if index%2 == 0:
            x_loc = (constants.DEFAULT_SCREEN_SIZE[0]//2) - savegame_button_size[0] - 5
        else:
            x_loc = (constants.DEFAULT_SCREEN_SIZE[0]//2) + 5
        new_savegame_location = ( x_loc, 
                                150 + ((len(savegame_buttons)//2) * (savegame_button_size[1] + 15)) )
        
        menu_buttons = [
            menu_classes.button(location=(10,10), 
                                size=(150, 50), 
                                text="Back",
                                font=constants.NORMAL_FONT),
            menu_classes.button(location=new_savegame_location, 
                                size=(400, 200), 
                                text="+", 
                                response_function=functions.algorithms.new_savegame.entry_loop,
                                font=constants.TITLE_FONT)
        ]
        
        
        
        loop = True
        while loop:
            tick_start = time.time()
            
            # FRAME CONSTANTS ONE
            mouse_pos = pygame.mouse.get_pos()
            
            # CHECK EVENTS
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    loop = False
                    
                if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
                    if menu_buttons[0].under_pointer:
                        return
                    elif menu_buttons[1].under_pointer:
                        menu_buttons[1].response_function(screen, account_details)
                        loop = False
                        break
                    else:
                        for savegame in savegame_buttons:
                            if savegame.under_pointer:
                                savegame.response_function(screen)
                                loop = False
                                break
            
            # PROCESS
            for button in menu_buttons:
                button.update(mouse_pos)
                
            for button in savegame_buttons:
                button.update(mouse_pos)
            
            # RENDER
            screen.fill("gray")
            for button in menu_buttons:
                screen = button.draw(screen)
            
            for button in savegame_buttons:
                screen = button.draw(screen)
                
            screen = draw_text("Savegames", screen, constants.TITLE_FONT, 
                                (constants.DEFAULT_SCREEN_SIZE[0]//2, 70),
                                (0,0,0),
                                "centre", "centre")
            
            
            # flip() draws screen to display
            pygame.display.flip()

            # Pause remainder of tick
            time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))
    



projects/final/functions/loops/savegame_options.py


def open_savegame(account_id, savegame_id, display_data, screen):
    print("editing savegame")
    
    # Libraries
    import pygame
    import time
    from json import load, dump
    
    # Local modules
    import classes.menu as menu_classes
    from classes.global_data import draw_text
    from classes.global_data import constants_structure
    # Constants
    constants = constants_structure()

    over_screen_size = (constants.DEFAULT_SCREEN_SIZE[0]*0.8, constants.DEFAULT_SCREEN_SIZE[1]*0.8)
    over_screen = pygame.Surface(over_screen_size) 
    background_texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/buttons/ratio1-2.0.png").convert(), over_screen_size) # Use text input button design
    over_screen.blit(background_texture, (0,0))

    # MENU OBJECTS
    from game_main import main_game
    from functions.algorithms.delete_savegame import delete_savegame
    menu_buttons = [
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*3), 
                            size=(600, 100), 
                            text="Play", 
                            response_function=main_game,
                            font=constants.TITLE_FONT),
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-300)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*4.5),
                            size=(300,100),
                            text="Delete",
                            response_function=delete_savegame,
                            font=constants.NORMAL_FONT),
        menu_classes.button(location=(constants.DEFAULT_SCREEN_SIZE[0]*0.1 + 10, constants.DEFAULT_SCREEN_SIZE[1]*0.1 + 10), 
                            size=(150, 50), 
                            text="Back")
        
    ]
    
    # shade over menu
    temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA) 
    pygame.draw.rect(temp_surface, (0, 0, 0, 80), (0, 0, *constants.DEFAULT_SCREEN_SIZE))
    screen.blit(temp_surface, (0,0))
    
    
    
    loop = True
    tickCount = 0
    while loop:
        tick_start = time.time()
        tickCount += 1
        keysPressed = []
        
        # FRAME CONSTANTS ONE
        mouse_pos = pygame.mouse.get_pos()
        
        # CHECK EVENTS
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                loop = False
                
            if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
                if menu_buttons[2].under_pointer:
                    return
                
                elif menu_buttons[0].under_pointer:
                    main_game(account_id, savegame_id, screen)
                    return
                
                elif menu_buttons[1].under_pointer:
                    delete_savegame(account_id, savegame_id)
                    return
                
            if event.type == pygame.KEYDOWN:
                keysPressed.append(event.unicode)
        
        # PROCESS
        for button in menu_buttons:
            button.update(mouse_pos, keysPressed)
        
        # RENDER
        screen.blit(over_screen, (constants.DEFAULT_SCREEN_SIZE[0]*0.1, constants.DEFAULT_SCREEN_SIZE[1]*0.1))
        
        #over_screen.fill("gray")
        for button in menu_buttons:
            screen = button.draw(screen, tickCount)
        
        screen = draw_text(display_data["name"], screen, constants.TITLE_FONT, 
                            (constants.DEFAULT_SCREEN_SIZE[0]//2, (constants.DEFAULT_SCREEN_SIZE[1]-over_screen_size[1])//2 + 140),
                            (0,0,0),
                            "centre", "centre")
        
        # flip() draws screen to display
        pygame.display.flip()

        # Pause remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))
        



projects/final/functions/loops/log_in_loop.py
def run(screen):
    print("log in button pressed")
    # Libraries
    import pygame
    import time

    # Local modules
    import classes.menu as menu_classes
    from functions.algorithms.log_in import do_log_in
    from classes.global_data import constants_structure
    from functions.loops.main_menu import run as main_menu
    # Constants
    constants = constants_structure()


    # MENU OBJECTS
    menu_buttons = [
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*5), 
                            size=(600, 100), 
                            text="Log-In", 
                            response_function=do_log_in,
                            font=constants.TITLE_FONT),
        menu_classes.textInputBox(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*3),
                            size=(600,100),
                            button_name="Password",
                            protected=True),
        menu_classes.textInputBox(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*2),
                            size=(600,100),
                            button_name="Username"),
        menu_classes.button(location=(10,10), 
                            size=(150, 50), 
                            text="Back")
        
    ]

    displayedError = None


    
    loop = True
    tickCount = 0
    responce = {}
    while loop:
        tick_start = time.time()
        tickCount += 1
        
        # FRAME CONSTANTS ONE
        mouse_pos = pygame.mouse.get_pos()
        keysPressed = []
        
        # CHECK EVENTS
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                loop = False
                
            if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
                if menu_buttons[0].under_pointer: # Log-in button
                    
                    responce = menu_buttons[0].response_function(menu_buttons[2].content, # Username
                                                                menu_buttons[1].content)  # Password
                
                elif menu_buttons[3].under_pointer: # back button
                    return
                    
                for button in menu_buttons[1:]:
                    if button.under_pointer:
                        button.response_function()
                    else:
                        button.selected = False
                        
            if event.type == pygame.KEYDOWN:
                keysPressed.append(event.unicode)
                
        # PROCESS
        #if keysPressed != []:
            #print(keysPressed)
        for button in menu_buttons:
            button.update(mouse_pos, keysPressed)
            
            
        if responce != {}:
            if responce["returnType"] == 1:
                main_menu(screen, responce["account_details"])
                
                return # After main menu loop is finished, create account section should be skipped in exchange for going directly back to account select
            else:
                displayedError = menu_classes.displayedError(responce["returnMessage"], tickCount)
                
        
        # RENDER
        screen.fill("gray")
        for button in menu_buttons:
            screen = button.draw(screen, tickCount)
        
        if displayedError != None:
            screen = displayedError.draw(screen)
            
        content = constants.TITLE_FONT.render("Log-In", True, (0,0,0))
        screen.blit(content,((constants.DEFAULT_SCREEN_SIZE[0]-content.get_width())//2, int((constants.DEFAULT_SCREEN_SIZE[1]-200)//10*1.25)))
        
        
        # flip() draws screen to display
        pygame.display.flip()

        # Pause remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))
        



projects/final/functions/loops/create_account_loop.py
def run(screen):
    print("create account button pressed")
    # Libraries
    import pygame
    import time

    # Local modules
    import classes.menu as menu_classes
    from functions.algorithms.account_creation import addAccount as account_creation_check
    from classes.global_data import constants_structure
    from functions.loops.main_menu import run as main_menu
    # Constants
    constants = constants_structure()


    # MENU OBJECTS
    menu_buttons = [
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*5.5), 
                            size=(600, 100), 
                            text="Create", 
                            response_function=account_creation_check,
                        font=constants.TITLE_FONT),
        menu_classes.textInputBox(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*4.5),
                            size=(600,100),
                            button_name="Re-enter Password",
                            protected=True),
        menu_classes.textInputBox(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*3.5),
                            size=(600,100),
                            button_name="Password",
                            protected=True),
        menu_classes.textInputBox(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*2.5),
                            size=(600,100),
                            button_name="Display Name"),
        menu_classes.textInputBox(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*1.5),
                            size=(600,100),
                            button_name="Username"),
        menu_classes.button(location=(10,10), 
                            size=(150, 50), 
                            text="Back")
        
    ]

    displayedError = None


    
    loop = True
    tickCount = 0
    responce = {}
    while loop:
        tick_start = time.time()
        tickCount += 1
        
        # FRAME CONSTANTS ONE
        mouse_pos = pygame.mouse.get_pos()
        keysPressed = []
        
        # CHECK EVENTS
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                loop = False
                
            if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
                if menu_buttons[0].under_pointer: # Create button
                    responce = menu_buttons[0].response_function(menu_buttons[4].content,   # Username
                                                        menu_buttons[1].content,            # Re-enter password
                                                        menu_buttons[2].content,            # Password (can be any way around with the one above, since they should match, and order is unnecessary)
                                                        menu_buttons[3].content,            # Display name
                                                        "")
                elif menu_buttons[5].under_pointer: # back button
                    return
                for button in menu_buttons[1:]:
                    if button.under_pointer:
                        button.response_function()
                    else:
                        button.selected = False
                        
            if event.type == pygame.KEYDOWN:
                keysPressed.append(event.unicode)
                
        # PROCESS
        #if keysPressed != []:
        #    print(keysPressed)
        for button in menu_buttons:
            button.update(mouse_pos, keysPressed)
            
            
        if responce != {}:
            if responce["returnType"] == 1:
                main_menu(screen, responce["account_details"])
                
                return # After main menu loop is finished, create account section should be skipped in exchange for going directly back to account select
            else:
                displayedError = menu_classes.displayedError(responce["returnMessage"], tickCount)
                
        
        # RENDER
        screen.fill("gray")
        for button in menu_buttons:
            screen = button.draw(screen, tickCount)
        
        if displayedError != None:
            screen = displayedError.draw(screen)
            
        content = constants.TITLE_FONT.render("Create Account", True, (0,0,0))
        screen.blit(content,((constants.DEFAULT_SCREEN_SIZE[0]-content.get_width())//2, int((constants.DEFAULT_SCREEN_SIZE[1]-200)//10)))
        
        
        # flip() draws screen to display
        pygame.display.flip()

        # Pause remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))
        



projects/final/functions/loops/transition_animation.py

import pygame
import time

def animation(screen, player_loc, game_window, last_room_screenshot, gui_window, background, player):
    from classes.global_data import constants_structure, draw_text
    constants = constants_structure()
    processTime = 1
    
    if player_loc == "top":
        player_loc = "up"
    elif player_loc == "bottom":
        player_loc = "down"
        
    #part_frames = 30
    first_part_frames = 10
    second_part_frames = 20
    
    for frame in range(first_part_frames + second_part_frames): # * 2
        tick_start = time.time()
        screen.blit(background, (0,0))
        if frame <= first_part_frames:
            #player.teleport(player.x_pos - (old_player_x_pos - player_loc[0] // 10),  player.y_pos + (old_player_y_pos - player_loc[1] // 10))
            if player_loc == "up":
                screen.blit(last_room_screenshot, (0, 0 + (frame * (constants.GAME_WINDOW_SIZE[1]//first_part_frames))))
                screen.blit(game_window, (0, 0 - constants.GAME_WINDOW_SIZE[1] + (frame * (constants.GAME_WINDOW_SIZE[1]//first_part_frames))))
            elif player_loc == "down":
                screen.blit(last_room_screenshot, (0, 0 - (frame * (constants.GAME_WINDOW_SIZE[1]//first_part_frames))))
                screen.blit(game_window, (0, constants.GAME_WINDOW_SIZE[1] - (frame * (constants.GAME_WINDOW_SIZE[1]//first_part_frames))))
            elif player_loc == "left":
                screen.blit(last_room_screenshot, (0 + (frame * (constants.GAME_WINDOW_SIZE[0]//first_part_frames)), 0))
                screen.blit(game_window, (0 - constants.GAME_WINDOW_SIZE[0] + (frame * (constants.GAME_WINDOW_SIZE[0]//first_part_frames)), 0))
            elif player_loc == "right":
                screen.blit(last_room_screenshot, (0 - (frame * (constants.GAME_WINDOW_SIZE[0]//first_part_frames)), 0))
                screen.blit(game_window, (constants.GAME_WINDOW_SIZE[0] - (frame * (constants.GAME_WINDOW_SIZE[0]//first_part_frames)), 0))
        else:
            screen.blit(game_window,(0,0))
            # find frame
            anim_frame = (frame-first_part_frames) // 3
            while anim_frame >= len(player.assets[f"run_{player_loc}"]):
                anim_frame -= len(player.assets[f"run_{player_loc}"])
            
            # find position
            pos = [player.x_pos, player.y_pos]
            if player_loc == "up":
                pos[1] = game_window.get_height() - ((frame-first_part_frames) / second_part_frames * (game_window.get_height() - player.y_pos))
            elif player_loc == "down":
                pos[1] =  ((frame-first_part_frames) / second_part_frames * (player.y_pos + player.size[1])) - player.size[1]
            elif player_loc == "left":
                pos[0] = game_window.get_width() - ((frame-first_part_frames) / second_part_frames * (game_window.get_width() - player.x_pos))
            elif player_loc == "right":
                pos[0] = ((frame-first_part_frames) / second_part_frames * (player.x_pos + player.size[0])) - player.size[0]
            screen.blit(player.hand_texture, pos)
            temp_surface = pygame.Surface(player.size, pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
            temp_surface.blit(pygame.transform.scale(player.assets[f"run_{player_loc}"][anim_frame], player.size),(0,0))
            screen.blit(temp_surface, pos)



        screen.blit(gui_window,(constants.GAME_WINDOW_SIZE[0], 0) if constants.LANDSCAPE else (0, constants.GAME_WINDOW_SIZE[1]))

        thefps = int((1 / processTime)*100)/100
        draw_text(f"FPS: {thefps}", screen, constants.SMALL_FONT, (10,10), (255,255,255), "left", "below")
        
        # flip() draws screen to display
        pygame.display.flip()
        
        time.sleep(max(0, (1/(constants.MENU_FPS*2))-(time.time()-tick_start)))
        processTime = time.time()-tick_start



projects/final/functions/loops/credits.py
def run(screen, account_details):
    print("entered credits screen")
    
    # Libraries
    import pygame
    import time

    # Local modules
    import classes.menu as menu_classes
    from classes.global_data import constants_structure
    # Constants
    constants = constants_structure()


    # MENU OBJECTS
    menu_buttons = [
        menu_classes.button(location=(10,10), 
                            size=(150, 50), 
                            text="Back",
                            font=constants.NORMAL_FONT)
    ]


    creditsText = "This game was designed\nand written by George Berkeley\n\nAssets were taken and derived from \nhttps://secrethideout.itch.io/\nrogue-dungeon-tileset-16x16"
    lines = creditsText.split("\n")
    
    loop = True
    while loop:
        tick_start = time.time()
        
        # FRAME CONSTANTS ONE
        mouse_pos = pygame.mouse.get_pos()
        
        # CHECK EVENTS
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                loop = False
                
            if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
                if menu_buttons[0].under_pointer:
                    return
        
        # PROCESS
        for button in menu_buttons:
            button.update(mouse_pos)
        
        # RENDER
        screen.fill("gray")
        for button in menu_buttons:
            screen = button.draw(screen)
        
        
        for line_index, line in enumerate(lines):
            content = constants.NORMAL_FONT.render(line, True, (0,0,0))
            screen.blit(content, ((constants.DEFAULT_SCREEN_SIZE[0] - content.get_width())//2, (constants.DEFAULT_SCREEN_SIZE[1] - (content.get_height()*len(lines)))//2 + (content.get_height()*line_index)))
        
        
        # flip() draws screen to display
        pygame.display.flip()

        # Pause remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))
        



projects/final/functions/loops/inventory.py

import pygame
import time

def run(inventory, screen, key_bindings):
    
    from classes.global_data import constants_structure, draw_text
    constants = constants_structure()
    
    inv_texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/inventory.png").convert(), ((constants.DEFAULT_SCREEN_SIZE[1] * 0.9)//5*3, constants.DEFAULT_SCREEN_SIZE[1] * 0.9))
    square_size = (inv_texture.get_width()//3, inv_texture.get_height()//5)
    inv_location = ((constants.DEFAULT_SCREEN_SIZE[0] - inv_texture.get_width())//2, (constants.DEFAULT_SCREEN_SIZE[1] - inv_texture.get_height())//2)
    selected_inv_texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/inventory_highlighted.png").convert(), square_size)
    
    temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
    temp_surface.fill((100,100,100,200))
    screen.blit(temp_surface, [0,0])
    background = screen.copy()
        
    selected_item = None
    
    throw_away_items = []
        
    loop = True
    while loop:
        tick_start = time.time()
        
        # FRAME CONSTANTS ONE
        mouse_pos = pygame.mouse.get_pos()
        
        selected_square = (((mouse_pos[0] - inv_location[0])//square_size[0]),   (mouse_pos[1] - inv_location[1])//square_size[1]) # comes as grid coordinate not screen coordinate
        selected_index = None
        if (selected_square[0] >= 0 and selected_square[0] < 3) and (selected_square[1] >= 0 and selected_square[1] < 4) : # if in main inv, will handle hands later
            selected_index = selected_square[1] * 3 + selected_square[0] + 2
            #print("set selected index to ", selected_index)
        elif ((selected_square[0] == 0) or (selected_square[0] == 2)) and (selected_square[1] == 4): # for lower two
            selected_index = selected_square[0]//2
            #print("set selected index to ", selected_index)
            
        
        # CHECK EVENTS
        events = pygame.event.get()
        for event in events:
            if event.type == pygame.QUIT:
                loop = False
            if event.type == pygame.KEYDOWN:
                if key_bindings.get(str(event.key)) == "inventory":
                    loop = False
            if event.type == pygame.MOUSEBUTTONUP:
                #print("mouse button up")
                if selected_index != None:
                    #print("index is selected")
                    if selected_item == None:
                        #print("pickup")
                        selected_item = inventory[selected_index]
                        inventory[selected_index] = None
                    else:
                        #print("putdown")
                        temp = None
                        if inventory[selected_index] != None:
                            temp = inventory[selected_index]
                            
                        do_move = True
                        # Not working correctly:
                        #print(selected_item.sort)
                        if selected_index == 8:
                            if selected_item.sort != "ring":
                                do_move = False
                        elif selected_index == 9:
                            if selected_item.sort != "necklace":
                                do_move = False
                        elif selected_index == 10:
                            if selected_item.sort != "bracelet":
                                do_move = False
                        elif selected_index == 11:
                            if selected_item.sort != "helmet":
                                do_move = False
                        elif selected_index == 12:
                            if selected_item.sort != "chestplate":
                                do_move = False
                        elif selected_index == 13:
                            if selected_item.sort != "boots":
                                do_move = False
                        if do_move:
                            inventory[selected_index] = selected_item
                            selected_item = temp
                            
                        
                elif selected_item != None:
                    throw_away_items.append(selected_item)
                    selected_item = None
                    
        
        # RENDER
        screen.blit(background, (0,0))
        
        #screen = draw_text("Inventory", screen, constants.TITLE_FONT, [constants.DEFAULT_SCREEN_SIZE[0]//2, constants.DEFAULT_SCREEN_SIZE[1]//3], (0,0,0), "centre", "above")
        
        # Inventory
        inv_location = ((constants.DEFAULT_SCREEN_SIZE[0] - inv_texture.get_width()) //2, (constants.DEFAULT_SCREEN_SIZE[1] - inv_texture.get_height()) //2)
        temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA) 
        temp_surface.blit(inv_texture, inv_location)
        screen.blit(temp_surface, (0,0))
        
        # Items
        temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA) 
        if inventory[0] != None:
                temp_surface.blit(pygame.transform.scale(inventory[0].inv_texture, (square_size[0]*0.7, square_size[1]*0.7)), 
                                    (((constants.DEFAULT_SCREEN_SIZE[0] - inv_texture.get_width())//2) + square_size[0]*0.15,   (constants.DEFAULT_SCREEN_SIZE[1] + inv_texture.get_height())//2 - square_size[1] + square_size[1]*0.15))
        if inventory[1] != None:
                temp_surface.blit(pygame.transform.scale(inventory[1].inv_texture, (square_size[0]*0.7, square_size[1]*0.7)), 
                                    (((constants.DEFAULT_SCREEN_SIZE[0] - inv_texture.get_width())//2) + (square_size[0] * 2) + square_size[0]*0.15,   (constants.DEFAULT_SCREEN_SIZE[1] + inv_texture.get_height())//2 - square_size[1] + square_size[1]*0.15))
        for i, item in enumerate(inventory[2:]):
            if item != None:
                temp_surface.blit(pygame.transform.scale(item.inv_texture, (square_size[0]*0.7, square_size[1]*0.7)), 
                                    ((i - (((i)//3)*3)) * square_size[0] + ((constants.DEFAULT_SCREEN_SIZE[0] - inv_texture.get_width())//2) + square_size[0]*0.15,   (i)//3 * square_size[1] + ((constants.DEFAULT_SCREEN_SIZE[1] - inv_texture.get_height())//2) + square_size[1]*0.15))
        
        screen.blit(temp_surface, (0,0))
        
        
        # Item hover
        temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA) 
        if (mouse_pos[0] > inv_location[0]  and  mouse_pos[0] < inv_location[0] + (3*square_size[0])  and 
            mouse_pos[1] > inv_location[1]  and  mouse_pos[1] < inv_location[1] + (5*square_size[1])  and  # within boundries
            selected_square != (1, 4)): # dont use empty square
            temp_surface.blit(selected_inv_texture, (selected_square[0] * square_size[0] + inv_location[0], selected_square[1] * square_size[1] + inv_location[1]))
        
        screen.blit(temp_surface, (0,0))
        
        # Held item
        temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA) 
        if selected_item != None:
            temp_surface.blit(pygame.transform.scale(selected_item.inv_texture, square_size), (mouse_pos[0] - (square_size[0]//2), mouse_pos[1] - (square_size[1]//2)))
        screen.blit(temp_surface, (0,0))
        
        
        #pause_key = "P" # update to take key from keybindings
        #screen = draw_text(f"Press {pause_key} to unpause", screen, constants.NORMAL_FONT, [constants.DEFAULT_SCREEN_SIZE[0]//2, constants.DEFAULT_SCREEN_SIZE[1]//3], (0,0,0), "centre", "below")
        #pygame.draw.rect(temp_surface, (255, 0, 0, 63), (0, 0, 60, 60))
        #screen.fill("gray")
        
        
        # flip() draws screen to display
        pygame.display.flip()

        # Pause remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))
    

    return inventory, throw_away_items



projects/final/data/accounts copy.json
[
    {
        "UUID": 1,
        "username": "george",
        "hashed_password": "FWij^Z'imehZ'Xj8/'j^[P",
        "display_name": "George",
        "profileImage": "",
        "config": {
            "volume": {
                "master_volume": 1,
                "enemy_volume": 0.5,
                "player_volume": 0.5,
                "menu_volume": 0.5,
                "music": 0.5
            },
            "key_bindings":{
                "119": "up",
                "115": "down",
                "97": "left",
                "100": "right",
                "102": "inventory",
                "101": "switch_hand",
                "1073742049": "sprint",
                "112": "pause",
                "49": "main_hand",
                "50": "off_hand",
                "32": "boost",
                "L_CLICK": "attack",
                "114": "interact"
            },
            "max_FPS": 30,
            "mini_map_displayed": true,
            "inventory_displayed": true,
            "armour_displayed": true
        },
        "savegames": [
            {
                "display_details": {
                    "name": "My New Savegame",
                    "level": 0,
                    "last_save": "05/01/2024, 10:48",
                    "created": "05/01/2024"
                }
            },
            {
                "display_details": {
                    "name": "George's New Game",
                    "level": 0,
                    "last_save": "05/01/2024, 10:49",
                    "created": "05/01/2024"
                }
            },
            {
                "display_details": {
                    "name": "Another Game",
                    "level": 0,
                    "last_save": "05/01/2024, 11:20",
                    "created": "05/01/2024"
                }
            }
        ]
    },
    {
        "UUID": 2,
        "username": "shmung",
        "hashed_password": "kdi^&M]ki&MXj8/&i^cP",
        "display_name": "shmungy",
        "profileImage": "",
        "config": {
            "volume": {
                "master_volume": 1,
                "enemy_volume": 0.5,
                "player_volume": 0.5,
                "menu_volume": 0.5,
                "music": 0.5
            },
            "key_bindings": {
                "119": "up",
                "115": "down",
                "97": "left",
                "100": "right",
                "102": "inventory",
                "101": "switch_hand",
                "1073742049": "sprint",
                "112": "pause",
                "49": "main_hand",
                "50": "off_hand",
                "32": "boost",
                "L_CLICK": "attack",
                "114": "interact"
            },
            "max_FPS": 30,
            "mini_map_displayed": true,
            "inventory_displayed": true,
            "armour_displayed": true
        },
        "savegames": [
            {
                "display_details": {
                    "name": "new game",
                    "level": 0,
                    "last_save": "10/01/2024, 15:26",
                    "created": "10/01/2024"
                }
            },
            {
                "display_details": {
                    "name": "another savegame",
                    "level": 0,
                    "last_save": "10/01/2024, 15:28",
                    "created": "10/01/2024"
                }
            }
        ]
    }
]



projects/final/data/default_config.json
{
    "volume":{
        "master_volume": 1,
        "enemy_volume": 0.5,
        "player_volume": 0.5,
        "menu_volume": 0.5,
        "music": 0.5
    },

    "key_bindings":{
        "119": "up",
        "115": "down",
        "97": "left",
        "100": "right",
        "102": "inventory",
        "101": "switch_hand",
        "1073742049": "sprint",
        "112": "pause",
        "49": "main_hand",
        "50": "off_hand",
        "32": "boost",
        "L_CLICK": "attack",
        "114": "interact"
    },

    "max_FPS": 30,

    "mini_map_displayed": true,
    "inventory_displayed": true,
    "armour_displayed": true
}



projects/final/data/default_savegame.json
{
    "display_details": {
        "name" : "",
        "level": 0,
        "last_save": "",
        "created": ""
    }
}



projects/final/data/accounts.json
[
    {
        "UUID": 1,
        "username": "george",
        "hashed_password": "FWij^Z'imehZ'Xj8/'j^[P",
        "display_name": "George",
        "profileImage": "",
        "config": {
            "volume": {
                "master_volume": 1,
                "enemy_volume": 0.5,
                "player_volume": 0.5,
                "menu_volume": 0.5,
                "music": 0.5
            },
            "key_bindings": {
                "119": "up",
                "115": "down",
                "97": "left",
                "100": "right",
                "102": "inventory",
                "101": "switch_hand",
                "1073742049": "sprint",
                "112": "pause",
                "49": "main_hand",
                "50": "off_hand",
                "32": "boost",
                "L_CLICK": "attack",
                "114": "interact"
            },
            "max_FPS": 30,
            "mini_map_displayed": true,
            "inventory_displayed": true,
            "armour_displayed": true
        },
        "savegames": [
            {
                "display_details": {
                    "name": "My New Savegame",
                    "id": 0,
                    "level": 0,
                    "last_save": "05/01/2024, 10:48",
                    "created": "05/01/2024"
                }
            }
        ]
    },
    {
        "UUID": 2,
        "username": "shmung",
        "hashed_password": "kdi^&M]ki&MXj8/&i^cP",
        "display_name": "shmungy",
        "profileImage": "",
        "config": {
            "volume": {
                "master_volume": 1,
                "enemy_volume": 0.5,
                "player_volume": 0.5,
                "menu_volume": 0.5,
                "music": 0.5
            },
            "key_bindings": {
                "119": "up",
                "115": "down",
                "97": "left",
                "100": "right",
                "102": "inventory",
                "101": "switch_hand",
                "1073742049": "sprint",
                "112": "pause",
                "49": "main_hand",
                "50": "off_hand",
                "32": "boost",
                "L_CLICK": "attack",
                "114": "interact"
            },
            "max_FPS": 30,
            "mini_map_displayed": true,
            "inventory_displayed": true,
            "armour_displayed": true
        },
        "savegames": [
            {
                "display_details": {
                    "name": "new game",
                    "id": 0,
                    "level": 0,
                    "last_save": "10/01/2024, 15:26",
                    "created": "10/01/2024"
                }
            },
            {
                "display_details": {
                    "name": "another savegame",
                    "id": 1,
                    "level": 0,
                    "last_save": "10/01/2024, 15:28",
                    "created": "10/01/2024"
                }
            }
        ]
    }
]



projects/final/data/account_games/player_default.json
{
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



projects/final/data/account_games/1_games/0_levels/rooms_-1/player.json
{
    "lives": 3,
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



projects/final/data/account_games/1_games/0_levels/rooms_-1/1.json
{
    "id": 1, 
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null}, 
        "right": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]}, 
        "up": {"type": "keyhole", "complete": false, "colour": [255, 100, 100, 100]}, 
        "down": {"type": "kill_count", "complete": false, "num": 1, "colour": null}
        }, 
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 2, 2, 0, 0, 0, 0, {"id":5,"colour":[255, 100, 100, 100]}, {"id":6,"colour":[255, 100, 100, 100]}, 1], 
        [1, 2, {"id": 3, "pos": "vbr"}, 0, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, {"id": 8, "pos": "htl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 4, 0, 0, 7], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 4, {"id": 12, "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, {"id": 11, "pos": "htl", "colour": [255, 100, 100, 100]}, 0, 2, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 10, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
        ],
    
        "entities": [
            {"name": "goblin", "x": 8, "y": 4},
            {"name": "item", "x": 400, "y": 400, "item": "key", "payload": {"colour": [255, 100, 100, 100]}}
        ]
    }



projects/final/data/account_games/1_games/0_levels/rooms_-1/2.json
{
    "id":2,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "up": null,
        "down": null
        
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 1
        },
        {"name": "goblin",
        "x": 8,
        "y": 8
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_-1/layout.json
[   [0, 0, 0, 0, 0],
    [0, 0, 5, 0, 0],
    [0, 2, 1, 3, 0],
    [0, 0, 4, 0, 0],
    [0, 0, 0, 0, 0]
]



projects/final/data/account_games/1_games/0_levels/rooms_-1/3.json
{
    "id":3,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "right": null,
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 2, 2, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_-1/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 2, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 4, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, {"id": 3, "pos": "vtl"}, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_-1/5.json
{
    "id":5,
    "doors": {
        "left": null,
        "right": null,
        "up": null,
        "down": {"type": "kill_count", "complete": false, "num": 2, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 4, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_0/6.json
{
    "id":6,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [7, 0, 4, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 4, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 7,
        "y": 4
        },
        {"name": "goblin",
        "x": 7,
        "y": 5
        },
        {"name": "crate",
        "x":2,
        "y":3.5
        },
        {"name": "crate",
        "x":2,
        "y":4.5
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_0/7.json
{
    "id":7,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 1, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "item", "x": 400, "y": 400, "item": "key", "payload": {"colour": [255, 100, 100, 100]}}
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_0/10.json
{
    "id":10,
    "doors": {
        "left": {"type": "powered", "complete": false, "colour": [150, 150, 255, 100]},
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 1, 1, 1, 1, 1], 
        [7, 0, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, {"id": 5, "colour": [150, 150, 255, 100]}, 0, 0, 1], 
        [7, 0, 0, 0, 0, 1, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_0/player.json
{
    "lives": 3,
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



projects/final/data/account_games/1_games/0_levels/rooms_0/1.json
{
    "id": 1, 
    "doors": {
        "left": null, 
        "right": {"type": "kill_count", "complete": false, "num": 1, "colour": null}, 
        "up": null, 
        "down": null
        }, 
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, {"id": 3, "pos": "vtr"}, 0, 0, 1, 0, 0, 7], 
        [1, 0, 0, {"id": 3, "pos": "vbr"}, 0, 0, 1, 0, 0, 7], 
        [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ],
    
        "entities": [
            {"name": "goblin", "x": 8, "y": 4}
        ]
    }



projects/final/data/account_games/1_games/0_levels/rooms_0/11.json
{
    "id":11,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "kill_count", "complete": false, "num": 7, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 4,
        "y": 2
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_0/2.json
{
    "id":2,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "down": {"type": "keyhole", "complete": false, "colour": [255, 100, 100, 100]}
        
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 1
        },
        {"name": "goblin",
        "x": 8,
        "y": 8
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_0/layout.json
[   [0, 0, 0, 0, 0],
    [0, 4, 5, 6, 0],
    [1, 2, 0, 8, 11],
    [0, 3, 7, 9, 10],
    [0, 0, 0, 0, 0]
]



projects/final/data/account_games/1_games/0_levels/rooms_0/3.json
{
    "id":3,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 3, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, 10, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_0/8.json
{
    "id":8,
    "doors": {
        "left": null,
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, {"id":8, "pos": "vbl", "colour": [255, 100, 100, 100]}, {"id":8, "pos": "vbr", "colour": [255, 100, 100, 100]}, 1, 1, 1, 1], 
        [1, 0, {"id": 6, "colour": [255, 100, 100, 100], "flicked": false}, 0, 0, 0, 0, 2, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 1, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 1, 2, 2, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 1,
        "y": 1
        },
        {"name": "goblin",
        "x": 1.5,
        "y": 1
        },
        {"name": "goblin",
        "x": 2.3,
        "y": 1.5
        },
        {"name": "goblin",
        "x": 1,
        "y": 1.7
        },
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 1.4,
        "y": 2
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_0/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 4, "colour": null},
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 2, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 7],
        [1, 1, 1, 1, 1, 4, 1, 0, 0, 7],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, {"id": 3, "pos": "vtl"}, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_0/5.json
{
    "id":5,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [7, 0, 4, 0, 1, 0, 0, 0, 0, 7],
        [7, 0, 0, 0, 1, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_0/9.json
{
    "id":9,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 16, "colour": null},
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 1, {"id":8, "pos": "hbl", "colour": [150, 150, 255, 100]}, {"id":8, "pos": "hbr", "colour": [150, 150, 255, 100]}, 1, 0, 0, 1], 
        [1, 0, {"id": 6, "colour": [255, 100, 100, 100], "flicked": false}, 1, {"id":8, "pos": "hbl", "colour": [150, 255, 150, 100]}, {"id":8, "pos": "hbr", "colour": [150, 255, 150, 100]}, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, {"id": 6, "colour": [150, 150, 255, 100], "flicked": false}, 0, 0, 0, 0, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 6,
        "y": 3
        },
        {"name": "goblin",
        "x": 5,
        "y": 3
        },
        {"name": "goblin",
        "x": 4,
        "y": 3
        },
        {"name": "goblin",
        "x": 6,
        "y": 6
        },
        {"name": "goblin",
        "x": 5,
        "y": 6
        },
        {"name": "goblin",
        "x": 4,
        "y": 6
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_1/6.json
{
    "id":6,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "powered", "complete": false, "colour": [150, 255, 150, 100]}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 1, 1, 1, 1, 1, 1, 1], 
        [7, 0, 0, {"id":11, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 4, 0, 1], 
        [7, 0, 0, {"id":11, "pos": "vbl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 4, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 6
        },
        {"name": "goblin",
        "x": 6,
        "y": 0.5
        },
        {"name": "goblin",
        "x": 3,
        "y": 1
        },
        {"name": "goblin",
        "x": 5,
        "y": 1.5,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 150, 255, 100]},
                        "chance": 1
                        }]
                    }]
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_1/7.json
{
    "id":7,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 3, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 3, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [150, 150, 255, 100]}, 0, 0, 0, 1], 
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 1, 0, 1, 0, 0, 0, 1], 
        [1, 1, 0, 1, 0, 1, 0, 0, 0, 1], 
        [7, 0, 4, 1, 0, 1, 0, 0, 0, 7], 
        [7, 0, 0, 0, 0, 1, 0, 0, 0, 7], 
        [1, {"id":8, "pos": "htl", "colour": [255, 100, 100, 100]}, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 4, 0, 0, 0, 0, 0, {"id": 5, "colour": [150, 150, 255, 100]}, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 1, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 7,
        "y": 8,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 100, 100, 100]},
                        "chance": 1
                        }]
                    }]
        },
        {"name": "goblin",
        "x": 7,
        "y": 3
        },
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 6,
        "y": 2
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_1/10.json
{
    "id":10,
    "doors": {
        "left": {"type": "empty", "complete": false, "num": 1, "colour": null},
        "right": null,
        "up": {"type": "powered", "complete": false, "colour": [150, 255, 150, 100]},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, {"id": 5, "colour": [150, 255, 150, 100]}, 4, {"id":8, "pos": "vtr", "colour": [150, 150, 255, 100]}, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 4, {"id": 5, "colour": [255, 255, 150, 100]}, 1],
        [1, 0, 0, {"id":8, "pos": "vbr", "colour": [150, 150, 255, 100]}, 0, 0, {"id":8, "pos": "vbl", "colour": [255, 100, 100, 100]}, 0, 0, 1],
        [1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 4, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 255, 150, 100]}, 4, {"id": 5, "colour": [150, 150, 255, 100]}, 1],
        [1, 0, 0, 0, 0, 0, {"id":8, "pos": "vbl", "colour": [255, 255, 150, 100]}, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 7,
        "y": 2
        },
        {"name": "goblin",
        "x": 7,
        "y": 8
        },
        {"name": "item", 
        "x": 140, 
        "y": 160, 
        "item": "key", 
        "payload": {
            "colour": [150, 150, 255, 100]
            }
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_1/player.json
{
    "lives": 3,
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



projects/final/data/account_games/1_games/0_levels/rooms_1/1.json
{"id": 1, "doors": {"left": null, "right": {"type": "empty", "complete": false, "colour": null}, "up": null, "down": null}, "squares": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [1, 0, {"id": 8, "pos": "vtr", "open": false, "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 0, 1], [1, {"id": 5, "colour": [255, 100, 100, 100]}, 1, 1, {"id": 8, "pos": "hbl", "open": false, "colour": [150, 255, 150, 100]}, {"id": 8, "pos": "hbr", "open": false, "colour": [150, 255, 150, 100]}, 1, 1, 1, 1], [1, 0, 1, 0, 0, 0, 0, 0, {"id": 8, "pos": "vtr", "open": false, "colour": [150, 150, 255, 100]}, 7], [1, 0, 1, 0, 0, 0, 0, 0, {"id": 8, "pos": "vbr", "open": false, "colour": [150, 150, 255, 100]}, 7], [1, 0, 1, 1, {"id": 11, "pos": "htl", "open": false, "colour": [255, 255, 150, 100]}, {"id": 11, "pos": "htr", "open": false, "colour": [255, 255, 150, 100]}, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 1], [1, {"id": 5, "colour": [150, 150, 255, 100]}, 1, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], "entities": [{"name": "goblin", "x": 6.908563904327037, "y": 4.5994336070377475, "health": 5}, {"name": "crate", "x": 1.0, "y": 6.0}]}



projects/final/data/account_games/1_games/0_levels/rooms_1/11.json
{
    "id":11,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 2, 0, 1, 0, 0, 1, 0, 4, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [255, 255, 150, 100]}, {"id":11, "pos": "htr", "colour": [255, 255, 150, 100]}, 1, 0, 0, 1],
        [1, 4, 0, 1, {"id":11, "pos": "htl", "colour": [255, 100, 100, 100]}, {"id":11, "pos": "htr", "colour": [255, 100, 100, 100]}, 1, 0, 0, 1],
        [1, 4, 0, 1, {"id":11, "pos": "htl", "colour": [150, 150, 255, 100]}, {"id":11, "pos": "htr", "colour": [150, 150, 255, 100]}, 1, 0, 0, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [150, 255, 150, 100]}, {"id":11, "pos": "htr", "colour": [150, 255, 150, 100]}, 1, 0, 2, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [255, 150, 255, 100]}, {"id":11, "pos": "htr", "colour": [255, 150, 255, 100]}, 1, 0, 2, 1],
        [1, 0, 0, 1, 0, 10, 1, 0, 4, 1],
        [1, 0, 4, 1, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "crate",
        "x": 1,
        "y": 3.5
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_1/2.json
{
    "id":2,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "up": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "down": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null}
        
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 2, 1, 0, 0, 1, 0, 0, 1],
        [1, 0, 1, 1, 0, 0, 1, 1, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [1, 0, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, 0, 0, 1, 0, 0, 1, 2, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 4,
        "y": 4
        },
        {"name": "goblin",
        "x": 4,
        "y": 5
        },
        {"name": "goblin",
        "x": 5,
        "y": 4
        },
        {"name": "goblin",
        "x": 5,
        "y": 5
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_1/layout.json
[   [0, 0, 0, 0, 0],
    [0, 4, 5, 6, 0],
    [1, 2,10, 8, 0],
    [0, 3, 7, 9, 0],
    [0,11, 0, 0, 0]
]



projects/final/data/account_games/1_games/0_levels/rooms_1/3.json
{
    "id":3,
    "doors": {
        "left": null,
        "right": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]},
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "powered", "complete": false, "colour": [150, 150, 255, 100]}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, {"id":8, "pos": "htl", "colour": [255, 100, 100, 100]}, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 4, 0, 0, 0, 0, 7],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 4, 0, 0, 0, 0, 7],
        [1, {"id":8, "pos": "hbl", "colour": [255, 100, 100, 100]}, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, {"id": 6, "colour": [150, 150, 255, 100], "flicked": false}, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, {"id":8, "pos": "hbl", "colour": [150, 255, 150, 100]}, {"id":8, "pos": "hbr", "colour": [150, 255, 150, 100]}, 1, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 4
        },
        {"name": "goblin",
        "x": 2,
        "y": 5
        },
        {"name": "goblin",
        "x": 3,
        "y": 5
        },
        {"name": "crate",
        "x": 4,
        "y": 3.5
        },
        {"name": "crate",
        "x": 4,
        "y": 4.5
        },
        {"name": "goblin",
        "x": 8,
        "y": 2
        },
        {"name": "goblin",
        "x": 8,
        "y": 7
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_1/8.json
{
    "id":8,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 1, {"id":8, "pos": "hbl", "colour": [255, 100, 100, 100]}, {"id":8, "pos": "hbr", "colour": [255, 100, 100, 100]}, 1, 4, 0, 1], 
        [1, 1, 1, 1, {"id": 5, "colour": [255, 100, 100, 100]}, {"id": 5, "colour": [255, 100, 100, 100]}, 1, 0, 0, 1], 
        [1, 0, 0, 1, {"id": 5, "colour": [150, 150, 255, 100]}, {"id": 5, "colour": [150, 150, 255, 100]}, 1, 1, 1, 1], 
        [1, 0, 4, 1, {"id":8, "pos": "htl", "colour": [150, 150, 255, 100]}, {"id":8, "pos": "htr", "colour": [150, 150, 255, 100]}, 1, {"id": 5, "colour": [150, 150, 255, 100]}, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 2,
        "y": 7
        },
        {"name": "goblin",
        "x": 7,
        "y": 2
        },
        {"name": "goblin",
        "x": 7,
        "y": 7
        },
        {"name": "item", 
        "x": 340, 
        "y": 340, 
        "item": "key", 
        "payload": {
            "colour": [150, 150, 255, 100]
            }
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_1/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": {"type": "empty", "complete": false, "num": 4, "colour": null},
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 4, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 4, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 1, 2, 0, 1, 0, 0, 7], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 7], 
        [1, 4, 4, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 4, 0, 0, 1, 0, 4, 1], 
        [1, 0, 0, 4, 0, 0, 1, 0, 2, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "crate",
        "x": 3,
        "y": 6.5
        },
        {"name": "crate",
        "x": 3,
        "y": 7.5
        },
        {"name": "crate",
        "x": 3,
        "y": 0.5
        },
        {"name": "crate",
        "x": 3,
        "y": 1.5
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_1/5.json
{
    "id":5,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null},
        "up": null,
        "down": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1], 
        [1, 0, 4, 0, 1, 0, 0, 0, 0, 1], 
        [7, 0, 0, 1, 1, 2, 0, 0, 0, 7], 
        [7, 0, 0, 0, 2, 1, 1, 0, 0, 7], 
        [1, 0, 0, 0, 0, 1, 0, 4, 0, 1], 
        [1, 0, 0, 0, 0, 1, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 6
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 5,
        "y": 8
        },
        {"name": "goblin",
        "x": 4,
        "y": 5
        },
        {"name": "goblin",
        "x": 6,
        "y": 3,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 255, 150, 100]},
                        "chance": 1
                        }]
                    }]
        },
        {"name": "goblin",
        "x": 1,
        "y": 2
        },
        {"name": "goblin",
        "x": 3,
        "y": 5
        }
    ]
}



projects/final/data/account_games/1_games/0_levels/rooms_1/9.json
{
    "id":9,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 5, "colour": null},
        "right": null,
        "up": {"type": "local_kill_count", "complete": false, "num": 5, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 1, 0, 1, 1, 0, 1, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 1, 0, 1, 1, 0, 1, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 6
        },
        {"name": "goblin",
        "x": 5,
        "y": 1
        },
        {"name": "goblin",
        "x": 5,
        "y": 5
        },
        {"name": "goblin",
        "x": 2,
        "y": 4
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_-1/player.json
{
    "lives": 3,
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



projects/final/data/account_games/default_games/default_levels/rooms_-1/1.json
{
    "id": 1, 
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null}, 
        "right": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]}, 
        "up": {"type": "keyhole", "complete": false, "colour": [255, 100, 100, 100]}, 
        "down": {"type": "kill_count", "complete": false, "num": 1, "colour": null}
        }, 
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 2, 2, 0, 0, 0, 0, {"id":5,"colour":[255, 100, 100, 100]}, {"id":6,"colour":[255, 100, 100, 100]}, 1], 
        [1, 2, {"id": 3, "pos": "vbr"}, 0, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, {"id": 8, "pos": "htl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 4, 0, 0, 7], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 4, {"id": 12, "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, {"id": 11, "pos": "htl", "colour": [255, 100, 100, 100]}, 0, 2, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 10, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
        ],
    
        "entities": [
            {"name": "goblin", "x": 8, "y": 4},
            {"name": "item", "x": 400, "y": 400, "item": "key", "payload": {"colour": [255, 100, 100, 100]}}
        ]
    }



projects/final/data/account_games/default_games/default_levels/rooms_-1/2.json
{
    "id":2,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "up": null,
        "down": null
        
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 1
        },
        {"name": "goblin",
        "x": 8,
        "y": 8
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_-1/layout.json
[   [0, 0, 0, 0, 0],
    [0, 0, 5, 0, 0],
    [0, 2, 1, 3, 0],
    [0, 0, 4, 0, 0],
    [0, 0, 0, 0, 0]
]



projects/final/data/account_games/default_games/default_levels/rooms_-1/3.json
{
    "id":3,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "right": null,
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 2, 2, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_-1/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 2, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 4, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, {"id": 3, "pos": "vtl"}, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_-1/5.json
{
    "id":5,
    "doors": {
        "left": null,
        "right": null,
        "up": null,
        "down": {"type": "kill_count", "complete": false, "num": 2, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 4, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_0/6.json
{
    "id":6,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [7, 0, 4, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 4, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 7,
        "y": 4
        },
        {"name": "goblin",
        "x": 7,
        "y": 5
        },
        {"name": "crate",
        "x":2,
        "y":3.5
        },
        {"name": "crate",
        "x":2,
        "y":4.5
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_0/7.json
{
    "id":7,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 1, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "item", "x": 400, "y": 400, "item": "key", "payload": {"colour": [255, 100, 100, 100]}}
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_0/10.json
{
    "id":10,
    "doors": {
        "left": {"type": "powered", "complete": false, "colour": [150, 150, 255, 100]},
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 1, 1, 1, 1, 1], 
        [7, 0, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, {"id": 5, "colour": [150, 150, 255, 100]}, 0, 0, 1], 
        [7, 0, 0, 0, 0, 1, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_0/player.json
{
    "lives": 3,
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



projects/final/data/account_games/default_games/default_levels/rooms_0/1.json
{
    "id": 1, 
    "doors": {
        "left": null, 
        "right": {"type": "kill_count", "complete": false, "num": 1, "colour": null}, 
        "up": null, 
        "down": null
        }, 
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, {"id": 3, "pos": "vtr"}, 0, 0, 1, 0, 0, 7], 
        [1, 0, 0, {"id": 3, "pos": "vbr"}, 0, 0, 1, 0, 0, 7], 
        [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ],
    
        "entities": [
            {"name": "goblin", "x": 8, "y": 4}
        ]
    }



projects/final/data/account_games/default_games/default_levels/rooms_0/11.json
{
    "id":11,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "kill_count", "complete": false, "num": 7, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 4,
        "y": 2
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_0/2.json
{
    "id":2,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "down": {"type": "keyhole", "complete": false, "colour": [255, 100, 100, 100]}
        
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 1
        },
        {"name": "goblin",
        "x": 8,
        "y": 8
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_0/layout.json
[   [0, 0, 0, 0, 0],
    [0, 4, 5, 6, 0],
    [1, 2, 0, 8, 11],
    [0, 3, 7, 9, 10],
    [0, 0, 0, 0, 0]
]



projects/final/data/account_games/default_games/default_levels/rooms_0/3.json
{
    "id":3,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 3, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, 10, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_0/8.json
{
    "id":8,
    "doors": {
        "left": null,
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, {"id":8, "pos": "vbl", "colour": [255, 100, 100, 100]}, {"id":8, "pos": "vbr", "colour": [255, 100, 100, 100]}, 1, 1, 1, 1], 
        [1, 0, {"id": 6, "colour": [255, 100, 100, 100], "flicked": false}, 0, 0, 0, 0, 2, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 1, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 1, 2, 2, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 1,
        "y": 1
        },
        {"name": "goblin",
        "x": 1.5,
        "y": 1
        },
        {"name": "goblin",
        "x": 2.3,
        "y": 1.5
        },
        {"name": "goblin",
        "x": 1,
        "y": 1.7
        },
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 1.4,
        "y": 2
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_0/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 4, "colour": null},
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 2, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 7],
        [1, 1, 1, 1, 1, 4, 1, 0, 0, 7],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, {"id": 3, "pos": "vtl"}, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_0/5.json
{
    "id":5,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [7, 0, 4, 0, 1, 0, 0, 0, 0, 7],
        [7, 0, 0, 0, 1, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_0/9.json
{
    "id":9,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 16, "colour": null},
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 1, {"id":8, "pos": "hbl", "colour": [150, 150, 255, 100]}, {"id":8, "pos": "hbr", "colour": [150, 150, 255, 100]}, 1, 0, 0, 1], 
        [1, 0, {"id": 6, "colour": [255, 100, 100, 100], "flicked": false}, 1, {"id":8, "pos": "hbl", "colour": [150, 255, 150, 100]}, {"id":8, "pos": "hbr", "colour": [150, 255, 150, 100]}, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, {"id": 6, "colour": [150, 150, 255, 100], "flicked": false}, 0, 0, 0, 0, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 6,
        "y": 3
        },
        {"name": "goblin",
        "x": 5,
        "y": 3
        },
        {"name": "goblin",
        "x": 4,
        "y": 3
        },
        {"name": "goblin",
        "x": 6,
        "y": 6
        },
        {"name": "goblin",
        "x": 5,
        "y": 6
        },
        {"name": "goblin",
        "x": 4,
        "y": 6
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_1/6.json
{
    "id":6,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "powered", "complete": false, "colour": [150, 255, 150, 100]}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 1, 1, 1, 1, 1, 1, 1], 
        [7, 0, 0, {"id":11, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 4, 0, 1], 
        [7, 0, 0, {"id":11, "pos": "vbl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 4, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 6
        },
        {"name": "goblin",
        "x": 6,
        "y": 0.5
        },
        {"name": "goblin",
        "x": 3,
        "y": 1
        },
        {"name": "goblin",
        "x": 5,
        "y": 1.5,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 150, 255, 100]},
                        "chance": 1
                        }]
                    }]
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_1/7.json
{
    "id":7,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 3, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 3, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [150, 150, 255, 100]}, 0, 0, 0, 1], 
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 1, 0, 1, 0, 0, 0, 1], 
        [1, 1, 0, 1, 0, 1, 0, 0, 0, 1], 
        [7, 0, 4, 1, 0, 1, 0, 0, 0, 7], 
        [7, 0, 0, 0, 0, 1, 0, 0, 0, 7], 
        [1, {"id":8, "pos": "htl", "colour": [255, 100, 100, 100]}, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 4, 0, 0, 0, 0, 0, {"id": 5, "colour": [150, 150, 255, 100]}, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 1, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 7,
        "y": 8,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 100, 100, 100]},
                        "chance": 1
                        }]
                    }]
        },
        {"name": "goblin",
        "x": 7,
        "y": 3
        },
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 6,
        "y": 2
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_1/10.json
{
    "id":10,
    "doors": {
        "left": {"type": "empty", "complete": false, "num": 1, "colour": null},
        "right": null,
        "up": {"type": "powered", "complete": false, "colour": [150, 255, 150, 100]},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, {"id": 5, "colour": [150, 255, 150, 100]}, 4, {"id":8, "pos": "vtr", "colour": [150, 150, 255, 100]}, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 4, {"id": 5, "colour": [255, 255, 150, 100]}, 1],
        [1, 0, 0, {"id":8, "pos": "vbr", "colour": [150, 150, 255, 100]}, 0, 0, {"id":8, "pos": "vbl", "colour": [255, 100, 100, 100]}, 0, 0, 1],
        [1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 4, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 255, 150, 100]}, 4, {"id": 5, "colour": [150, 150, 255, 100]}, 1],
        [1, 0, 0, 0, 0, 0, {"id":8, "pos": "vbl", "colour": [255, 255, 150, 100]}, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 7,
        "y": 2
        },
        {"name": "goblin",
        "x": 7,
        "y": 8
        },
        {"name": "item", 
        "x": 140, 
        "y": 160, 
        "item": "key", 
        "payload": {
            "colour": [150, 150, 255, 100]
            }
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_1/player.json
{
    "lives": 3,
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



projects/final/data/account_games/default_games/default_levels/rooms_1/1.json
{
    "id": 1, 
    "doors": {
        "left": null, 
        "right": {"type": "empty", "complete": false, "colour": null}, 
        "up": null, 
        "down": null
        }, 
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 1, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, {"id":8, "pos": "vtr", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 0, 1], 
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 1, 1, {"id":8, "pos": "hbl", "colour": [150, 255, 150, 100]}, {"id":8, "pos": "hbr", "colour": [150, 255, 150, 100]}, 1, 1, 1, 1], 
        [1, 0, 1, 0, 0, 0, 0, 0, {"id":8, "pos": "vtr", "colour": [150, 150, 255, 100]}, 7], 
        [1, 0, 1, 0, 0, 0, 0, 0, {"id":8, "pos": "vbr", "colour": [150, 150, 255, 100]}, 7], 
        [1, 4, 1, 1, {"id":11, "pos": "htl", "colour": [255, 255, 150, 100]}, {"id":11, "pos": "htr", "colour": [255, 255, 150, 100]}, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 1], 
        [1, {"id": 5, "colour": [150, 150, 255, 100]}, 1, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ], 
    
    "entities": [
        {"name": "goblin",
        "x": 7.5,
        "y": 4.5,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 255, 150, 100]},
                        "chance": 1
                        }]
                    }]
            }
        ]
    }



projects/final/data/account_games/default_games/default_levels/rooms_1/11.json
{
    "id":11,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 2, 0, 1, 0, 0, 1, 0, 4, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [255, 255, 150, 100]}, {"id":11, "pos": "htr", "colour": [255, 255, 150, 100]}, 1, 0, 0, 1],
        [1, 4, 0, 1, {"id":11, "pos": "htl", "colour": [255, 100, 100, 100]}, {"id":11, "pos": "htr", "colour": [255, 100, 100, 100]}, 1, 0, 0, 1],
        [1, 4, 0, 1, {"id":11, "pos": "htl", "colour": [150, 150, 255, 100]}, {"id":11, "pos": "htr", "colour": [150, 150, 255, 100]}, 1, 0, 0, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [150, 255, 150, 100]}, {"id":11, "pos": "htr", "colour": [150, 255, 150, 100]}, 1, 0, 2, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [255, 150, 255, 100]}, {"id":11, "pos": "htr", "colour": [255, 150, 255, 100]}, 1, 0, 2, 1],
        [1, 0, 0, 1, 0, 10, 1, 0, 4, 1],
        [1, 0, 4, 1, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "crate",
        "x": 1,
        "y": 3.5
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_1/2.json
{
    "id":2,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "up": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "down": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null}
        
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 2, 1, 0, 0, 1, 0, 0, 1],
        [1, 0, 1, 1, 0, 0, 1, 1, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [1, 0, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, 0, 0, 1, 0, 0, 1, 2, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 4,
        "y": 4
        },
        {"name": "goblin",
        "x": 4,
        "y": 5
        },
        {"name": "goblin",
        "x": 5,
        "y": 4
        },
        {"name": "goblin",
        "x": 5,
        "y": 5
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_1/layout.json
[   [0, 0, 0, 0, 0],
    [0, 4, 5, 6, 0],
    [1, 2,10, 8, 0],
    [0, 3, 7, 9, 0],
    [0,11, 0, 0, 0]
]



projects/final/data/account_games/default_games/default_levels/rooms_1/3.json
{
    "id":3,
    "doors": {
        "left": null,
        "right": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]},
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "powered", "complete": false, "colour": [150, 150, 255, 100]}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, {"id":8, "pos": "htl", "colour": [255, 100, 100, 100]}, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 4, 0, 0, 0, 0, 7],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 4, 0, 0, 0, 0, 7],
        [1, {"id":8, "pos": "hbl", "colour": [255, 100, 100, 100]}, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, {"id": 6, "colour": [150, 150, 255, 100], "flicked": false}, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, {"id":8, "pos": "hbl", "colour": [150, 255, 150, 100]}, {"id":8, "pos": "hbr", "colour": [150, 255, 150, 100]}, 1, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 4
        },
        {"name": "goblin",
        "x": 2,
        "y": 5
        },
        {"name": "goblin",
        "x": 3,
        "y": 5
        },
        {"name": "crate",
        "x": 4,
        "y": 3.5
        },
        {"name": "crate",
        "x": 4,
        "y": 4.5
        },
        {"name": "goblin",
        "x": 8,
        "y": 2
        },
        {"name": "goblin",
        "x": 8,
        "y": 7
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_1/8.json
{
    "id":8,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 1, {"id":8, "pos": "hbl", "colour": [255, 100, 100, 100]}, {"id":8, "pos": "hbr", "colour": [255, 100, 100, 100]}, 1, 4, 0, 1], 
        [1, 1, 1, 1, {"id": 5, "colour": [255, 100, 100, 100]}, {"id": 5, "colour": [255, 100, 100, 100]}, 1, 0, 0, 1], 
        [1, 0, 0, 1, {"id": 5, "colour": [150, 150, 255, 100]}, {"id": 5, "colour": [150, 150, 255, 100]}, 1, 1, 1, 1], 
        [1, 0, 4, 1, {"id":8, "pos": "htl", "colour": [150, 150, 255, 100]}, {"id":8, "pos": "htr", "colour": [150, 150, 255, 100]}, 1, {"id": 5, "colour": [150, 150, 255, 100]}, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 2,
        "y": 7
        },
        {"name": "goblin",
        "x": 7,
        "y": 2
        },
        {"name": "goblin",
        "x": 7,
        "y": 7
        },
        {"name": "item", 
        "x": 340, 
        "y": 340, 
        "item": "key", 
        "payload": {
            "colour": [150, 150, 255, 100]
            }
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_1/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": {"type": "empty", "complete": false, "num": 4, "colour": null},
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 4, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 4, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 1, 2, 0, 1, 0, 0, 7], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 7], 
        [1, 4, 4, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 4, 0, 0, 1, 0, 4, 1], 
        [1, 0, 0, 4, 0, 0, 1, 0, 2, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "crate",
        "x": 3,
        "y": 6.5
        },
        {"name": "crate",
        "x": 3,
        "y": 7.5
        },
        {"name": "crate",
        "x": 3,
        "y": 0.5
        },
        {"name": "crate",
        "x": 3,
        "y": 1.5
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_1/5.json
{
    "id":5,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null},
        "up": null,
        "down": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1], 
        [1, 0, 4, 0, 1, 0, 0, 0, 0, 1], 
        [7, 0, 0, 1, 1, 2, 0, 0, 0, 7], 
        [7, 0, 0, 0, 2, 1, 1, 0, 0, 7], 
        [1, 0, 0, 0, 0, 1, 0, 4, 0, 1], 
        [1, 0, 0, 0, 0, 1, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 6
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 5,
        "y": 8
        },
        {"name": "goblin",
        "x": 4,
        "y": 5
        },
        {"name": "goblin",
        "x": 6,
        "y": 3,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 255, 150, 100]},
                        "chance": 1
                        }]
                    }]
        },
        {"name": "goblin",
        "x": 1,
        "y": 2
        },
        {"name": "goblin",
        "x": 3,
        "y": 5
        }
    ]
}



projects/final/data/account_games/default_games/default_levels/rooms_1/9.json
{
    "id":9,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 5, "colour": null},
        "right": null,
        "up": {"type": "local_kill_count", "complete": false, "num": 5, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 1, 0, 1, 1, 0, 1, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 1, 0, 1, 1, 0, 1, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 6
        },
        {"name": "goblin",
        "x": 5,
        "y": 1
        },
        {"name": "goblin",
        "x": 5,
        "y": 5
        },
        {"name": "goblin",
        "x": 2,
        "y": 4
        }
    ]
}



projects/final/data/squares/default_square.json
{
    "name": "None",
    "basic": true,
    "collidable": true,
    "animated": false,
    "break_animation": false,
    "textures": ["air"],
    "breakable": true,
    "strength": 20,
    "has_drops": false,
    "collision_size": [1,1],
    "relative_top_left": [0,0],
    "transparent": false,
    "size": [1,1],
    "texture_pos": [0,0]
}



projects/final/data/squares/squares_data.json
[
    {
        "id": 0,
        "name": "air",
        "basic": true,
        "collidable": false,
        "textures": ["air"],
        "transparent": true
    },

    {
        "id": 1,
        "name": "rock",
        "basic": true,
        "breakable": false,
        "textures": ["rock"],
        "size": [1, 1.5],
        "texture_pos": [0, -0.5]
    },

        {"id": 2,
        "name": "vase",
        "basic": true,
        "collidable": true,
        "collision_size": [0.4, 0.4],
        "break_animation": true,
        "textures": ["vase"],
        "strength": 2,
        "transparent": true,
        "has_drops": true,

        "drops": [{"rolls": 1,
                    "total": 5,
                    "drops": [{
                        "item": "stick",
                        "chance": 1
                        },
                    {
                        "item": "long_sword",
                        "chance": 1
                        },
                    {
                        "item": "metal_axe",
                        "chance": 1
                        },
                    {
                        "item": "dagger",
                        "chance": 1
                        },
                    {
                        "item": "mace",
                        "chance": 1
                        }]
                    },
                    {"rolls": 1,
                    "total": 9,
                    "drops": [{
                        "item": "wood_head",
                        "chance": 1
                        },
                    {
                        "item": "wood_chest",
                        "chance": 1
                        },
                    {
                        "item": "wood_feet",
                        "chance": 1
                        },
                    {
                        "item": "chain_head",
                        "chance": 1
                        },
                    {
                        "item": "chain_chest",
                        "chance": 1
                        },
                    {
                        "item": "chain_feet",
                        "chance": 1
                        },
                    {
                        "item": "metal_head",
                        "chance": 1
                        },
                    {
                        "item": "metal_chest",
                        "chance": 1
                        },
                    {
                        "item": "metal_feet",
                        "chance": 1
                        }
                    ]
                    }
                ]
    },

    {
        "id": 3,
        "name": "door",
        "basic": false
    },

    {
        "id": 4,
        "name": "crate",
        "basic": false
    },

    {
        "id": 5,
        "name": "button",
        "basic": false
    },

    {
        "id": 6,
        "name": "lever",
        "basic": false
    },

    {
        "id": 7,
        "name": "non_navigable_air",
        "basic": true,
        "collidable": true,
        "collision_size": [0,0],
        "textures": ["air"]
    },

    {
        "id": 8,
        "name": "mechanical_door",
        "basic": false
    },

    {
        "id": 9,
        "name": "objective_door",
        "basic": false
    },

    {
        "id": 10,
        "name": "ladder",
        "basic": false
    },

    {
        "id": 11,
        "name": "keyhole_door",
        "basic": false
    },

    {
        "id": 12,
        "name": "keyhole_wall",
        "basic": false
    }

]



projects/final/data/entities/enemies/goblin.json
{
    "health": 5,
    "walk_speed": 2,
    "run_speed": 4,
    "max_player_memory_range": [20, 100],
    "size": [150,150],
    "collision_box_size": [30, 20],
    "team": "enemy",
    "mele_reach": 90,
    "attack_damage": 4,
    "attack_cooldown": 30
}



Total files: 118
