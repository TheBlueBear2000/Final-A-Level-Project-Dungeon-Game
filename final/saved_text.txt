CODE:



File: projects/final//path_generator.py
import os

def create_ascii_tree(directory, prefix='', is_last=True):
    """
    Recursively creates an ASCII tree representation of a directory.

    Args:
        directory (str): The path to the directory.
        prefix (str): Prefix string to prepend to each line.
        is_last (bool): Whether the current item is the last in the directory.
    """
    if os.path.isdir(directory):
        items = os.listdir(directory)
        items = [item for item in items if not item.startswith('.')]  # Exclude files starting with '.'
        items.sort()
        for i, item in enumerate(items):
            path = os.path.join(directory, item)
            is_item_last = i == len(items) - 1
            connector = '└── ' if is_item_last else '├── '
            print(prefix + connector + item)
            if os.path.isdir(path):
                new_prefix = prefix + ('    ' if is_last else '│   ')
                create_ascii_tree(path, new_prefix + '    ', is_item_last)
            else:
                print(new_prefix + ('│   ' if not is_item_last else '    '), end='') # print the correct prefix
    else:
        print(prefix + '└── ' + os.path.basename(directory))

def main():
    directory = input("Enter the directory path: ").strip()
    if os.path.isdir(directory):
        print("Directory structure:")
        print(directory)
        print("└── " + os.path.basename(directory))
        create_ascii_tree(directory, '', True)
    else:
        print("The provided path is not a directory.")

if __name__ == "__main__":
    main()
    
    
    
    




File: projects/final//game_main.py
def rungame(account_id, savegame_id, room, config, screen, player, player_loc, level, newlevel, last_room_screenshot):
    # Libraries
    import pygame
    import time
    from random import randint

    # Local modules
    import classes.menu as menu_classes
    
    from classes.player import Player
    from classes.room import Room

    # Constants
    from classes.global_data import constants_structure, draw_text
    constants = constants_structure()
    
    # define game and GUI subwindows
    game_window = pygame.Surface((constants.GAME_WINDOW_SIZE), pygame.SRCALPHA)
    gui_window = pygame.Surface((constants.GUI_WINDOW_SIZE), pygame.SRCALPHA)
    
    # draw minimap image
    map_room_size = [20,20]
    map_joint_length = 10
    map_joint_width = 7
    level_layout = json.load(open(constants.FILE_PATH + f"data/account_games/{account_id}_games/{savegame_id}_levels/rooms_{level}/layout.json", 'r'))
    minimap = pygame.Surface(((len(level_layout[0]) * (map_room_size[0] + map_joint_length)) - map_joint_length,   (len(level_layout) * (map_room_size[1] + map_joint_length)) - map_joint_length), pygame.SRCALPHA)
    # draw squares
    for y, row in enumerate(level_layout):
        for x, item in enumerate(row):
            if item != 0:
                # squares
                pygame.draw.rect(minimap, (0,0,0), (x * (map_room_size[0] + map_joint_length), y * (map_room_size[1] + map_joint_length), *map_room_size))
                if room["id"] == item:
                    pygame.draw.circle(minimap, (255,255,255), ((x * (map_room_size[0] + map_joint_length)) + (map_room_size[0]//2), (y * (map_room_size[1] + map_joint_length))+ (map_room_size[1]//2)), map_room_size[0]//3)
                
                # lines
                doors = json.load(open(constants.FILE_PATH + f"data/account_games/{account_id}_games/{savegame_id}_levels/rooms_{level}/{item}.json", 'r'))["doors"]
                if doors["right"] is not None:
                    colour = (100,100,100)
                    if doors["right"]["complete"]:
                        colour = (0,0,0)
                    pygame.draw.rect(minimap, colour, ((x * (map_room_size[0] + map_joint_length)) + map_room_size[0], (y * (map_room_size[1] + map_joint_length)) + ((map_room_size[1]-map_joint_width)//2), map_joint_length, map_joint_width))
                if doors["down"] is not None:
                    colour = (100,100,100)
                    if doors["down"]["complete"]:
                        colour = (0,0,0)
                    pygame.draw.rect(minimap, colour, ((x * (map_room_size[0] + map_joint_length)) + ((map_room_size[0]-map_joint_width)//2), (y * (map_room_size[1] + map_joint_length)) + map_room_size[0], map_joint_width, map_joint_length))
    
    # get background
    background = pygame.Surface(constants.GAME_WINDOW_SIZE)
    image = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/underground_background.png").convert()
    background.blit(pygame.transform.scale(image, (image.get_width() * 2.5, image.get_height() * 2.5)), (0,0))
    

    # Load room
    room = Room(room, level, {"account_id": account_id, "savegame_id": savegame_id})
    
    # Load player starting position
    player_coord = [player.x_pos, player.y_pos]
    if player_loc == "right":
        player_coord[0] = room.location[0] + (constants.SQUARE_SIZE[0] * 1.4) - 75
    elif player_loc == "left":
        player_coord[0] = room.location[0] + room.size[0] - (constants.SQUARE_SIZE[0] * 1.4) - 75
    elif player_loc == "bottom":
        player_coord[1] = room.location[1] + (constants.SQUARE_SIZE[1] * 1.4) - 75
    elif player_loc == "top":
        player_coord[1] = room.location[1] + room.size[1] - (constants.SQUARE_SIZE[1] * 1.4) - 75
    player.teleport(*player_coord)
    
    # Run transition animation to new room
    if not newlevel:
        game_window = room.draw(game_window, constants.SQUARE_SIZE, config)
        rendering_order = sorted(room.get_rendering_list(), key=lambda item : item.get_rendering_row() )
        for item in rendering_order:
            game_window = item.draw(game_window)
            
        gui_window = player.draw_overlay_data(gui_window, room.location, (len(room.layout[0]) * constants.SQUARE_SIZE[0], len(room.layout[1]) * constants.SQUARE_SIZE[1]))  
        gui_window.blit(minimap, ((constants.GUI_WINDOW_SIZE[0] - minimap.get_width())//2, constants.GUI_WINDOW_SIZE[1] * 0.8))
        game_window = room.draw_over(game_window, constants.SQUARE_SIZE)
        from functions.loops.transition_animation import animation
        animation(screen, player_loc, game_window, last_room_screenshot, gui_window, background, player)
    
    player.reassess_keys(config["key_bindings"])
    

    processTime = 1
    
    frame = 0
    
    loop = True
    # Main game
    while loop:
        tick_start = time.time()

        # CHECK EVENTS
        events = pygame.event.get()
        for event in events:
            if event.type == pygame.QUIT:
                # Always save before program quits
                player.save(level, room.id)
                room.save()
                print("Closing program, goodbye!")
                quit()
            
        # PROCESS
        # Move player
        dead, room.living_items, continue_game = player.move(config["key_bindings"], 
                    events, 
                    {"layout": room.layout, "location": room.location},
                    room.entities, 
                    room.living_items,
                    room.crates,
                    room.levers,
                    [*room.doors, *room.objective_doors],
                    room,
                    screen)
        
        if not continue_game: # If the game needs to be quit, save progress and exit
            player.save(level, room.id)
            room.save()
            return False, "quit", game_window
            
        if dead: # If the player has died, handle as such
            player.lives -= 1
            if player.lives < 0:
                return True, "final_death", game_window # Restart whole level on final death
            
            # If theres still lives left, respawn at start
            player.health = player.max_health
            player.x_pos = constants.GAME_WINDOW_SIZE[0]//2 - 75
            player.y_pos = constants.GAME_WINDOW_SIZE[1]//2 - 75
            room.save()
            player.save(level, 1)
            return True, None, game_window
        
        # Check if player is at gateway to neighboring room
        if player.collision_box["location"][0] <= room.location[0] + (constants.SQUARE_SIZE[0] * 0.6): # If leaving left
            room.save()
            player.save(level, room.id)
            return False, "left", game_window
        elif player.collision_box["location"][1] <= room.location[1] + (constants.SQUARE_SIZE[1] * 0.6): # If leaving top
            room.save()
            player.save(level, room.id)
            return False, "top", game_window
        elif player.collision_box["location"][0] >= room.location[0] + (len(room.layout[0]) * constants.SQUARE_SIZE[0]) - (constants.SQUARE_SIZE[0] * 0.6): # If leaving right
            room.save()
            player.save(level, room.id)
            return False, "right", game_window
        elif player.collision_box["location"][1] >= room.location[1] + (len(room.layout[1]) * constants.SQUARE_SIZE[1]) - (constants.SQUARE_SIZE[1] * 0.6): # If leaving bottom
            room.save()
            player.save(level, room.id)
            return False, "bottom", game_window
        
        # Update room
        room.update(player)
        
        # Update entities
        for entity in room.entities:
            dead = entity.think(player, room.entities, room.crates, [*room.doors, *room.objective_doors], room, constants) # DEFINE ENTITIES AS ARRAY OF ALL ENTITIES BUT NOT PLAYER
            if dead:
                room.entities.remove(entity)
        
        for item in room.living_items:
            item.move(room.layout, room.location, constants)
            
        # Update squares
        for button in room.buttons:
            button.update(player.collision_box, room.crates, room.entities)   
            
        if room.ladder is not None:
            if (room.ladder.player_proximity([player.collision_box["location"][i] + 
                                            (player.collision_box["size"][i]//2) for i in range(2)]) 
                <= constants.SQUARE_SIZE[0] // 3):
                print(f"level {level} complete")
                room.save()
                player.save(level, room.id)
                return False, "level_complete", game_window # Move to next level if player has completed it
        
        # RENDER
        game_window.blit(background, (0,0))
        
        # Draw room
        game_window = room.draw(game_window, constants.SQUARE_SIZE, config)
        
        # Calculate rendering order
        rendering_order = []
        rendering_order = room.get_rendering_list()
        rendering_order.append(player)
        rendering_order.sort( key=lambda item : item.get_rendering_row() )
        
        # Draw rendering order
        for item in rendering_order:
            game_window = item.draw(game_window)
        
        # Draw room overlays
        game_window = room.draw_over(game_window, constants.SQUARE_SIZE)
        game_window = room.draw_icons(game_window, player)
        
        # Draw GUI window
        gui_window = player.draw_overlay_data(gui_window, room.location, (len(room.layout[0]) * constants.SQUARE_SIZE[0], len(room.layout[1]) * constants.SQUARE_SIZE[1]))  
        gui_window.blit(minimap, ((constants.GUI_WINDOW_SIZE[0] - minimap.get_width())//2, constants.GUI_WINDOW_SIZE[1] * 0.8)) #(room.location[0] + room.size[0] + 100, 450))
        
        
        # Draw seperate subwindows to main display
        screen.blit(game_window,(0,0))
        screen.blit(gui_window,(constants.GAME_WINDOW_SIZE[0], 0) if constants.LANDSCAPE else (0, constants.GAME_WINDOW_SIZE[1]))
        
        # Draw new level overlay for new levels
        if frame < 25 and newlevel:
            frame += 1
            temp_surface = pygame.Surface((constants.DEFAULT_SCREEN_SIZE), pygame.SRCALPHA)
            pygame.draw.rect(temp_surface, [50,50,50, 255 - (frame*10)], (0,0, *constants.DEFAULT_SCREEN_SIZE))
            draw_text(f"Level {level}", temp_surface, constants.TITLE_FONT, (constants.DEFAULT_SCREEN_SIZE[0]//2, constants.DEFAULT_SCREEN_SIZE[1]//2), (255,255,255, 255 - (frame*10)), "centre", "centre")
            screen.blit(temp_surface, (0,0))
            
        # Draw FPS
        thefps = int((1 / processTime)*100)/100
        draw_text(f"FPS: {thefps}", screen, constants.SMALL_FONT, (10,10), (255,255,255), "left", "below")
        
        pygame.display.flip()
        
        # Wait for remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))
        processTime = time.time()-tick_start


import json
import pygame
def main_game(account_id, savegame_id, screen): # Runs level system and room system
    print(f"running account {account_id} game {savegame_id}")
    
    from classes.global_data import constants_structure
    constants = constants_structure()
    
    # Extract account data
    with open(constants.FILE_PATH + "data/accounts.json", 'r') as data_file:
            thedata = json.load(data_file)
            config = thedata[account_id - 1]["config"]
    
    level = 1 # Start game at level 1
    
    
    playing = True
    while playing: # In game loop, switches between levels
        from classes.player import Player
        player = Player(level, account_id, savegame_id)
        
        # Load room
        room = json.load(open(constants.FILE_PATH + f"data/account_games/{account_id}_games/{savegame_id}_levels/rooms_{level}/{player.current_room}.json", 'r'))
        
        # Find the current room coordinates
        level_layout = json.load(open(constants.FILE_PATH + f"data/account_games/{account_id}_games/{savegame_id}_levels/rooms_{level}/layout.json", 'r'))
        for y, row in enumerate(level_layout):
            for x, item in enumerate(row):
                if item == player.current_room:
                    room_coord = [x, y]
                    break
        
        direction = "centre"
        
        dead = False
        newlevel = True
        last_room_screenshot = None
        while not dead: # In level loop, switches between rooms
            # Run actual game
            dead, direction, last_room_screenshot = rungame(account_id, savegame_id, room, config, screen, player, direction, level, newlevel, last_room_screenshot)
            newlevel = False
            if dead: 
                if direction == "final_death": # On final death, reset level data and then continue to restart level, since data is new
                    # Remove old files
                    from shutil import rmtree
                    rmtree(constants.FILE_PATH + f"data/account_games/{account_id}_games/{savegame_id}_levels")
                    
                    # Create new files from template
                    from functions.algorithms.new_savegame import create_new_game_files
                    create_new_game_files(account_id, savegame_id)
                    
                break # Restart level if dead
            
            # Switch rooms
            if direction == "left":
                room_coord[0] -= 1
            elif direction == "top":
                room_coord[1] -= 1
            elif direction == "right":
                room_coord[0] += 1
            elif direction == "bottom":
                room_coord[1] += 1
                
            # Quit game
            elif direction == "quit": 
                playing = False
                break
            
            # Next level
            else:
                level += 1
                break
            
            # Get data for next room
            room_number = level_layout[room_coord[1]][room_coord[0]]
            room = json.load(open(constants.FILE_PATH + f"data/account_games/{account_id}_games/{savegame_id}_levels/rooms_{level}/{room_number}.json", 'r'))




File: projects/final//compile_to_text.py

import os

file_string = "CODE:"

file_order_string = ""



file_count = 0

directory = 'projects/final/'
for dirpath, dirnames, filenames in os.walk(directory):
    for filename in filenames:
        if filename.endswith('.py')  or  filename.endswith('.json'):
            with open(os.path.join(dirpath, filename)) as f:
                file_string += "\n\n\n\nFile: " + dirpath + '/' + filename + "\n"
                file_string += f.read()
                file_count += 1
                #print(f.read())

file_string += f"\n\n\n\nTotal files: {file_count}\n"

#print(file_string)

with open("projects/final/saved_text.txt", 'w') as f:
    f.write(file_string)




# directories
# rptree.py

#"""This module provides RP Tree main module."""

import os
import pathlib

PIPE = "│"
ELBOW = "└──"
TEE = "├──"
PIPE_PREFIX = "│   "
SPACE_PREFIX = "    "






File: projects/final//main.py
# FIRST WINDOW AND MAIN GAME FILE

# Libraries
import pygame
import time

# Open window
pygame.init()
screen = pygame.display.set_mode((1000, 720))
pygame.display.set_caption('Dungeon Game')

# Local modules
import classes.menu as menu_classes
from functions.loops.create_account_loop import run as create_account
from functions.loops.log_in_loop import run as log_in
# Constants
from classes.global_data import constants_structure
constants = constants_structure()

# Buttons
menu_buttons = [
    menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5), 
                        size=(600, 200), 
                        text="Log-In", 
                        response_function=log_in,
                        font=constants.TITLE_FONT),
    menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*4), 
                        size=(600, 200), 
                        text="Create Account", 
                        response_function=create_account,
                        font=constants.TITLE_FONT)
]

loop = True
while loop:
    tick_start = time.time()
    
    # FRAME CONSTANTS ONE
    mouse_pos = pygame.mouse.get_pos()
    
    # CHECK EVENTS
    for event in pygame.event.get():
        if event.type == pygame.QUIT: # Quit program
            print("Closing program, goodbye!")
            quit()
            
        if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
            for button in menu_buttons:
                if button.under_pointer:
                    button.response_function(screen) # Run button functions if pressed
                else:
                    button.selected = False
    
    # PROCESS
    for button in menu_buttons:
        button.update(mouse_pos)
    
    # RENDER
    screen.fill("gray")
    
    # Draw buttons
    for button in menu_buttons:
        screen = button.draw(screen)
    
    pygame.display.flip()

    # Wait for remainder of tick
    time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))




File: projects/final/classes/global_data.py
import pygame

class constants_structure:
    def __init__(self):
        # Set all constants so that the program can access them anywhere.
        # If this was a language like java, this would be a static object, but static objects do not appear to exist in python
        
        self.MENU_FPS = 15
        self.FILE_PATH = "projects/final/"
        self.INV_ITEM_SIZE = [80,80]
        self.LIVES_SIZE = [50, 50]
        
        self.DEFAULT_SCREEN_SIZE = pygame.display.get_window_size()
        
        # Calculate GUI and game windows from screen size
        self.GAME_WINDOW_SIZE = [min(*self.DEFAULT_SCREEN_SIZE) for i in range(2)]
        self.LANDSCAPE = self.DEFAULT_SCREEN_SIZE[0] > self.DEFAULT_SCREEN_SIZE[1]
        if self.LANDSCAPE:
            self.GUI_WINDOW_SIZE = [self.DEFAULT_SCREEN_SIZE[0] - self.GAME_WINDOW_SIZE[0], self.DEFAULT_SCREEN_SIZE[1]]
        else:
            self.GUI_WINDOW_SIZE = [self.DEFAULT_SCREEN_SIZE[0], self.DEFAULT_SCREEN_SIZE[1] - self.GAME_WINDOW_SIZE[1]]
            
        self.SQUARE_SIZE = [(min(*self.DEFAULT_SCREEN_SIZE) // 12) for i in range(2)]
            
        # Fonts
        pygame.font.init()
        self.TITLE_FONT = pygame.font.Font(self.FILE_PATH + "project_lib/fonts/title.ttf", 80)
        self.NORMAL_FONT = pygame.font.Font(self.FILE_PATH + "project_lib/fonts/normal.ttf", 40)
        self.SMALL_FONT = pygame.font.Font(self.FILE_PATH + "project_lib/fonts/normal.ttf", 15)
        

def draw_text(text, surface, font, location, colour, h_alignment, v_alignment):
    rendered_text = font.render(text, True, colour)
    
    # find true location from alignment
    if h_alignment == "centre":
        location = (location[0] - (rendered_text.get_width()//2) ,  location[1])
    # alignment "left" changes nothing
    elif h_alignment == "right":
        location = (location[0] - rendered_text.get_width() ,  location[1])
        
    # vertical alignment
    if v_alignment == "centre":
        location = (location[0] ,  location[1] - (rendered_text.get_height()//2))
    # alignment "below" changes nothing
    elif v_alignment == "above":
        location = (location[0] ,  location[1] - rendered_text.get_height())

    # opacity
    if len(colour) > 3:
        rendered_text.set_alpha(colour[3])
        
    surface.blit(rendered_text, location)
    return surface




File: projects/final/classes/objective_icon.py
import pygame

class ObjectiveIndicator:
    def __init__(self, side, objective):
        # Set attributes
        self.side = side
        self.objective = objective
        
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        
        self.texture = temp_surface = pygame.Surface([1,1], pygame.SRCALPHA)
        self.description = []
        
        # Set texture and description attributes depending on objective type
        if objective["type"] == "kill_count":
            self.texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/icons/skull_and_crossbones.png").convert(), constants.SQUARE_SIZE)
            # Descriptions are arrays of lines so that when rendered it is an appropriate size
            self.description = [f"Kill a total of {objective['num']}", "enemies to open this door"]
        elif objective["type"] == "local_kill_count":
            self.texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/icons/skull.png").convert(), constants.SQUARE_SIZE)
            self.description = [f"Kill {objective['num']} enemies in this", "room to open this door"]
        elif objective["type"] == "keyhole":
            self.texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/icons/key.png").convert(), constants.SQUARE_SIZE)
            self.description = [f"Open this door with a key", "of the matching colour"]
        elif objective["type"] == "powered":
            self.texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/icons/bolt.png").convert(), constants.SQUARE_SIZE)
            self.description = [f"Trigger an input", "of the matching colour"]
        # PLACE TO ADD DETAILS FOR MORE OBJECTIVE TYPES
        
        # Shade texture if necessary
        if objective["colour"] is not None:
            temp_surface = pygame.Surface((self.texture.get_width(), self.texture.get_height()), pygame.SRCALPHA)
            temp_surface.blit(self.texture, (0,0))
            temp_surface.fill(objective["colour"], special_flags=pygame.BLEND_MULT)
            self.texture = temp_surface
        
        # Set icon position
        self.centre = [0,0]
        
        if self.side == "left":
            self.centre[0] = constants.SQUARE_SIZE[0] // 2
            self.centre[1] = constants.GAME_WINDOW_SIZE[1] // 2
        elif self.side == "right":
            self.centre[0] = constants.GAME_WINDOW_SIZE[0] - (constants.SQUARE_SIZE[0] // 2)
            self.centre[1] = constants.GAME_WINDOW_SIZE[1] // 2
        elif self.side == "up":
            self.centre[0] = constants.GAME_WINDOW_SIZE[0] // 2
            self.centre[1] = constants.SQUARE_SIZE[1] // 2 + (constants.SQUARE_SIZE[1] // 2)
        elif self.side == "down":
            self.centre[0] = constants.GAME_WINDOW_SIZE[0] // 2
            self.centre[1] = constants.GAME_WINDOW_SIZE[1] - (constants.SQUARE_SIZE[1] // 2)
            
        self.x_pos = self.centre[0] - (self.texture.get_width()//2)
        self.y_pos = self.centre[1] - (self.texture.get_height())
        
    def draw(self, screen, text):
        from classes.global_data import constants_structure, draw_text
        constants = constants_structure()
        
        # Draw texture
        temp_surface = pygame.Surface(constants.SQUARE_SIZE, pygame.SRCALPHA)
        temp_surface.blit(self.texture, [0,0])
        screen.blit(temp_surface, [self.x_pos, self.y_pos])
        
        # Draw objective progress text
        draw_text(text, screen, constants.SMALL_FONT, (self.centre[0], self.centre[1] + (self.texture.get_height()//4)), (255,255,255), "centre", "centre")
        
        # Is mouse close enough for objective description
        from math import sqrt
        mouse_pos = pygame.mouse.get_pos()
        if sqrt(((mouse_pos[0]-self.centre[0])**2) + ((mouse_pos[1]-self.centre[1])**2)) <= constants.SQUARE_SIZE[0] * 1.5:
            # If so, draw objective description
            
            # Draw shadow
            temp_surface = pygame.Surface((250, 30 * len(self.description)), pygame.SRCALPHA)
            temp_surface.blit(pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/menu/shadow.png").convert(), (250, 30 * len(self.description))), [0,0])
            
            # Calculate text alignment based on side (so that text is always visible and not off screen)
            v_pos = "centre"
            h_pos = "centre"
            if self.side == "left":
                h_pos = "left"
                screen.blit(temp_surface, (mouse_pos[0], mouse_pos[1] - 20))
            elif self.side == "right":
                h_pos = "right"
                screen.blit(temp_surface, (mouse_pos[0] - temp_surface.get_width(), mouse_pos[1] - 20))
            elif self.side == "up":
                v_pos = "below"
                screen.blit(temp_surface, (mouse_pos[0] - (temp_surface.get_width()//2), mouse_pos[1]-5))
            elif self.side == "down":
                v_pos = "above"
                screen.blit(temp_surface, (mouse_pos[0] - (temp_surface.get_width()//2), mouse_pos[1]-20))
            
            # Write description in lines
            for i, text in enumerate(self.description):
                # Draw at fixed pos instead, align accordingly
                draw_text(text, screen, constants.SMALL_FONT, (mouse_pos[0], mouse_pos[1] + (i*20)), (255,255,255), h_pos, v_pos)
        
        return screen




File: projects/final/classes/menu.py
import pygame
from classes.global_data import draw_text
from classes.global_data import constants_structure
constants = constants_structure()

def default_response_function(): # Default response function does nothing
    return

class button:
    def __init__(self, location, size, text, response_function=default_response_function, font=constants.NORMAL_FONT):
        # Set all attributes
        self.location = location
        self.size = size
        self.text = text
        self.response_function = response_function
        self.font = font
        
        self.under_pointer = False
        
        # Get texture based on button shape
        ratio = (size[0]/size[1])
        self.texture = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/buttons/ratio1-{ratio}.png").convert()
        
    
        
    def update(self, mouse_pos, keyspressed=[]):
        if (mouse_pos[0] > self.location[0] and
            mouse_pos[1] > self.location[1] and
            mouse_pos[0] < self.location[0] + self.size[0] and
            mouse_pos[1] < self.location[1] + self.size[1] ): # If mouse pointer is within button boundary
            self.under_pointer = True
        else:
            self.under_pointer = False
        
    def draw(self, screen, tickCount=None):
        # Draw button
        screen.blit(pygame.transform.scale(self.texture, self.size), self.location)
        
        # Shade if hovered over
        if self.under_pointer:
            # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
            temp_surface = pygame.Surface(self.size, pygame.SRCALPHA)
            pygame.draw.rect(temp_surface, (0, 0, 0, 128), (0, 0, *self.size))
            screen.blit(temp_surface, self.location)
            
        # Add text
        screen = draw_text(self.text, screen, self.font, 
                            (self.location[0] + ((self.size[0])//2), self.location[1] + ((self.size[1])//2)),
                            (0,0,0),
                            "centre",
                            "centre")
        
        return screen
    
    
class textInputBox:
    def __init__(self, location, size, button_name, protected=False, font = constants.NORMAL_FONT):
        # Set attributes
        self.location = location
        self.size = size
        self.name = button_name
        self.protected = protected
        self.font = font
        
        self.selected = False
        self.content = ""
        
        # Get texture based on button shape
        ratio = (size[0]/size[1])
        self.texture = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/text_input/ratio1-{ratio}.png").convert()
        
    def response_function(self):
        self.selected = not self.selected # toggle selection
    
    def update(self, mouse_pos, keyspressed=[]):
        if (mouse_pos[0] > self.location[0] and
            mouse_pos[1] > self.location[1] and
            mouse_pos[0] < self.location[0] + self.size[0] and
            mouse_pos[1] < self.location[1] + self.size[1] ): # If mouse pointer is within button boundary
            self.under_pointer = True
        else:
            self.under_pointer = False
            
        # Check keyboard inputs to add to content
        if self.selected:
            for key in keyspressed:
                if key == '\x08': # Backspace
                    self.content = self.content[:-1]
                elif key == "\r": # Enter
                    self.selected = False
                elif len(self.content) <= 17: # Maximum string length is 17
                    self.content += key
        
    
    def draw(self, screen, tickCount=None):
        # Draw button
        screen.blit(pygame.transform.scale(self.texture, self.size), self.location)
        
        # Shade if hovered over
        if self.under_pointer or self.selected:
            if self.selected and not self.under_pointer:
                intensity = 64
            else:
                intensity = 128
                
            # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
            temp_surface = pygame.Surface(self.size, pygame.SRCALPHA) 
            pygame.draw.rect(temp_surface, (0, 0, 0, intensity), (0, 0, *self.size))
            screen.blit(temp_surface, self.location)
            
        # Add text
        if self.content != "" or self.selected:
            if self.protected:
                protected_string = "*" * len(self.content)
                content = self.font.render(protected_string, True, (0, 0, 0))
            else:
                content = self.font.render(self.content, True, (0, 0, 0))
        else:
            content = self.font.render(self.name, True, (50, 50, 50))
        screen.blit(content, (self.location[0] + ((self.size[0] - content.get_width())//2), self.location[1] + ((self.size[1] - content.get_height())//2)))
        
        # Draw text cursor
        if tickCount % 16 < 8 and self.selected:
            pygame.draw.rect(screen, (0, 0, 0), (self.location[0] + (self.size[0] + content.get_width())//2 + 4, self.location[1] + 30, 7, 40))
        
        return screen
    
    
class displayedError:
    def __init__(self, error_message, start_tick):
        # Set attributes
        self.error_message = error_message
        self.start_tick = start_tick 
    
    def draw(self, screen):
        intensity = 128
        font = pygame.font.Font(constants.FILE_PATH + "project_lib/fonts/normal.ttf", 20)
        
        # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA) 
        content = font.render(self.error_message, True, (255, 50, 50, intensity) )
        temp_surface.blit(content, ((constants.DEFAULT_SCREEN_SIZE[0] - content.get_width())//2, 5))
        screen.blit(temp_surface, (0,0))
        
        return screen
    
    
class savegameButton:
    def __init__(self, location, size, savegame_display_details, game_data):
        # Set attributes
        self.location = location
        self.size = size
        self.savegame_display_details = savegame_display_details
        self.middle_font = pygame.font.Font(constants.FILE_PATH + "project_lib/fonts/normal.ttf", 30)
        
        self.game_data = game_data
        
        self.under_pointer = False
        
        # Get texture based on button shape
        ratio = (size[0]/size[1])
        self.texture = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/text_input/ratio1-{ratio}.png").convert() # Use text input button design
    
    def update(self, mouse_pos, keyspressed=[]):
        if (mouse_pos[0] > self.location[0] and
            mouse_pos[1] > self.location[1] and
            mouse_pos[0] < self.location[0] + self.size[0] and
            mouse_pos[1] < self.location[1] + self.size[1] ): # If mouse pointer is within button boundary
            self.under_pointer = True
        else:
            self.under_pointer = False
    
    def response_function(self, screen):
        # Open screen to edit savegame
        from functions.loops.savegame_options import open_savegame
        open_savegame(*self.game_data, self.savegame_display_details, screen)
        return
    
    def draw(self, screen, tickCount=None):
        # Draw button
        screen.blit(pygame.transform.scale(self.texture, self.size), self.location)
        
        # Shade if hovered over
        if self.under_pointer:
            # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
            temp_surface = pygame.Surface(self.size, pygame.SRCALPHA)
            pygame.draw.rect(temp_surface, (0, 0, 0, 128), (0, 0, *self.size))
            screen.blit(temp_surface, self.location)
            
        # Add text
        info = [self.savegame_display_details["name"],
                "Level: " + str(self.savegame_display_details["level"]),
                "Last Saved: " + str(self.savegame_display_details["last_save"]),
                "Created: " + str(self.savegame_display_details["created"])]
        
        for i, line in enumerate(info):
            if i == 0: # Name of savegame
                text = self.middle_font.render(line, True, (0, 0, 0))
                screen.blit(text, (self.location[0] + ((self.size[0] - text.get_width())//2), 
                                self.location[1] + (self.size[1]//2) + (self.size[1]//8 * (i-1)) - 20))
            else: # Savegame details
                text = constants.SMALL_FONT.render(line, True, (0, 0, 0))
                screen.blit(text, (self.location[0] + ((self.size[0] - text.get_width())//2), 
                                    self.location[1] + (self.size[1]//2) + (self.size[1]//8 * (i-1))))
            
        return screen
    
    
    
    
class KeyBindingInput:
    def __init__(self, location, size, name, key, protected=False, font = constants.NORMAL_FONT):
        # Set attributes
        self.location = location
        self.size = size
        self.name = name
        self.key = key
        self.protected = protected
        self.font = font
        
        self.selected = False
        self.content = ""
        
        # Get texture based on button shape
        ratio = (size[0]/size[1])
        
        self.selected_texture = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/text_input/ratio1-{ratio}.png").convert()
        self.default_texture = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/buttons/ratio1-{ratio}.png").convert()
        
    def response_function(self):
        self.selected = not self.selected
        return self.selected
        #self.selected = not self.selected # toggle selection
    
    def update(self, mouse_pos, keyspressed=[]):
        if (mouse_pos[0] > self.location[0] and
            mouse_pos[1] > self.location[1] and
            mouse_pos[0] < self.location[0] + self.size[0] and
            mouse_pos[1] < self.location[1] + self.size[1] ): # If mouse pointer is within button boundary
            self.under_pointer = True
        else:
            self.under_pointer = False
            
    
    def draw(self, screen, tickCount=None):
        # Draw button depending on state
        if self.selected:
            screen.blit(pygame.transform.scale(self.selected_texture, self.size), self.location)
        else:
            screen.blit(pygame.transform.scale(self.default_texture, self.size), self.location)
        
        # Shade if hovered over
        if self.under_pointer or self.selected:
            if self.selected and not self.under_pointer:
                intensity = 64
            else:
                intensity = 128
            temp_surface = pygame.Surface(self.size, pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
            pygame.draw.rect(temp_surface, (0, 0, 0, intensity), (0, 0, *self.size))
            screen.blit(temp_surface, self.location)
            
        # Add text
        # add key
        screen = draw_text(self.key.upper(), screen, self.font, 
                            (self.location[0] + ((self.size[0])//2), self.location[1] + ((self.size[1])//2)),
                            (0,0,0),
                            "centre",
                            "centre")
        # add binding name
        screen = draw_text(self.name.replace("_", " ").title() + ": ", screen, self.font, 
                            (self.location[0], self.location[1] + ((self.size[1])//2)),
                            (0,0,0),
                            "right",
                            "centre")
        
        return screen




File: projects/final/classes/player.py
import pygame
from functions.algorithms.aoeScanner import aoeScanner
from functions.algorithms.item_lookup import lookup
from classes.items.living_item import LivingItem
from math import sqrt
from random import randint


class Player:
    def __init__(self, level, account_id, savegame_id):
        import json
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        # Extract player data
        player_data = json.load(open(constants.FILE_PATH + f"data/account_games/{account_id}_games/{savegame_id}_levels/rooms_{level}/player.json", "r"))

        # Set all attributes (most data extracted from player data)
        self.account_id = account_id
        self.savegame_id = savegame_id
        
        self.initiate_assets(constants)
        
        self.state = "idle"
        self.direction = player_data["direction"]
        
        self.lives = player_data["lives"]
        
        self.max_health = player_data["max_health"]
        self.health = player_data["health"]
        self.x_pos = player_data["x"] if player_data["x"] is not None else constants.GAME_WINDOW_SIZE[0]//2 - 75   #x if x is not None else player_data["x"]
        self.y_pos = player_data["y"] if player_data["y"] is not None else constants.GAME_WINDOW_SIZE[1]//2 - 75   #y if y is not None else player_data["y"]
        self.current_room = player_data["current_room"]
        self.movement_vector = [0,0]
        self.speed = player_data["speed"]
        self.push_pull_speed = player_data["push_pull_speed"]
        self.size = (150,150)
        self.sprinting = False
        self.push_speed_multiplier = 0.3
        self.pushing = False
        self.sprint_multiplier = 2
        self.max_sprint_stamina = player_data["max_sprint_stamina"]
        self.sprint_stamina = player_data["sprint_stamina"]
        self.max_boost_time = player_data["max_boost_time"]
        self.boost_cooldown = player_data["boost_cooldown"]
        self.boost_frame = 0
        self.boost_speed = player_data["boost_speed"]
        self.animation_frame_time = 0.1
        self.animation_cooldown = 0
        
        self.mele_reach = player_data["mele_reach"]
        self.mele_push_strength = player_data["mele_push_strength"]
        self.attack_damage = player_data["attack_damage"]
        self.attack_timer = 0
        self.max_attack_cooldown = player_data["max_attack_cooldown"]
        self.attack_cooldown = self.max_attack_cooldown
        
        self.team = "player"
        
        self.held_keys = {
            "up": False,
            "down": False,
            "left": False,
            "right": False,
            "sprint": False
        }
        
        self.collision_box = {"size": (48, 25),
                            "location": ((self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 40 + self.y_pos)}
        
        # Inventory
        inventory_data = player_data["inventory"]
        
        from functions.algorithms.item_lookup import lookup as i_lookup
        self.inventory = []
        for item in inventory_data:
            if item is not None:
                self.inventory.append(i_lookup(item["item"])(item["payload"])) # Translate item IDs into item objects to populate inventory
            else:
                self.inventory.append(None)
        
        
        # General textures
        self.inv_texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/inventory.png").convert(), (constants.INV_ITEM_SIZE[0] * 3, constants.INV_ITEM_SIZE[1] * 5))
        self.selected_inv_texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/inventory_highlighted.png").convert(), constants.INV_ITEM_SIZE)
        self.holding_main_hand = player_data["holding_main_hand"]
        
        self.lives_texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/icons/player_head.png").convert(), constants.LIVES_SIZE)
        
        self.side_bar_asset = pygame.image.load(constants.FILE_PATH + "project_lib/assets/menu/side_bar.png")
        
        self.get_square = lambda room : [int((self.collision_box["location"][0] - room.location[0])//constants.SQUARE_SIZE[0]),
                                        int((self.collision_box["location"][1] - room.location[1])//constants.SQUARE_SIZE[1])]
        
        
        # possible states: idle, run, sprint, boost, push, pull, attack, take_damage, death, fall
        self.change_state("idle")
        
        # Statistics
        self.kills = player_data["kills"]
        
        
    def move(self, key_bindings, events, room_data, entities, living_items, crates, levers, doors, room, screen):
        # Prioritise non-processing animations (death)
        if self.state == "death":
            if self.animation_frame == len(self.assets["death"])-1:
                return True, living_items, True # Running death animation
            else:
                return False, living_items, True # Finally dead

        
        throw_away_items = [] # Items that will be thrown out of the players inventory later and turned into living items
        
        # Increment attack cooldown
        if self.attack_cooldown < self.max_attack_cooldown:
            self.attack_cooldown += 1 * self.get_attack_speed_multiplier()
        
        # Keep track of actions in this frame
        started_movements = []
        ended_movements = []
        for event in events:
            # Tracks what keys have been pressed or unpressed
            if event.type == pygame.KEYDOWN:
                if key_bindings.get(str(event.key)) is not None: # key values are equal to the decimal ascii value of that key
                    started_movements.append(key_bindings[str(event.key)])
            if event.type == pygame.KEYUP:
                if key_bindings.get(str(event.key)) is not None: # key values are equal to the decimal ascii value of that key
                    ended_movements.append(key_bindings[str(event.key)])
            # Tracks what mouse buttons have been pressed or unpressed
            if event.type == pygame.MOUSEBUTTONDOWN:
                if key_bindings.get("L_CLICK") is not None:
                    started_movements.append(key_bindings["L_CLICK"])
            if event.type == pygame.MOUSEBUTTONUP:
                if key_bindings.get("L_CLICK") is not None:
                    started_movements.append(key_bindings["L_CLICK"])

        
        
        
        
        # Start togglable movements
        for movement in started_movements:
            # Directional movements
            # Held Keys are keys where the state needs to referenced every frame, rather than only being triggered when they are hit
            # For example, when holding the up key, you want the player to continue to do the action until you release the key, but
            # with something like attacking, you only want them to attack when you click, and then you should have to click again
            # in order to attack again.
            if movement == "up":
                self.held_keys["up"] = True
            elif movement == "down":
                self.held_keys["down"] = True
            elif movement == "left":
                self.held_keys["left"] = True
            elif movement == "right":
                self.held_keys["right"] = True
                
            elif movement == "sprint":
                self.held_keys["sprint"] = True
                if self.sprint_stamina > 0:
                    self.sprinting = True
                    
            elif movement == "attack":
                if self.attack_cooldown >= self.max_attack_cooldown: # Check if attack is possible
                    self.attack_cooldown = 0
                    attack_damage = self.attack_damage # Default
                    # calculate new damage from weapon
                    if self.holding_main_hand and (self.inventory[0] != None): # Mainhand
                        attack_damage = self.attack_damage * self.inventory[0].damage_multiplier
                    elif (not self.holding_main_hand) and (self.inventory[1] != None): # Offhand
                        attack_damage = self.attack_damage * self.inventory[1].damage_multiplier
                        
                    # Run attack
                    drops = self.attack(self, entities, room, attack_damage)
                    
                    # Handle drops from attack
                    for item in drops:
                        if item["name"] != None:
                            living_items.append(LivingItem(item["x"], item["y"], lookup(item["name"]["item"])(item["name"]["payload"]), [randint(-10,10), randint(-10,10)]))
                            
                
            # Hand selection (boolean determines where in inventory array will be selected, since index 0 and 1 are the main and off hand respectively)
            elif movement == "switch_hand": # Toggle
                self.holding_main_hand = not self.holding_main_hand
            elif movement == "main_hand": # Main
                self.holding_main_hand = True
            elif movement == "off_hand": # Off
                self.holding_main_hand = False
                
            # Run screen buttons
            elif movement == "pause": # Pause screen
                from functions.loops.pause_screen import run as run_pause_screen
                continue_game = run_pause_screen(screen, key_bindings)
                # Pause screen might tell player to quit game, which needs to be brought back to game loop shell by returning values
                if not continue_game:
                    return False, living_items, False # Last false means that game must be quit
                
                self.reassess_keys(key_bindings) # Manually reassess what keys are pressed
                
            elif movement == "inventory": # Inventory screen
                from functions.loops.inventory import run as open_inventory
                self.inventory, throw_away_items = open_inventory(self.inventory, screen, key_bindings) # Get items removed from inventory after inventory closed
                
                self.reassess_keys(key_bindings)# Manually reassess what keys are pressed
                
            # Boost functionality
            elif movement == "boost":
                # Boost will only run if player is moving to prevent accidental use
                if self.boost_cooldown == self.max_boost_time  and  (self.held_keys["up"] or self.held_keys["down"] or self.held_keys["left"] or self.held_keys["right"]):
                    self.boost_cooldown = 0
                    self.boost_frame = 3
                    
            elif movement == "interact":
                # check for item pickup
                if len(living_items) > 0:
                    item = None
                    distance = 9999999999999
                    for l_item in living_items:
                        n_distance = sqrt((((l_item.x_pos + (l_item.size[0]//2)) - (self.collision_box["location"][0] + (self.collision_box["size"][0]//2)))  **2)  +
                                        (((l_item.y_pos + (l_item.size[1]//2)) - (self.collision_box["location"][1] + (self.collision_box["size"][1]//2)))  **2))
                        if n_distance < distance:
                            item = l_item
                            distance = n_distance
                        
                    if distance < 60:
                        living_items = self.pick_up(item, living_items)
                        break # break from interaction
                    
                # check for doors to be opened
                if len(doors) > 0:
                    door = None
                    distance = 9999999999999
                    for n_door in doors:
                        if n_door.manual or n_door.type == "keyhole":
                            n_distance = sqrt((((n_door.collision_box["location"][0] + (n_door.collision_box["size"][0]//2)) - (self.collision_box["location"][0] + (self.collision_box["size"][0]//2)))  **2)  +
                                            (((n_door.collision_box["location"][1] + (n_door.collision_box["size"][1]//2)) - (self.collision_box["location"][1] + (self.collision_box["size"][1]//2)))  **2))
                            if n_distance < distance:
                                door = n_door
                                distance = n_distance
                                
                        
                    if distance < 90:
                        if door.type == "keyhole": # Keyhole doors require current hand to contain correct key
                            if self.inventory[1-int(self.holding_main_hand)] != None:
                                if self.inventory[1-int(self.holding_main_hand)].type == "key":
                                    if self.inventory[1-int(self.holding_main_hand)].colour == door.colour:
                                        door.toggle_state()
                                        if door.side is not None:
                                            room.complete_objective(door.side)
                        else:
                            door.toggle_state() # Normal door
                        break # break from interaction
                        
                # check for levers to be flicked
                if len(levers) > 0:
                    lever = None
                    distance = 9999999999999
                    for n_lever in levers:
                        n_distance = sqrt((((n_lever.collision_box["location"][0] + (n_lever.collision_box["size"][0]//2)) - (self.collision_box["location"][0] + (self.collision_box["size"][0]//2)))  **2)  +
                                        (((n_lever.collision_box["location"][1] + (n_lever.collision_box["size"][1]//2)) - (self.collision_box["location"][1] + (self.collision_box["size"][1]//2)))  **2))
                        if n_distance < distance:
                            lever = n_lever
                            distance = n_distance
                        
                    if distance < 60:
                        lever.flicked = not lever.flicked # toggle
                        break # break from interaction
        
        # end movements (only held keys)
        for movement in ended_movements:
            if movement == "up":
                self.held_keys["up"] = False
            elif movement == "down":
                self.held_keys["down"] = False
            elif movement == "left":
                self.held_keys["left"] = False
            elif movement == "right":
                self.held_keys["right"] = False
            elif movement == "sprint":
                self.sprinting = False
                self.held_keys["sprint"] = False
                
        # Calculate speed based on sprinting
        multiplier = self.get_speed_multiplier() # Multiplier based on current equipment
        if self.sprinting:
            multiplier = self.sprint_multiplier
            
        
        # create vector from held keys
        self.movement_vector = [0,0]
        if self.held_keys["up"]:
            self.movement_vector[1] -= self.speed * multiplier
        if self.held_keys["down"]:
            self.movement_vector[1] += self.speed * multiplier
        if self.held_keys["left"]:
            self.movement_vector[0] -= self.speed * multiplier
        if self.held_keys["right"]:
            self.movement_vector[0] += self.speed * multiplier
        self.check_direction()
        
        
        # adjust stamina
        if self.sprinting and self.sprint_stamina > 0 and (not self.pushing):
            self.sprint_stamina -= 1
        elif self.sprint_stamina < 45 and (not self.pushing):
            self.sprint_stamina += 1 * self.get_stamina_recharge_multiplier()
        
        if self.sprint_stamina == 0:
            self.sprinting = False
        
        # adjust boost cooldown
        if self.boost_cooldown < self.max_boost_time:
            self.boost_cooldown += 1
                    
                    
        moves = 1
        boosting = False
        if self.boost_frame > 0:
            boosting = True
            self.boost_frame -= 1 * self.get_stamina_recharge_multiplier()
            moves = self.boost_speed
            
            
        # CALCULATE MOVEMENT VECTOR
        speed = self.speed * self.get_speed_multiplier()
        if self.sprinting and not boosting:
            speed *= self.sprint_multiplier
        # Uses direction vector and scales it to work for movement speed, so that movement in any direction has a uniform speed
        from functions.algorithms.getMovementVector import get_movement_vector
        self.movement_vector = get_movement_vector(speed, self.movement_vector)
        
        
        
        from functions.algorithms.collision_detection import is_colliding, collision
        from classes.global_data import constants_structure
        constants = constants_structure()
        self.pushing = False
        for i in range(moves): # Check every step so that player can walk right up to wall
            self.collision_box["location"] = ((self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 23 + self.y_pos)
            # Calculate X direction
            projected_collision_box = self.collision_box
            for x_distance in range(abs(int(self.movement_vector[0]))):
                # Cast collision box
                self.collision_box["location"] = ((self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 23 + self.y_pos)
                projected_collision_box = {
                    "size": projected_collision_box["size"],
                    "location": (projected_collision_box["location"][0] + (self.movement_vector[0]/abs(self.movement_vector[0])), projected_collision_box["location"][1])
                }
                # Check for square collisions
                if not is_colliding(projected_collision_box, room_data["layout"], room_data["location"], constants.SQUARE_SIZE): # wall collision
                    is_crate_collision = False
                    pushed_x = False
                    collided_door = False
                    # Check for door collisions
                    for door in doors:
                        if collision([*projected_collision_box["location"], *projected_collision_box["size"]], [*door.collision_box["location"], *door.collision_box["size"]]):
                            collided_door = True
                            break
                    if not collided_door:
                        # Check for crate collisions
                        for crate in crates:
                            if collision([*projected_collision_box["location"], *projected_collision_box["size"]], [*crate.collision_box["location"], *crate.collision_box["size"]]):
                                is_crate_collision = True
                                if self.held_keys["sprint"]:
                                    self.pushing = True
                                    if crate.move("left" if self.movement_vector[0] < 0 else "right", self.push_speed_multiplier, room, crates, doors, entities, []):
                                        if not pushed_x:
                                            pushed_x = True
                                            self.x_pos += (self.movement_vector[0]/abs(self.movement_vector[0])) * self.push_speed_multiplier
                    # Carry out move if possible
                    if not (is_crate_collision or collided_door):
                        self.x_pos += (self.movement_vector[0]/abs(self.movement_vector[0]))
                
            # Calculate Y direction
            projected_collision_box = self.collision_box
            for y_distance in range(abs(int(self.movement_vector[1]))):
                # Cast collision box
                self.collision_box["location"] = ((self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 23 + self.y_pos)
                projected_collision_box = {
                    "size": projected_collision_box["size"],
                    "location": (projected_collision_box["location"][0], projected_collision_box["location"][1] + (self.movement_vector[1]/abs(self.movement_vector[1])))
                }
                # Check for square collisions
                if not is_colliding(projected_collision_box, room_data["layout"], room_data["location"], constants.SQUARE_SIZE):
                    is_crate_collision = False
                    pushed_y = False
                    collided_door = False
                    # Check for door collisions
                    for door in doors:
                        if collision([*projected_collision_box["location"], *projected_collision_box["size"]], [*door.collision_box["location"], *door.collision_box["size"]]):
                            collided_door = True
                            break
                    if not collided_door:
                        # Check for crate collisions
                        for crate in crates:
                            if collision([*projected_collision_box["location"], *projected_collision_box["size"]], [*crate.collision_box["location"], *crate.collision_box["size"]]):
                                is_crate_collision = True
                                if self.held_keys["sprint"]:
                                    self.pushing = True
                                    if crate.move("up" if self.movement_vector[1] < 0 else "down", self.push_speed_multiplier, room, crates, doors, entities, []):
                                        if not pushed_y:
                                            pushed_y = True
                                            self.y_pos += (self.movement_vector[1]/abs(self.movement_vector[1])) * self.push_speed_multiplier
                    # Carry out move if possible
                    if not (is_crate_collision or collided_door):
                        self.y_pos += (self.movement_vector[1]/abs(self.movement_vector[1]))
        
        
        # Calculate state changes
        if (self.state in ["idle", "run"] or (self.attack_cooldown == self.max_attack_cooldown)) and not self.pushing: # check that the state shouldn't be anything else
            if self.movement_vector == [0,0] and not self.state == "idle":
                self.change_state("idle")
            elif self.movement_vector != [0,0] and not self.state == "run":
                self.change_state("run")
                
        elif self.pushing and self.state != "push":
            self.change_state("push")
            
        # Update collision box
        self.collision_box["location"] = ((self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 23 + self.y_pos)
        
        # Turn thrown away items into living items and add them to the living items list
        for item in throw_away_items:
            throwing_velocity = 10
            if self.direction == "right":
                throwing_direction = [throwing_velocity,0]
            elif self.direction == "left":
                throwing_direction = [-1 * throwing_velocity,0]
            elif self.direction == "up":
                throwing_direction = [0,-1 * throwing_velocity]
            elif self.direction == "down":
                throwing_direction = [0,throwing_velocity]
            living_items.append(LivingItem(self.collision_box["location"][0] + (self.collision_box["size"][0]//2) + randint(0,20)-10,
                                            self.collision_box["location"][1] + randint(0,20)-10,
                                            item,
                                            throwing_direction))
        
        return False, living_items, True # Return all updated data back to main function
    
    
    def get_damage_multiplier(self): # not including hand (that is dealt with seperately)
        multiplier = 1
        for i in range(3): # Charms
            if self.inventory[8+i] != None:
                multiplier *= self.inventory[8+i].damage_multiplier
        return multiplier
    
    def get_speed_multiplier(self):
        multiplier = 1
        for i in range(6): # Charms and armour
            if self.inventory[8+i] != None:
                multiplier *= self.inventory[8+i].speed_multiplier
        return multiplier
    
    def get_mele_armour_multiplier(self):
        multiplier = 1
        for i in range(6): # Charms and armour
            if self.inventory[8+i] != None:
                multiplier *= self.inventory[8+i].mele_armour_multiplier
        return multiplier
    
    # NOT IMPLEMENTED DUE TO NO RANGED WEAPONS
    def get_ranged_armour_multiplier(self):
        multiplier = 1
        for i in range(6): # Charms and armour
            if self.inventory[8+i] != None:
                multiplier *= self.inventory[8+i].ranged_armour_multiplier
        return multiplier
    
    def get_attack_speed_multiplier(self): # not including hand (that is dealt with seperately)
        multiplier = 1
        for i in range(3): # Charms
            if self.inventory[8+i] != None:
                multiplier *= self.inventory[8+i].attack_speed_multiplier
        return multiplier
        
    # NOT IMPLEMENTED DUE TO NO RANGED WEAPONS
    def get_ranged_reload_multiplier(self):
        multiplier = 1
        for i in range(3): # Charms
            if self.inventory[8+i] != None:
                multiplier *= self.inventory[8+i].ranged_reload_multiplier
        return multiplier
    
    # NOT IMPLEMENTED DUE TO NO CHARMS
    def get_max_health_multiplier(self):
        multiplier = 1
        for i in range(3): # Charms
            if self.inventory[8+i] != None:
                multiplier *= self.inventory[8+i].max_health_multiplier
        return multiplier
    
    # NOT IMPLEMENTED
    def get_regen_speed(self):
        speed = 0
        for i in range(3): # Charms
            if self.inventory[8+i] != None:
                multiplier += self.inventory[8+i].regen_speed
        return speed
    
    def get_stamina_recharge_multiplier(self):
        multiplier = 1
        for i in range(3): # Charms
            if self.inventory[8+i] != None:
                multiplier *= self.inventory[8+i].stamina_recharge_multiplier
        return multiplier
        
        
    
    def teleport(self, x, y): # Manually sets coordinates if needed
        self.x_pos = x
        self.y_pos = y
        
    def reassess_keys(self, key_bindings): # Manually reassess the state of all held keys
        keys = pygame.key.get_pressed()
        for key in key_bindings:
            if key_bindings[key] in self.held_keys:
                self.held_keys[key_bindings[key]] = keys[int(key)]
            
    def change_state(self, new_state): # Update state and reset animation frame
        self.state = new_state
        self.animation_frame = 0
    
    def check_direction(self):
        # Calculate direction based off of movement vector
        if self.movement_vector != [0,0]:
            if self.movement_vector[0] == 0:
                if self.movement_vector[1] < 0:
                    self.direction = "up"
                else:
                    self.direction = "down"
            if self.movement_vector[0] < 0:
                self.direction = "left"
            elif self.movement_vector[0] > 0:
                self.direction = "right"
    
    def pick_up(self, living_item, living_items):
        if None in self.inventory: # If inventory has space
            for s, slot in enumerate(self.inventory):
                if slot == None:
                    # Add item to empty slot
                    self.inventory[s] = living_item.item 
                    # Remove item from ground
                    for i, item in enumerate(living_items):
                        if living_item == item:
                            living_items.pop(i)
                            break
                    break
        return living_items
                
    def attack(self, player, entities, room, damage):
        from functions.algorithms.getMovementVector import get_movement_vector
        from classes.global_data import constants_structure
        constants = constants_structure()
        # Start attack animation
        self.change_state("attack")
        self.attack_timer = 3
        
        # Calculate how much damage should be done to effected objects
        damage *= self.get_damage_multiplier()
        
        multiplier = 1
        if self.inventory[(0 if self.holding_main_hand else 1)] != None:
            multiplier = self.inventory[(0 if self.holding_main_hand else 1)].mele_range_multiplier
        
        # Calculate attack range
        reach = self.mele_reach * multiplier
        range_vector = get_movement_vector(reach, self.movement_vector)
        attack_loc = [(self.collision_box["location"][0] + (self.collision_box["size"][0]//2)) + range_vector[0],
                        (self.collision_box["location"][1] + (self.collision_box["size"][1]//2)) + range_vector[1]]
        
        # Get lists of effected entities and squares
        effectedEntities, effectedSquares, playerEffected = aoeScanner(attack_loc, entities, room, player, reach, constants, True)
        
        drops = []
        
        # Entities
        for entity in effectedEntities:
            if entity.team != self.team:
                killed, entity_drops = entity.take_damage(damage) # returns true if entity is killed
                if killed:
                    self.kills += 1
                    room.kills += 1
                for drop in entity_drops:
                    drops.append({"name": drop, 
                                    "x": entity.collision_box["location"][0],
                                    "y": entity.collision_box["location"][1]})
        
        # Squares
        for square in effectedSquares:
            square_obj = room.layout[square[1]][square[0]]
            if square_obj.breakable:
                square_drops = square_obj.take_damage(damage, room)
                for drop in square_drops:
                    drops.append({"name": drop, 
                                    "x": square[0]*constants.SQUARE_SIZE[0] + room.location[0],
                                    "y": square[1]*constants.SQUARE_SIZE[1] + room.location[1]})
        
        return drops
                
    def take_damage(self, damage, damage_type="mele"):
        self.change_state("take_damage")
        
        # Reduce incoming damage based on armour stats
        if damage_type == "mele":
            damage *= self.get_mele_armour_multiplier()
        elif damage_type == "ranged": # NOT YET FULLY IMPLEMENTED
            damage *= self.get_ranged_armour_multiplier()
        
        # Do damage and check for death
        self.health -= damage
        if self.health <= 0:
            self.die()
            
    def die(self):
        # Start death sequence
        self.change_state("death")
        
        
    def save(self, level, room_id):
        import json
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        # Turn inventory objects back into strings
        inventory_data = []
        for item in self.inventory:
            if item is not None:
                inventory_data.append(item.save())
            else:
                inventory_data.append(None)
        
        # Construct data
        data = {
        "lives": self.lives,
        "max_health": self.max_health,
        "health": self.health,
        "x": self.x_pos,
        "y": self.y_pos,
        "current_room": room_id,
        "direction": self.direction,
        "speed": self.speed,
        "push_pull_speed": self.push_pull_speed,
        "max_sprint_stamina": self.max_sprint_stamina,
        "sprint_stamina": self.sprint_stamina,
        "max_boost_time": self.max_boost_time,
        "boost_cooldown": self.boost_cooldown,
        "boost_speed": self.boost_speed,

        "mele_reach": self.mele_reach,
        "mele_push_strength": self.mele_push_strength,
        "attack_damage": self.attack_damage,
        "max_attack_cooldown": self.max_attack_cooldown,

        "inventory": inventory_data,

        "holding_main_hand": self.holding_main_hand,

        "kills": self.kills
        }
        
        # Write data to file
        with open(constants.FILE_PATH + f"data/account_games/{self.account_id}_games/{self.savegame_id}_levels/rooms_{level}/player.json", 'w') as file:
            json_string = json.dumps(data)
            file.write(json_string)
    
    def get_rendering_row(self):
        return self.collision_box["location"][1]
    
    def draw(self, screen):
        from classes.global_data import constants_structure, draw_text
        constants = constants_structure()
        
        FPS = constants.MENU_FPS * 2
        
        # Get animation name for direction states
        if (self.state == "idle" or
            self.state == "run" or
            self.state == "push" or
            self.state == "pull" or
            self.state == "attack"):
            animation = self.state + "_" + self.direction
        # Get animation name for non-directional states
        else:
            animation = self.state
            
            
        # HAND ITEM
        
        # Select hand item texture to draw
        self.hand_texture = pygame.Surface((1,1), pygame.SRCALPHA)
        if self.holding_main_hand:
            if self.inventory[0] != None:
                item_texture = self.inventory[0].game_texture
        else:
            if self.inventory[1] != None:
                item_texture = self.inventory[1].game_texture
        
        if (self.holding_main_hand and self.inventory[0] != None) or ((not self.holding_main_hand) and self.inventory[1] != None):
            # Rotate for attack type to draw animation
            if self.state == "attack":
                item_texture = pygame.transform.rotate(item_texture, self.animation_frame * -60)
            # Find orientation and size
            if self.direction == "left" or self.direction == "up":
                item_texture = pygame.transform.flip(item_texture, True, False)
            item_texture = pygame.transform.scale(item_texture, (self.size[0]//3, self.size[1]//3))
            # Draw to location
            temp_surface = pygame.Surface(self.size, pygame.SRCALPHA)
            if self.direction == "left" or self.direction == "up":
                temp_surface.blit(item_texture, (15,50))
            else:
                temp_surface.blit(item_texture, ((self.size[0]//2)+10, 50))
            self.hand_texture = temp_surface
            screen.blit(temp_surface, (self.x_pos, self.y_pos))
            
            
        # Player
        
        # Calculate animation frame
        self.animation_cooldown += 1
        if self.sprinting:
            self.animation_cooldown *= self.sprint_multiplier
        if self.animation_cooldown >= FPS // (1/self.animation_frame_time):
            self.animation_cooldown = 0
            self.animation_frame += 1
            
        
        if self.animation_frame >= len(self.assets[animation]):
            self.animation_frame = 0
        
        self.chosen_asset = self.assets[animation][self.animation_frame]
        
        # Draw animation frame
        # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        temp_surface = pygame.Surface(self.size, pygame.SRCALPHA) 
        temp_surface.blit(pygame.transform.scale(self.chosen_asset, self.size),(0,0))
        screen.blit(temp_surface, (self.x_pos, self.y_pos))
        
        # Code to draw collision box for development:
        # temp_surface = pygame.Surface(self.size, pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        # pygame.draw.rect(temp_surface, (255, 0, 0, 127), (0, 0, *self.collision_box["size"]))
        # screen.blit(temp_surface, self.collision_box["location"])
        
        return screen
    
    def draw_overlay_data(self, screen, room_location, room_size):
        from classes.global_data import constants_structure, draw_text
        constants = constants_structure()
        
        # Draw side-bar
        temp_surface = pygame.Surface(constants.GUI_WINDOW_SIZE, pygame.SRCALPHA) 
        side_bar = self.side_bar_asset
        if not constants.LANDSCAPE:
            side_bar = pygame.transform.rotate(side_bar, 90)
        temp_surface.blit(pygame.transform.scale(side_bar, constants.GUI_WINDOW_SIZE), (0,0))
        screen.blit(temp_surface, (0,0))
        
        
        # Draw sprint energy
        sprint_energy_location = [(constants.GUI_WINDOW_SIZE[0] - self.inv_texture.get_width())//2 + (self.inv_texture.get_width() // 4 * 3), 20 + self.inv_texture.get_height() + 100]
        sprint_energy_size = [self.inv_texture.get_width() // 2 - 40, 20]
        screen = draw_text("Sprint", screen, constants.SMALL_FONT, sprint_energy_location, (255,255,255), "centre", "below")
        # Black background
        pygame.draw.rect(screen, (0, 0, 0), (sprint_energy_location[0] - (sprint_energy_size[0]//2), sprint_energy_location[1] - sprint_energy_size[1] - 10, *sprint_energy_size))
        # Green fill
        bar_width = int(sprint_energy_size[0] * self.sprint_stamina / self.max_sprint_stamina)
        pygame.draw.rect(screen, (0, 255, 0), (sprint_energy_location[0] - (sprint_energy_size[0]//2), sprint_energy_location[1] - 30, 
                                                bar_width, sprint_energy_size[1]))
        
        # Draw boost energy
        boost_energy_location = [(constants.GUI_WINDOW_SIZE[0] - self.inv_texture.get_width())//2 + (self.inv_texture.get_width() // 4), 20 + self.inv_texture.get_height() + 100]
        boost_energy_size = [self.inv_texture.get_width() // 2 - 40, 20]
        screen = draw_text("Boost", screen, constants.SMALL_FONT, boost_energy_location, (255,255,255), "centre", "below")
        # Black background
        pygame.draw.rect(screen, (0, 0, 0), (boost_energy_location[0] - (boost_energy_size[0]//2), boost_energy_location[1] - boost_energy_size[1] - 10, *boost_energy_size))
        # Green fill
        bar_width = int(boost_energy_size[0] * self.boost_cooldown / self.max_boost_time)
        pygame.draw.rect(screen, (0, 255, 0), (boost_energy_location[0] - (boost_energy_size[0]//2), boost_energy_location[1] - 30, 
                                                bar_width, boost_energy_size[1]))
        
        
        # Draw health
        health_bar_location = [(constants.GUI_WINDOW_SIZE[0] - self.inv_texture.get_width())//2 + (self.inv_texture.get_width() // 2), 20 + self.inv_texture.get_height() + 40]
        health_bar_size = [self.inv_texture.get_width(), 20]
        screen = draw_text("Health", screen, constants.SMALL_FONT, health_bar_location, (255,255,255), "centre", "below")
        # Black background
        pygame.draw.rect(screen, (0, 0, 0), (health_bar_location[0] - (health_bar_size[0]//2), health_bar_location[1] - health_bar_size[1] - 10, *health_bar_size))
        # Green fill
        bar_width = int(health_bar_size[0] * self.health / self.max_health)
        pygame.draw.rect(screen, (0, 255, 0), (health_bar_location[0] - (health_bar_size[0]//2), health_bar_location[1] - health_bar_size[1] - 10, 
                                                bar_width, health_bar_size[1]))
        
        
        # Draw inventory
        inv_location = ((constants.GUI_WINDOW_SIZE[0] - self.inv_texture.get_width())//2, 20)
        temp_surface = pygame.Surface(constants.GUI_WINDOW_SIZE, pygame.SRCALPHA) 
        temp_surface.blit(self.inv_texture, inv_location)
        
        # Draw selected square 
        screen.blit(temp_surface, (0,0))
        if self.holding_main_hand:
            temp_surface.blit(self.selected_inv_texture, (inv_location[0] + 3, inv_location[1] + (constants.INV_ITEM_SIZE[1] * 4)))
        else:
            temp_surface.blit(self.selected_inv_texture, (inv_location[0] - 3 + (constants.INV_ITEM_SIZE[0] * 2), inv_location[1] + (constants.INV_ITEM_SIZE[1] * 4)))
        screen.blit(temp_surface, (0,0))
        
        # Manually draw lower two items since order is odd
        if self.inventory[0] != None:
            self.inventory[0].draw_inv(screen, (inv_location[0], inv_location[1] + (4*constants.INV_ITEM_SIZE[1])))
        if self.inventory[1] != None:
            self.inventory[1].draw_inv(screen, (inv_location[0] + (2*constants.INV_ITEM_SIZE[0]), inv_location[1] + (4*constants.INV_ITEM_SIZE[1])))
        
        # Draw rest of inventory
        for row in range(4):
            for item in range(3):
                item_i = 2 + (row * 3) + item
                if self.inventory[item_i] != None:
                    self.inventory[item_i].draw_inv(screen, (inv_location[0] + (item*constants.INV_ITEM_SIZE[0]), inv_location[1] + (row*constants.INV_ITEM_SIZE[1])))
        
        # Draw lives
        temp_surface = pygame.Surface([self.lives * (constants.LIVES_SIZE[0] + 15), constants.LIVES_SIZE[1]], pygame.SRCALPHA) 
        for life in range(self.lives):
            temp_surface.blit(self.lives_texture, [life * (constants.LIVES_SIZE[0] + 15), 0])
        screen.blit(temp_surface, [53, 545])
            
        return screen
    
    def initiate_assets(self, constants):
        self.assets = {}
        # Get sprite-sheet
        master_texture = pygame.image.load(constants.FILE_PATH + "project_lib/assets/player/main.png").convert() # Use text input button design
        images = []
        # Split sprite-sheet into 2d array of images
        for row in range(master_texture.get_height()//48):
            row_textures = []
            for image in range(master_texture.get_width()//48):
                texture_surface = pygame.Surface((48, 48))
                texture_surface.blit(master_texture, (0, 0), (48*image, 48*row, 48, 48))
                row_textures.append(texture_surface)
            images.append(row_textures)
            
        # Extract animations manually from images array

        # Direct animations
        self.assets["idle_up"] = images[1][:8]
        self.assets["idle_down"] = images[0][:8]
        self.assets["run_up"] = images[3][:6]
        self.assets["run_down"] = images[2][:6]
        
        self.assets["attack_right"] = images[2][6:9]
        self.assets["attack_down"] = images[3][6:9]
        self.assets["attack_up"] = images[4][6:9]
        
        self.assets["push_right"] = images[4][:6]
        self.assets["pull_left"] = images[5][:6]
        
        self.assets["take_damage"] = images[5][6:9]
        
        self.assets["push_up"] = images[6][:4]
        self.assets["pull_up"] = images[7][:4]
        self.assets["pull_down"] = images[6][4:9]
        self.assets["push_down"] = images[7][4:9]
        
        self.assets["death"] = images[8][:5]
        self.assets["fall"] = images[9][:5]
        
        # Animations derived from existing ones
        self.assets["idle_left"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["idle_down"]] # this line of code returns a flipped version of every frame of the animation
        self.assets["run_left"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["run_down"]]
        self.assets["attack_left"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["attack_right"]]
        self.assets["push_left"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["push_right"]]
        
        self.assets["idle_right"] = self.assets["idle_down"]
        self.assets["run_right"] = self.assets["run_down"]
        self.assets["pull_right"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["pull_left"]]

        # SPACE TO ADD MORE ANIMATIONS




File: projects/final/classes/entity.py
import pygame
from functions.algorithms.aoeScanner import aoeScanner

class Entity:
    def __init__(self, x, y, type, room_loc, drops):
        # Constants
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        # Set attributes

        self.initiate_assets(type, constants)
        
        self.type = type
        self.state = "idle"
        self.direction = "down"
        
        # Calculate screen coordinates from grid coordinates
        self.x_pos = (x * constants.SQUARE_SIZE[0]) + room_loc[0] - 50
        self.y_pos = (y * constants.SQUARE_SIZE[1]) + room_loc[1] - 60
        
        self.movement_vector = [0,0]
        self.speed = 2
        self.size = (150,150)
        self.animation_frame_time = 0.1
        self.animation_cooldown = 0
        self.max_health = 5
        self.health = self.max_health
        self.mele_reach = 60
        self.attack_damage = 3
        self.attack_timer = 0
        self.team = None
        
        
        self.collision_box = {"size": (48, 25),
                            "location": [(self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 40 + self.y_pos]}
        
        # Turns screen coordinates back to grid coordinates when necessary
        self.get_square = lambda room : [int((self.collision_box["location"][0] - room.location[0])//constants.SQUARE_SIZE[0]),
                                        int((self.collision_box["location"][1] - room.location[1])//constants.SQUARE_SIZE[1])]
        
        # possible states: idle, run, sprint, boost, push, pull, attack, take_damage, death, fall
        self.change_state("spawn")
        
        # Precalculate entity drops to save memory
        self.drops = self.calculate_drops(drops)
        
        
    def move(self, destination, room_data, crates, doors, forced = False):
        # Path can either be algorithmic path to player, or path to random local location if entity is idle
        # CALCULATE MOVEMENT VECTOR
        if not forced:
            # Find vector of entity speed going towards destination
            from functions.algorithms.getMovementVector import get_movement_vector
            self.movement_vector = get_movement_vector(self.speed, [destination[0] - self.collision_box["location"][0],  destination[1] - self.collision_box["location"][1]])
        else:
            # Teleports entity to destination if necessary
            self.movement_vector = destination
            
        from functions.algorithms.collision_detection import is_colliding, collision
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        can_move = [False, False]
        self.collision_box["location"] = [(self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 23 + self.y_pos]
        
        
        # Do all X checks
        projected_collision_box = {
            "size": self.collision_box["size"],
            "location": [self.collision_box["location"][0] + self.movement_vector[0], self.collision_box["location"][1]]
        }
        
        # Check squares
        if not is_colliding(projected_collision_box, room_data.layout, room_data.location, constants.SQUARE_SIZE):
            can_move[0] = True
            
        # Check doors
        for door in doors:
            if collision([*projected_collision_box["location"], *projected_collision_box["size"]], [*door.collision_box["location"], *door.collision_box["size"]]):
                can_move[0] = False
        
        # Check crates
        for crate in crates:
            if collision([*projected_collision_box["location"], *projected_collision_box["size"]], [*crate.collision_box["location"], *crate.collision_box["size"]]):
                can_move[0] = False
                break
            
            
        # Do all Y checks
        projected_collision_box = {
            "size": self.collision_box["size"],
            "location": [self.collision_box["location"][0], self.collision_box["location"][1] + self.movement_vector[1]]
        }
        
        # Check squares
        if not is_colliding(projected_collision_box, room_data.layout, room_data.location, constants.SQUARE_SIZE):
            can_move[1] = True
        
        # Check doors
        for door in doors:
            if collision([*projected_collision_box["location"], *projected_collision_box["size"]], [*door.collision_box["location"], *door.collision_box["size"]]):
                can_move[1] = False
                
        # Check crates
        for crate in crates:
            if collision([*projected_collision_box["location"], *projected_collision_box["size"]], [*crate.collision_box["location"], *crate.collision_box["size"]]):
                can_move[1] = False
                break
        
        # Do possible movements
        if can_move[0] and can_move[1]:
            self.x_pos += self.movement_vector[0]
            self.y_pos += self.movement_vector[1]
        
        # If only one direction is possible, walk in that direction at normal speed so that entity 
        # doesn't look like it is rubbing on wall. Makes movement look more intentional.
        elif can_move[0]: 
            self.x_pos += (self.movement_vector[0]//abs(self.movement_vector[0])) * self.speed
        elif can_move[1]:
            self.y_pos += (self.movement_vector[1]//abs(self.movement_vector[1])) * self.speed
        
        # calculate animation state change
        if self.movement_vector == [0,0] and not self.state == "idle":
            self.change_state("idle")
        elif self.movement_vector != [0,0] and not self.state == "run":
            self.change_state("run")
                
        self.check_direction()
                
        # Update collision box
        self.collision_box["location"] = [(self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 23 + self.y_pos]
        
    def push(self, direction, speed, room, crates, doors):
        # Very similar to crate pushing function
        from functions.algorithms.collision_detection import is_colliding, collision
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        # Pre-make move
        if direction == "left":
            self.collision_box["location"][0] -= speed
        elif direction == "right":
            self.collision_box["location"][0] += speed
        elif direction == "up":
            self.collision_box["location"][1] -= speed
        elif direction == "down":
            self.collision_box["location"][1] += speed
        
        # Check square collisions
        colliding = is_colliding(self.collision_box, room.layout, room.location, constants.SQUARE_SIZE)
        
        # Check door collisions
        if not colliding:
            for door in doors:
                if collision([*self.collision_box["location"], *self.collision_box["size"]], [*door.collision_box["location"], *door.collision_box["size"]]):
                    colliding = True
                    break
        
        # Check crate collisions
        if not colliding:
            hit_crate = False
            for crate in crates:
                if collision([*self.collision_box["location"], *self.collision_box["size"]], 
                            [*crate.collision_box["location"], *crate.collision_box["size"]]):
                    hit_crate = True
                    colliding = True
                    
            # Update movement
            if not hit_crate:
                if direction == "left" or direction == "right":
                    self.x_pos += speed * (-1 if direction == "left" else 1)
                else:
                    self.y_pos += speed * (-1 if direction == "up" else 1)
            
        # Update collision box
        self.collision_box["location"] = [(self.size[0]-48)//2 + self.x_pos, (self.size[1]-20)//2 + 23 + self.y_pos]
        
        return not colliding # can move
    
    def change_state(self, new_state):
        # Set state to new state, as well as resetting animation frame so that animation starts from start
        self.state = new_state
        self.animation_frame = 0
    
    def check_direction(self):
        # Calculates direction based on movement vector
        if self.movement_vector != [0,0]:
            if self.movement_vector[0] == 0:
                if self.movement_vector[1] < 0:
                    self.direction = "up"
                else:
                    self.direction = "down"
            if self.movement_vector[0] < 0:
                self.direction = "left"
            elif self.movement_vector[0] > 0:
                self.direction = "right"
                
                
    def attack(self, player, entities, room):
        from functions.algorithms.getMovementVector import get_movement_vector
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        # Initiate attack animation
        self.change_state("attack")
        self.attack_timer = 3
        
        # Calculate lists of all effected squares and entities based on attack range
        range_vector = get_movement_vector(self.mele_reach, self.movement_vector)
        attack_loc = [(self.collision_box["location"][0] + (self.collision_box["size"][0]//2)) + range_vector[0],
                        (self.collision_box["location"][1] + (self.collision_box["size"][1]//2)) + range_vector[1]]
        effectedEntities, effectedSquares, playerEffected = aoeScanner(attack_loc, entities, room, player, self.mele_reach, constants)
        
        
        # Attack player if player effected
        if playerEffected and (self.team != player.team):
            player.take_damage(self.attack_damage)
            
        # Attack entities if they are effected
        for entity in effectedEntities:
            if entity.team != self.team:
                entity.take_damage(self.attack_damage)
        
    def take_damage(self, damage):
        # Set animation
        self.change_state("take_damage")
        # Reduce health and check for deaths
        self.health -= damage
        if self.health <= 0:
            self.die()
            return True, self.drops # If died, tell player so that object can be removed from list and killed. Also return drops
        return False, []
            
    def die(self):
        # Start dying animation
        if self.state != "death":
            self.change_state("death")
            
    def calculate_drops(self, drops):
        from random import randint
        out_drops = []
        for set in drops: # for every seperate set of rolls
            set_drops = []
            for item in set["drops"]: # Go through each item in that set
                for instance in range(item["chance"]):
                    payload = {}
                    if "payload" in item:
                        payload = item["payload"]
                    set_drops.append({"item": item["item"], "payload": payload}) # makes one long array with all possible choices according to weights
                    
            while len(set_drops) < set["total"]:
                set_drops.append(None) # complete list with empty drops to complete length
                    
            for roll in range(set["rolls"]):
                # For each roll of each set, add a random item from full drops list.
                out_drops.append(set_drops[randint(0, set["total"]-1)])
        
        return out_drops
            
            
    def save(self, room_loc):
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        data = {
            "name": self.type,
            "x": (self.x_pos + 50 - room_loc[0]) / constants.SQUARE_SIZE[0],
            "y": (self.y_pos + 60 - room_loc[1]) / constants.SQUARE_SIZE[1],
            "health": self.health
            }
        return data
        
    def get_rendering_row(self):
        return self.collision_box["location"][1]
        
    def draw(self, screen):
        from classes.global_data import constants_structure, draw_text
        constants = constants_structure()
        
        FPS = constants.MENU_FPS * 2
        
        if (self.state == "idle" or
            self.state == "run" or
            self.state == "push" or
            self.state == "pull" or
            self.state == "attack"):
            # Get animation name for directional animations
            animation = self.state + "_" + self.direction
            
        else:
            # Get animation name for non-directional animations
            animation = self.state
            
        
        # Choose asset based on animation and current frame
        self.chosen_asset = self.assets[animation][self.animation_frame]
        
        # Draw asset to screen
        temp_surface = pygame.Surface(self.size, pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        temp_surface.blit(pygame.transform.scale(self.chosen_asset, self.size),(0,0))
        screen.blit(temp_surface, (self.x_pos, self.y_pos))
        
        
        # Update animation frame
        self.animation_cooldown += 1
    
        if self.animation_cooldown >= FPS // (1/self.animation_frame_time):
            self.animation_cooldown = 0
            self.animation_frame += 1
        
        if self.animation_frame == len(self.assets[animation]):
            self.animation_frame = 0
        
        
        # Code to draw collision box for development purposes:
        # temp_surface = pygame.Surface(self.size, pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        # pygame.draw.rect(temp_surface, (255, 0, 0, 127), (0, 0, *self.collision_box["size"]))
        # screen.blit(temp_surface, self.collision_box["location"])
        
        
        # Draw health bar if necessary
        if self.health != self.max_health:
            health_bar_location = [self.collision_box["location"][0] + (self.collision_box["size"][0]//2), self.collision_box["location"][1] + self.collision_box["size"][1] + 10]
            health_bar_size = [self.collision_box["size"][0], 5]
            # Black background
            pygame.draw.rect(screen, (0, 0, 0), (health_bar_location[0] - (health_bar_size[0]//2), health_bar_location[1] - health_bar_size[1] - 10, *health_bar_size))
            # Green fill
            bar_width = int(health_bar_size[0] * self.health / self.max_health)
            pygame.draw.rect(screen, (0, 255, 0), (health_bar_location[0] - (health_bar_size[0]//2), health_bar_location[1] - health_bar_size[1] - 10, 
                                                    bar_width, health_bar_size[1]))
        
        return screen
    
    def initiate_assets(self, type, constants):
        self.assets = {}
        
        # Get sprite-sheet
        master_texture = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/entities/{type}.png").convert() # Use text input button design
        images = []
        
        # Extract each seperate image from sprite sheet into 2D array
        for row in range(master_texture.get_height()//48):
            row_textures = []
            for image in range(master_texture.get_width()//48):
                texture_surface = pygame.Surface((48, 48))
                texture_surface.blit(master_texture, (0, 0), (48*image, 48*row, 48, 48))
                row_textures.append(texture_surface)
            images.append(row_textures)
            
            
        # Extract animations manually from images array

        # Direct animations
        self.assets["idle_up"] = images[1][:8]
        self.assets["idle_down"] = images[0][:8]
        self.assets["run_up"] = images[3][:6]
        self.assets["run_down"] = images[2][:6]
        
        self.assets["attack_right"] = images[2][6:9]
        self.assets["attack_down"] = images[3][6:9]
        self.assets["attack_up"] = images[4][6:9]
        
        self.assets["push_right"] = images[4][:6]
        self.assets["pull_left"] = images[5][:6]
        
        self.assets["take_damage"] = images[5][6:9]
        
        self.assets["push_up"] = images[6][:4]
        self.assets["pull_up"] = images[7][:4]
        self.assets["pull_down"] = images[6][4:9]
        self.assets["push_down"] = images[7][4:9]
        
        self.assets["death"] = images[8][:5]
        self.assets["fall"] = images[9][:5]
        
        # Animations derived from existing ones
        self.assets["idle_left"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["idle_down"]] # this line of code returns a flipped version of every frame of the animation
        self.assets["run_left"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["run_down"]]
        self.assets["attack_left"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["attack_right"]]
        self.assets["push_left"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["push_right"]]
        
        self.assets["idle_right"] = self.assets["idle_down"]
        self.assets["run_right"] = self.assets["run_down"]
        self.assets["pull_right"] = [pygame.transform.flip(texture, True, False) for texture in self.assets["pull_left"]]

        self.assets["spawn"] = images[8][:5]
        self.assets["spawn"].reverse()
        
        # SPACE FOR MORE ANIMATIONS IF NEEDED




File: projects/final/classes/square.py
import copy
import pygame

class Square: # Square parent class
    def __init__(self, square, default, file_path, square_size, location, grid_loc):
        # Set data to be default and then update parts that appear in square specific data
        self.data = copy.deepcopy(default)
        for data in square:
            self.data[data] = square[data]
        
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        # Set all attributes from data
        
        self.id = self.data["id"]
    
        self.collidable = self.data["collidable"]
        self.breakable = self.data["breakable"]
        self.health = self.data["strength"]
        
        self.grid_loc = grid_loc
        
        self.location = location
        self.x_pos = location[0]
        self.width = int(self.data["collision_size"][0] * constants.SQUARE_SIZE[0])
        self.y_pos = location[1]
        self.height = int(self.data["collision_size"][1] * constants.SQUARE_SIZE[1])
        
        # Calculate screen coordinates from grid coordinates
        self.collision_x = ((constants.SQUARE_SIZE[0] - self.width)//2) + self.x_pos
        self.collision_y = ((constants.SQUARE_SIZE[1] - self.height)//2) + self.y_pos
        
        # Load textures
        texture_names = self.data["textures"]
        self.textures = [pygame.transform.scale(pygame.image.load(file_path + f"project_lib/assets/squares/{texture_name}.png").convert(), square_size) for texture_name in texture_names]
        self.texture_pos = [constants.SQUARE_SIZE[0] * self.data["texture_pos"][0], constants.SQUARE_SIZE[1] * self.data["texture_pos"][1]]
    
    def get_rendering_row(self):
        return self.y_pos

    def draw(self, screen):
        if self.data["transparent"]:
            # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
            temp_surface = pygame.Surface([self.textures[0].get_width(), self.textures[0].get_height()], pygame.SRCALPHA) 
            temp_surface.blit(self.textures[0],(0,0))
            screen.blit(temp_surface, (self.x_pos + self.texture_pos[0], self.y_pos + self.texture_pos[1]))
        else:
            # Only rendering asset 0 for now, since there are no animations for squares yet. This will be updated when there are
            screen.blit(self.textures[0], (self.x_pos + self.texture_pos[0], self.y_pos + self.texture_pos[1])) 
        
        return screen
    
    def calculate_drops(self):
        from random import randint
        drops = []
        for set in self.data["drops"]: # For every seperate set of rolls
            set_drops = []
            for item in set["drops"]:
                for instance in range(item["chance"]):
                    payload = {}
                    if "payload" in item:
                        payload = item["payload"]
                    set_drops.append({"item": item["item"], "payload": payload}) # Add weighted number of items to list
            while len(set_drops) < set["total"]:
                set_drops.append(None) # Complete list to total length
                    
            for roll in range(set["rolls"]): # Do each roll for each set
                drops.append(set_drops[randint(0, set["total"]-1)]) 
        return drops
    
    def take_damage(self, damage, room):
        self.health -= damage
        drops = []
        if self.health <= 0: # Check for death
            drops = self.destroy(room)
        return drops
    
    def destroy(self, room):
        import json
        from classes.square import Square
        from classes.global_data import constants_structure
        constants = constants_structure()
        # Get square data
        squares_data = json.load(open(constants.FILE_PATH + "data/squares/squares_data.json", "r"))
        default_square = json.load(open(constants.FILE_PATH + "data/squares/default_square.json", "r"))
        
        drops = []
        # Calculate drops
        if self.data["has_drops"]:
            drops = self.calculate_drops()
        
        # Replace self with empty square
        room.layout[self.grid_loc[1]][self.grid_loc[0]] = Square(squares_data[0], default_square, constants.FILE_PATH, constants.SQUARE_SIZE, self.location, self.grid_loc)
        
        return drops
    
    def save(self):
        return self.id # Default square save data is just the ID of the square




File: projects/final/classes/item.py
import pygame

class Item: # Item parent class
    def __init__(self, type, payload=None):
        # Set all default multipliers
        # Armour
        self.speed_multiplier = 1
        self.mele_armour_multiplier = 1
        self.ranged_armour_multiplier = 1
        # Mele
        self.damage_multiplier = 1
        self.attack_speed_multiplier = 1
        self.mele_range_multiplier = 1
        # Ranged
        self.ranged_reload_multiplier = 1
        # Charms
        self.max_health_multiplier = 1
        
        # Regen_speed is how much is added every tick to the regen speed timer (when timer 
        # is more than 1, it adds 1 health and resets to 0). Items do not add regen by 
        # default. Only works for charms
        self.regen_speed = 0 
        
        self.stamina_recharge_multiplier = 1
        
        
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        # Set other general attributes
        self.sort = "generic" # sort defines what slots item can be placed in
        self.type = type
        self.payload = payload
        # Load textures
        self.game_texture = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/items/{type}.png").convert()
        self.inv_texture = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/items/{type}.png").convert()
        
    
    def draw_inv(self, screen, location):
        
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        temp_surface = pygame.Surface(constants.INV_ITEM_SIZE, pygame.SRCALPHA)
        temp_surface.blit(pygame.transform.scale(self.inv_texture, (constants.INV_ITEM_SIZE[0] - 24, constants.INV_ITEM_SIZE[1] - 24)),(12,12))
        screen.blit(temp_surface, location)
        
        return screen
        
        
    def save(self):
        return {
            "item": self.type, 
            "payload": None
            }




File: projects/final/classes/room.py
import json
import pygame

class Room:
    def __init__(self, data, level, game_data):
        # Import all necessary squares
        from classes.square import Square
        from classes.special_squares.door import Door
        from classes.special_squares.mechanical_door import MechanicalDoor
        from classes.special_squares.objective_door import ObjectiveDoor
        from classes.entities.moveable_squares.crate import Crate
        from classes.special_squares.button import Button
        from classes.special_squares.lever import Lever
        from classes.special_squares.ladder import Ladder
        from classes.special_squares.keyhole_wall import Keyhole
        
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        # Set up attributes
        self.account_id = game_data["account_id"]
        self.savegame_id = game_data["savegame_id"]
        
        self.level = level
        
        self.kills = 0
        
        # SQUARES
        
        # Create lists
        self.layout = []
        self.doors = []
        self.crates = []
        self.buttons = []
        self.levers = []
        self.ladder = None
        
        # Load square data files
        squares_data = json.load(open(constants.FILE_PATH + "data/squares/squares_data.json", "r"))
        default_square = json.load(open(constants.FILE_PATH + "data/squares/default_square.json", "r"))
        
        # Define room size and location
        self.size = [len(data["squares"][0]) * constants.SQUARE_SIZE[0], len(data["squares"]) * constants.SQUARE_SIZE[1]]
        self.location = ((constants.GAME_WINDOW_SIZE[0] - self.size[0]) // 2, (constants.GAME_WINDOW_SIZE[1] - self.size[1]) // 2) 
        
        # Traverse 2D array
        for y, row in enumerate(data["squares"]):
            new_row = [None for i in range(len(row))]
            for x, square in enumerate(row): 
                # For every square
                square_int = False
                if isinstance(square, int): 
                    square_int = True
                if square_int  and  squares_data[square]["basic"]: # If the square is just an ID and the square is basic, load that ID as a basic square
                    size = constants.SQUARE_SIZE
                    if "size" in squares_data[square]:
                        size = [constants.SQUARE_SIZE[0] * squares_data[square]["size"][0], constants.SQUARE_SIZE[1] * squares_data[square]["size"][1]]
                    new_row[x] = Square(squares_data[square], default_square, constants.FILE_PATH, size, [self.location[0] + (x * constants.SQUARE_SIZE[0]), self.location[1] + (y * constants.SQUARE_SIZE[1])], [x,y])
                
                # If the square is not basic, load differently
                else:
                    if isinstance(square, int): # for just IDs
                        square_name = squares_data[square]["name"]
                    else: # for squares with data
                        square_name = (squares_data[square["id"]]["name"])
                    
                    # Check every type of non-basic square
                    # Check for doors
                    if square_name.endswith("door"):
                        # Create empty space at that coordinate on grid
                        new_row[x] = Square(squares_data[0], default_square, constants.FILE_PATH, constants.SQUARE_SIZE, [self.location[0] + (x * constants.SQUARE_SIZE[0]), self.location[1] + (y * constants.SQUARE_SIZE[1])], [x,y])
                        # Extract data for door positioning
                        if square["pos"][1] == "t":
                            corner = "top_"
                        else:
                            corner = "bottom_"
                        if square["pos"][2] == "l":
                            corner += "left"
                        else:
                            corner += "right"
                        
                        # Generate door object depending on type
                        if square_name.startswith("mechanical"):
                            self.doors.append(MechanicalDoor(x, y, corner, square["pos"][0], self.location, square["colour"], is_open=(square["open"] if "open" in square else False)))
                        elif square_name.startswith("keyhole"):
                            self.doors.append(MechanicalDoor(x, y, corner, square["pos"][0], self.location, square["colour"], "keyhole", is_open=(square["open"] if "open" in square else False)))
                        else:
                            self.doors.append(Door(x, y, corner, square["pos"][0], self.location))
                    
                    # Check for buttons
                    elif square_name.startswith("button"):
                        # Create empty space at that coordinate on grid
                        new_row[x] = Square(squares_data[0], default_square, constants.FILE_PATH, constants.SQUARE_SIZE, [self.location[0] + (x * constants.SQUARE_SIZE[0]), self.location[1] + (y * constants.SQUARE_SIZE[1])], [x,y])
                        # Add the button
                        self.buttons.append(Button(square["colour"], (x,y), self.location))
                    
                    # Check for levers
                    elif square_name.startswith("lever"):
                        # Create empty space at that coordinate on grid
                        new_row[x] = Square(squares_data[0], default_square, constants.FILE_PATH, constants.SQUARE_SIZE, [self.location[0] + (x * constants.SQUARE_SIZE[0]), self.location[1] + (y * constants.SQUARE_SIZE[1])], [x,y])
                        # Add the lever
                        flicked = False
                        if "flicked" in square:
                            flicked = square["flicked"]
                        self.levers.append(Lever(square["colour"], flicked, (x,y), self.location))
                    
                    # Check for crates
                    elif square_name == "crate":
                        # Create empty space at that coordinate on grid
                        new_row[x] = Square(squares_data[0], default_square, constants.FILE_PATH, constants.SQUARE_SIZE, [self.location[0] + (x * constants.SQUARE_SIZE[0]), self.location[1] + (y * constants.SQUARE_SIZE[1])], [x,y])
                        # Add crate
                        self.crates.append(Crate(x, y, self.location))
                    
                    # Check for ladder
                    elif square_name == "ladder":
                        # Create empty space at that coordinate on grid
                        new_row[x] = Square(squares_data[0], default_square, constants.FILE_PATH, constants.SQUARE_SIZE, [self.location[0] + (x * constants.SQUARE_SIZE[0]), self.location[1] + (y * constants.SQUARE_SIZE[1])], [x,y])
                        # Add ladder
                        self.ladder = Ladder(x, y, self.location)
                    
                    # Check for keyhole walls
                    elif square_name == "keyhole_wall":
                        # Create empty space at that coordinate on grid
                        new_row[x] = Keyhole(x, y, self.location, square["colour"])
                        # SPACE TO IMPLEMENT KEYHOLE WALLS IF I DEVELOP THEM LATER
                    
                    # SPACE TO ADD MORE SPECIAL SQUARES IF I DEVELOP THEM LATER
                        
            # Add row to grid
            self.layout.append(new_row)
            
        
        
        
        # ENTITIES
        
        from functions.algorithms.item_lookup import lookup as i_lookup
        from functions.algorithms.entity_lookup import lookup as e_lookup
        # Create entity lists
        self.entities = []
        self.living_items = []
        
        for entity in data["entities"]:
            entity_class = e_lookup(entity["name"]) # Lookup entity from ID
            # Check for crates
            if entity["name"] == "crate":
                self.crates.append(entity_class(entity["x"], entity["y"], self.location))
                continue
            # Check for living items
            elif entity["name"] == "item": 
                self.living_items.append(entity_class(entity["x"], entity["y"], i_lookup(entity["item"])(entity["payload"])))
                continue
            # Otherwise, generate general entity type (will work for any entities I choose to create later)
            # Calculate default stats
            health = -1
            if "health" in entity:
                health = entity["health"]
            drops = {}
            if "drops" in entity:
                drops = entity["drops"]
            # Create entity
            self.entities.append(entity_class(entity["x"], entity["y"], health, self.location, drops))
            
        # Set up active colours dict
        self.active_colours = {}
        for trigger in [*self.levers, *self.buttons]:
            self.active_colours[str(trigger.colour)] = False
            
        # Set up remaining attributes
        self.id = data["id"]
        self.objectives = data["doors"]
        
        
        
        # OBJECTIVES
        
        self.objective_doors = []
        self.objective_icons = []
        from classes.objective_icon import ObjectiveIndicator
        for objective in self.objectives:
            if self.objectives[objective] is not None:
                self.objective_icons.append(ObjectiveIndicator(objective, self.objectives[objective]))
                if not ("colour" in self.objectives[objective]):
                    self.objectives[objective]["colour"] = None
        
        # Pre-load non navigable air
        non_navigable_air = Square(squares_data[7], default_square, constants.FILE_PATH, constants.SQUARE_SIZE, [self.location[0] + (x * constants.SQUARE_SIZE[0]), self.location[1] + (y * constants.SQUARE_SIZE[1])], [x,y])
        
        # Set up objectives with coordinates depending on location
        if self.objectives["left"] is not None:
            self.layout[len(self.layout)//2-1][0] = non_navigable_air
            self.layout[len(self.layout)//2][0] = non_navigable_air
            if self.objectives["left"]["type"] != "empty":
                self.objective_doors.append(self.objective_door_generate(self.objectives["left"]["type"], 0, len(self.layout)//2-1, "top_right", "v", self.objectives["left"]["colour"], "left"))
                self.objective_doors.append(self.objective_door_generate(self.objectives["left"]["type"], 0, len(self.layout)//2, "bottom_right", "v", self.objectives["left"]["colour"], "left"))
            
        if self.objectives["right"] is not None:
            self.layout[len(self.layout)//2-1][len(self.layout[0])-1] = non_navigable_air
            self.layout[len(self.layout)//2][len(self.layout[0])-1] = non_navigable_air
            if self.objectives["right"]["type"] != "empty":
                self.objective_doors.append(self.objective_door_generate(self.objectives["right"]["type"], len(self.layout[0])-1, len(self.layout)//2-1, "top_left", "v", self.objectives["right"]["colour"], "right"))
                self.objective_doors.append(self.objective_door_generate(self.objectives["right"]["type"], len(self.layout[0])-1, len(self.layout)//2, "bottom_left", "v", self.objectives["right"]["colour"], "right"))
            
        if self.objectives["up"] is not None:
            self.layout[0][len(self.layout[0])//2-1] = non_navigable_air
            self.layout[0][len(self.layout[0])//2] = non_navigable_air
            if self.objectives["up"]["type"] != "empty":
                self.objective_doors.append(self.objective_door_generate(self.objectives["up"]["type"], len(self.layout[0])//2-1, 0, "bottom_left", "h", self.objectives["up"]["colour"], "up"))
                self.objective_doors.append(self.objective_door_generate(self.objectives["up"]["type"], len(self.layout[0])//2, 0, "bottom_right", "h", self.objectives["up"]["colour"], "up"))
            
        if self.objectives["down"] is not None:
            self.layout[len(self.layout)-1][len(self.layout[0])//2-1] = non_navigable_air
            self.layout[len(self.layout)-1][len(self.layout[0])//2] = non_navigable_air
            if self.objectives["down"]["type"] != "empty":
                self.objective_doors.append(self.objective_door_generate(self.objectives["down"]["type"], len(self.layout[0])//2-1, len(self.layout)-1, "top_left", "h", self.objectives["down"]["colour"], "down"))
                self.objective_doors.append(self.objective_door_generate(self.objectives["down"]["type"], len(self.layout[0])//2, len(self.layout)-1, "top_right", "h", self.objectives["down"]["colour"], "down"))
                
        # Add objectives and check individual progress
        for door in self.objective_doors:
            if self.objectives[door.side]["complete"]:
                door.open()
            elif self.objectives[door.side]["type"] == "empty":
                self.complete_objective(door.side)
    
    
    def objective_door_generate(self, objective_type, x, y, hinge_corner, starting_dir, colour=None, side = None):   
        # Pick the correct door for the objective depending on the objective type 
        if objective_type == "keyhole":
            from classes.special_squares.mechanical_door import MechanicalDoor
            return MechanicalDoor(x, y, hinge_corner, starting_dir, self.location, colour, "keyhole", side)
        elif objective_type == "powered":
            from classes.special_squares.mechanical_door import MechanicalDoor
            return MechanicalDoor(x, y, hinge_corner, starting_dir, self.location, colour, objective_side = side)
        else:
            from classes.special_squares.objective_door import ObjectiveDoor
            return ObjectiveDoor(x, y, hinge_corner, starting_dir, self.location, colour, side)
        
        
    def complete_objective(self, objective_side):
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        # Set objective to complete
        self.objectives[objective_side]["complete"] = True
        
        # Find the opposite side of the objective (for picking objective to complete in attached room)
        if objective_side == "left":
            objective_opposite = "right"
        elif objective_side == "right":
            objective_opposite = "left"
        elif objective_side == "up":
            objective_opposite = "down"
        else:
            objective_opposite = "up"
        
        # Load level mapping
        level_layout = json.load(open(constants.FILE_PATH + f"data/account_games/{self.account_id}_games/{self.savegame_id}_levels/rooms_{self.level}/layout.json", 'r'))
        
        # Find next room
        next_room_id = None
        for y, row in enumerate(level_layout):
            for x, item in enumerate(row):
                if item == self.id:
                    if objective_side == "left":
                        next_room_id = level_layout[y][x-1]
                    elif objective_side == "right":
                        next_room_id = level_layout[y][x+1]
                    elif objective_side == "up":
                        next_room_id = level_layout[y-1][x]
                    elif objective_side == "down":
                        next_room_id = level_layout[y+1][x]
                
        # Update next room
        with open(constants.FILE_PATH + f"data/account_games/{self.account_id}_games/{self.savegame_id}_levels/rooms_{self.level}/{next_room_id}.json", 'r') as file:
            data = json.load(file)
        data["doors"][objective_opposite]["complete"] = True
            
        with open(constants.FILE_PATH + f"data/account_games/{self.account_id}_games/{self.savegame_id}_levels/rooms_{self.level}/{next_room_id}.json", 'w') as file:
            json_string = json.dumps(data)
            file.write(json_string)
        
        # Open objective doors
        for door in self.objective_doors:
            if door.side == objective_side:
                door.open()
    
    def update(self, player):
        # Turn off all active colours so that they can be reassessed
        for colour in self.active_colours:
            self.active_colours[colour] = False
        
        # Check levers and buttons to update active colours
        for lever in self.levers:
            if lever.flicked:
                self.active_colours[str(lever.colour)] = True
        for button in self.buttons:
            if not button.state_up:
                self.active_colours[str(button.colour)] = True
                
        # Check all powered doors and update them if state changed
        for door in self.doors:
            if not door.manual and door.type == "button":
                if str(door.colour) in self.active_colours:
                    if self.active_colours[str(door.colour)]:
                        door.open()
                    else:
                        door.close()
                    
        
        # Check objectives
        for objective in self.objectives:
            if self.objectives[objective] is not None:
                if not self.objectives[objective]["complete"]: # Only check incomplete objectives to save time
                    # Kill count:
                    if self.objectives[objective]["type"] == "kill_count":
                        if player.kills >= self.objectives[objective]["num"]:
                            self.complete_objective(objective)
                    # Local kill count
                    elif self.objectives[objective]["type"] == "local_kill_count":
                        if self.kills >= self.objectives[objective]["num"]:
                            self.complete_objective(objective)
                    
                    # Powered
                    elif self.objectives[objective]["type"] == "powered":
                        if self.active_colours[str(self.objectives[objective]["colour"])]:
                            self.complete_objective(objective)
                    
                    # Keyhole objective is done elsewhere
                    
                    # SPACE TO ADD MORE OBJECTIVES
                
        
    
    def save(self):
        # Create base data
        data = {"id": self.id,
                "doors": self.objectives}
        
        # Collect data for basic squares
        squares = []
        for y, row in enumerate(self.layout):
            new_row = []
            for x, square in enumerate(row):
                new_row.append(square.save())
            squares.append(new_row)
            
        # Then add complex squares
        for lever in self.levers:
            squares[lever.grid_location[1]][lever.grid_location[0]] = lever.save()
        for button in self.buttons:
            squares[button.grid_location[1]][button.grid_location[0]] = button.save()
        for door in self.doors:
            squares[door.grid_location[1]][door.grid_location[0]] = door.save()
        if self.ladder is not None:
            squares[self.ladder.grid_coords[1]][self.ladder.grid_coords[0]] = 10
        
        data["squares"] = squares
        
        # Create entities list
        entities = []
        
        for entity in self.entities:
            entities.append(entity.save(self.location))
            
        for crate in self.crates: # Crates are saved as entities after being loaded since they will likely be not in grid locations anymore
            entities.append(crate.save(self.location))
            
        for item in self.living_items:
            entities.append(item.save(self.location))
        
        data["entities"] = entities
        
        
        from classes.global_data import constants_structure
        constants = constants_structure()
        # Log saving of file
        print("saving to: " + constants.FILE_PATH + f"data/account_games/{self.account_id}_games/{self.savegame_id}_levels/rooms_{self.level}/{self.id}.json")
        # Save file
        with open(constants.FILE_PATH + f"data/account_games/{self.account_id}_games/{self.savegame_id}_levels/rooms_{self.level}/{self.id}.json", 'w') as file:
            json_string = json.dumps(data)
            file.write(json_string)
    
    def get_rendering_list(self):
        # Create list of objects in order of Y position so that they can be rendered with a Z order
        rendering_list = []
        for row in self.layout:
            for item in row:
                rendering_list.append(item)
        rendering_list += [*self.buttons, *self.levers, *self.doors, *self.objective_doors, *self.entities, *self.living_items, *self.crates]
        if self.ladder is not None:
            rendering_list.append(self.ladder)
            
        return rendering_list
            
    
    def draw(self, screen, square_size, config):
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        # PLACE TO ADD CODE FOR CONNECTED TEXTURES
        
        # Draw tunnels
        tunnel = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/menu/tunnel_h.png").convert(), (square_size[0] * 3, square_size[1] * 4.5))
        if self.objectives["right"] is not None:
            screen.blit(tunnel, (self.location[0] + self.size[0], (constants.GAME_WINDOW_SIZE[1] - tunnel.get_height())//2 - (constants.SQUARE_SIZE[1]//4)))
        if self.objectives["left"] is not None:
            screen.blit(tunnel, (self.location[0] - tunnel.get_width(), (constants.GAME_WINDOW_SIZE[1] - tunnel.get_height())//2 - (constants.SQUARE_SIZE[1]//4)))
            
        tunnel = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/menu/tunnel_v.png").convert(), (square_size[0] * 4, square_size[1] * 3.5))
        if self.objectives["up"] is not None:
            screen.blit(tunnel, ((constants.GAME_WINDOW_SIZE[0] - tunnel.get_width())//2,  self.location[1] - tunnel.get_height()))
        # Draw bottom tunnel last so that it sits over other squares
        
        # Draw floor
        for y, row in enumerate(self.layout):
            for x, square in enumerate(row):
                texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/squares/ground.png").convert(), square_size)
                screen.blit(texture, (self.location[0] + (square_size[0] * x), self.location[1] + (square_size[1] * y)))
        
        
        # Draw squares
        for y, row in enumerate(self.layout):
            for x, square in enumerate(row):
                screen = square.draw(screen)

        # Special squares are all drawn by seperate rendering function in main game loop later
        
        return screen
    
    def draw_over(self, screen, square_size):
        # Draw the bottom tunnel after the rest of the game window is drawn
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        tunnel = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/menu/tunnel_v.png").convert(), (square_size[0] * 4, square_size[1] * 3.5))
        
        if self.objectives["down"] is not None:
            screen.blit(tunnel, ((constants.GAME_WINDOW_SIZE[0] - tunnel.get_width())//2,  self.location[1] + self.size[1] - (constants.SQUARE_SIZE[1]//2)))

        # Space to draw new overlaying objects if necessary

        return screen
    
    def draw_icons(self, screen, player):
        
        # Draw all objective icons
        for icon in self.objective_icons:
            text = ""
            
            if self.objectives[icon.side]["type"] == "kill_count":
                text = f"{min(self.objectives[icon.side]['num'], player.kills)}/{self.objectives[icon.side]['num']}"
                
            elif self.objectives[icon.side]["type"] == "local_kill_count":
                text = f"{min(self.objectives[icon.side]['num'], self.kills)}/{self.objectives[icon.side]['num']}"
                
            elif self.objectives[icon.side]["type"] == "keyhole":
                text = "LOCKED"
                if self.objectives[icon.side]["complete"]:
                    text = "UNLOCKED"
                    
            elif self.objectives[icon.side]["type"] == "powered":
                text = "OFF"
                if self.objectives[icon.side]["complete"]:
                    text = "ON"
            # SPACE TO DRAW NEW OBJECTIVES
                
            screen = icon.draw(screen, text)
        return screen




File: projects/final/classes/special_squares/keyhole_wall.py
import pygame

# KEYHOLE WALL IS CURRENTLY UNUSED SINCE I DECIDED AFTER MAKING IT THAT IT WAS UNNECESSARY
# MAY BE IMPEMENTED IN THE FUTURE IF I FIND A GOOD USE FOR IT
class Keyhole:
    def __init__(self, x, y, room_loc, colour):
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        # Set all coordinates and attributes (coordinates come in grid coordinates, so pre-calculate screen coordinates)
        self.grid_pos = [x,y]
        self.x_pos = (constants.SQUARE_SIZE[0] * x) + room_loc[0]
        self.y_pos = (constants.SQUARE_SIZE[1] * y) + room_loc[1]
        self.collision_x = self.x_pos
        self.collision_y = self.y_pos
        
        self.width = constants.SQUARE_SIZE[0]
        self.height = constants.SQUARE_SIZE[1]
        
        self.colour = colour
        self.collidable = True
        self.breakable = False
        
        
        # Generate texture with colours
        base = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/rock.png").convert()
        temp_surface = pygame.Surface((base.get_width(), base.get_height()), pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        temp_surface.blit(base, (0,0))
        self.texture = temp_surface
        
        temp_surface = pygame.Surface((self.texture.get_width(), self.texture.get_height()), pygame.SRCALPHA)
        temp_surface.blit(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/keyhole_wall.png").convert(), (0,0))
        temp_surface.fill(colour, special_flags=pygame.BLEND_MULT)
        self.texture.blit(temp_surface, (0,0)) 
        
        self.texture = pygame.transform.scale(self.texture, (constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 1.5))
        
        self.draw_loc = [0, -0.5 * constants.SQUARE_SIZE[1]]
        
        
    def save(self):
        return {"id": 12,
                "colour": self.colour}
        
    def get_rendering_row(self):
        return self.y_pos
        
    def draw(self, screen):
        
        temp_surface = pygame.Surface((self.texture.get_width(), self.texture.get_height()), pygame.SRCALPHA)
        temp_surface.blit(self.texture, (0,0))
        
        screen.blit(temp_surface, (self.x_pos + self.draw_loc[0], self.y_pos + self.draw_loc[1]))
        
        return screen




File: projects/final/classes/special_squares/lever.py
import pygame

class Lever:
    def __init__(self, colour, flicked, location, room_loc):
        from classes.global_data import constants_structure;
        constants = constants_structure()
        
        self.textures = {}
        
        # Generate both textures with colour
        for texture in ["flicked", "unflicked"]:
            base = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/plain_lever_{texture}.png").convert()
            temp_surface = pygame.Surface((base.get_width(), base.get_height()), pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
            temp_surface.blit(base, (0,0))
            temp_surface.fill(colour, special_flags=pygame.BLEND_MULT)
            self.textures[texture] = temp_surface
            temp_surface = pygame.Surface((base.get_width(), base.get_height()), pygame.SRCALPHA)
            temp_surface.blit(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/plain_lever_{texture}_rim.png").convert(), (0,0))
            self.textures[texture].blit(temp_surface, (0,0)) 

        
        # Location comes as grid coordinate, so pre-calculate screen coordinates
        self.grid_location = location
        self.x_pos = (location[0] * constants.SQUARE_SIZE[0]) + room_loc[0]
        self.y_pos = (location[1] * constants.SQUARE_SIZE[1]) + room_loc[1]
        self.collision_box = {"size": (constants.SQUARE_SIZE[0] * 0.9, constants.SQUARE_SIZE[1] * 0.9),
                            "location": [self.x_pos + constants.SQUARE_SIZE[0] * 0.05, self.y_pos + constants.SQUARE_SIZE[1] * 0.05]}
        
        # Set other attributes
        self.colour = colour
        self.flicked = flicked
        
    
    def save(self):
        data = {"id": 6,
                "colour": self.colour,
                "flicked": self.flicked}
        return data
    
    def get_rendering_row(self):
        return self.y_pos
    
    def draw(self, screen):
        from classes.global_data import constants_structure;
        constants = constants_structure()
        
        # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        temp_surface = pygame.Surface(constants.SQUARE_SIZE, pygame.SRCALPHA) 
        
        # Draw depending on state
        if self.flicked:
            temp_surface.blit(pygame.transform.scale(self.textures["flicked"], constants.SQUARE_SIZE),(0,0))
        else:
            temp_surface.blit(pygame.transform.scale(self.textures["unflicked"], constants.SQUARE_SIZE),(0,0))
        
        screen.blit(temp_surface, (self.x_pos, self.y_pos))
        
        return screen




File: projects/final/classes/special_squares/button.py
import pygame

class Button:
    def __init__(self, colour, location, room_loc):
        from classes.global_data import constants_structure;
        constants = constants_structure()
        
        self.textures = {}
        
        # Add pressed and unpressed textures
        for texture in ["up", "down"]:
            base = pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/plain_button_{texture}.png").convert()
            temp_surface = pygame.Surface((base.get_width(), base.get_height()), pygame.SRCALPHA) # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
            temp_surface.blit(base, (0,0))
            temp_surface.fill(colour, special_flags=pygame.BLEND_MULT)
            self.textures[texture] = temp_surface
            temp_surface = pygame.Surface((base.get_width(), base.get_height()), pygame.SRCALPHA)
            temp_surface.blit(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/plain_button_{texture}_rim.png").convert(), (0,0))
            self.textures[texture].blit(temp_surface, (0,0)) 
        
        # Location comes as grid coordinate, so translate it to screen coordinate
        self.grid_location = location
        self.x_pos = (location[0] * constants.SQUARE_SIZE[0]) + room_loc[0]
        self.y_pos = (location[1] * constants.SQUARE_SIZE[1]) + room_loc[1]
        self.collision_box = {"size": (constants.SQUARE_SIZE[0] * 0.9, constants.SQUARE_SIZE[1] * 0.9),
                            "location": [self.x_pos + constants.SQUARE_SIZE[0] * 0.05, self.y_pos + constants.SQUARE_SIZE[1] * 0.05]}
        
        # Set attributes
        self.colour = colour
        self.state_up = True
        
        
    def update(self, player_collision_box, crates, enemies): # Runs every tick
        from functions.algorithms.collision_detection import collision
        self.state_up = True
        
        # Check if player is pressing it
        if collision([*player_collision_box["location"], *player_collision_box["size"]], [*self.collision_box["location"], *self.collision_box["size"]]):
            self.state_up = False
        else:
            for crate in crates: # Check if crate is pressing it
                if collision([*crate.collision_box["location"], *crate.collision_box["size"]], [*self.collision_box["location"], *self.collision_box["size"]]):
                    self.state_up = False
                    break
            if self.state_up == True:
                for enemy in enemies: # Check if entity is pressing it
                    if collision([*enemy.collision_box["location"], *enemy.collision_box["size"]], [*self.collision_box["location"], *self.collision_box["size"]]):
                        self.state_up = False
                        break
    
    def save(self):
        data = {"id": 5,
                "colour": self.colour}
        return data
    
    def get_rendering_row(self):
        return self.y_pos
    
    def draw(self, screen):
        from classes.global_data import constants_structure;
        constants = constants_structure()
        
        # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        temp_surface = pygame.Surface(constants.SQUARE_SIZE, pygame.SRCALPHA) 
        
        # Pick texture depending on state
        if self.state_up:
            temp_surface.blit(pygame.transform.scale(self.textures["up"], constants.SQUARE_SIZE),(0,0))
        else:
            temp_surface.blit(pygame.transform.scale(self.textures["down"], constants.SQUARE_SIZE),(0,0))
            
        # Apply texture
        screen.blit(temp_surface, (self.x_pos, self.y_pos))
        
        return screen



File: projects/final/classes/special_squares/door.py
import pygame

class Door:
    def __init__(self, x, y, hinge_corner, starting_dir, room_location, door_type=""):
        # x and y are grid coordinates and wil be translated to screen coordinates
        
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        # Pre-calculate all coordinates
        self.grid_location = [x,y]
        x = (x * constants.SQUARE_SIZE[0]) + room_location[0]
        y = (y * constants.SQUARE_SIZE[1]) + room_location[1]
        self.starting_dir = starting_dir
        
        # state is either 'h' or 'v' (horizontal of vertical)
        self.state = starting_dir
        self.corner = hinge_corner
        self.is_open = False
        
        self.x_pos = x
        self.y_pos = y
        
        # Load both textures
        self.textures = {"h": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/{door_type}door_right.png").convert(), constants.SQUARE_SIZE),
                        "v": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/{door_type}door_up.png").convert(), (constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 2))}
        
        
        
        # Possible hinge corner values: bottom_left, bottom_right, top_left, top_right
        
        # Load both collision boxes
        self.collision_boxes = {
            "h": {"size": (constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 0.1),  "location": [x, y + (constants.SQUARE_SIZE[1] * 0.9)]},
            "v": {"size": (constants.SQUARE_SIZE[0] * 0.1, constants.SQUARE_SIZE[1]),  "location": [x, y]}
        }
        
        self.collision_box = self.collision_boxes[starting_dir]
        
        
        # Re-align textures and collision box according to door coordinate
        if hinge_corner == "bottom_right":
            self.collision_boxes["v"]["location"][0] = x + (constants.SQUARE_SIZE[0] * 0.9)
            self.textures["h"] = pygame.transform.flip(self.textures["h"], True, False)
            #self.textures["v"] = pygame.transform.flip(self.textures["v"], True, False)
            
            
        elif hinge_corner == "top_left":
            self.collision_boxes["h"]["location"][1] = y
            temp_surface = pygame.Surface((constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 2), pygame.SRCALPHA)
            temp_surface.blit(self.textures["h"], (0,0))
            self.textures["h"] = temp_surface
            
            
        elif hinge_corner == "top_right":
            self.collision_boxes["h"]["location"][1] = y
            self.collision_boxes["v"]["location"][0] = x + (constants.SQUARE_SIZE[0] * 0.9)
            self.textures["h"] = pygame.transform.flip(self.textures["h"], True, False)
            #self.textures["v"] = pygame.transform.flip(self.textures["v"], True, False)
            
            temp_surface = pygame.Surface((constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 2), pygame.SRCALPHA)
            temp_surface.blit(self.textures["h"], (0,0))
            self.textures["h"] = temp_surface
            
        # Set default attributes (inheriting classes can edit these)
        self.manual = True
        self.type = "manual"
        
    def toggle_state(self): # Switches door position depending on current one
        self.is_open = not self.is_open
        if self.state == "v":
            self.state = "h"
            self.collision_box = self.collision_boxes["h"]
        else:
            self.state = "v"
            self.collision_box = self.collision_boxes["v"]
            
            
    def open(self): # Sets door to be open
        if self.starting_dir == self.state:
            self.is_open = True
            if self.state == "v":
                self.state = "h"
                self.collision_box = self.collision_boxes["h"]
            else:
                self.state = "v"
                self.collision_box = self.collision_boxes["v"]
    
    def close(self): # Sets door to be closed
        if self.starting_dir != self.state:
            self.is_open = False
            self.state = self.starting_dir
            self.collision_box = self.collision_boxes[self.starting_dir]
            
            
    def save(self):
        # Generate position string
        pos = self.state
        pos += self.corner[0]
        if "left" in self.corner:
            pos += "l"
        else:
            pos += "r"
            
        data = {"id": 3,
                "pos": pos}
        return data
    
    def get_rendering_row(self):
        return self.collision_box["location"][1]
        
    def draw(self, screen):
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        # Draw for vertical state
        if self.state == 'v':
            temp_surface = pygame.Surface((self.textures["v"].get_width(), self.textures["v"].get_height()), pygame.SRCALPHA)
            temp_surface.blit(self.textures["v"], (0,0))
            if self.corner.find("right") != -1:
                screen.blit(temp_surface, (self.x_pos + (constants.SQUARE_SIZE[1] * 0.65), self.y_pos - constants.SQUARE_SIZE[1]))
            else:
                screen.blit(temp_surface, (self.x_pos - (constants.SQUARE_SIZE[1] * 0.15), self.y_pos - constants.SQUARE_SIZE[1]))
            
        # Draw for horizontal state
        elif self.state == 'h':
            temp_surface = pygame.Surface((self.textures["h"].get_width(), self.textures["h"].get_height()), pygame.SRCALPHA)
            temp_surface.blit(self.textures["h"], (0,0))
            if self.corner.find("top") != -1:
                screen.blit(temp_surface, (self.x_pos, self.y_pos - int(constants.SQUARE_SIZE[1] * 0.7)))
            else:
                screen.blit(temp_surface, (self.x_pos, self.y_pos))
        
        return screen




File: projects/final/classes/special_squares/objective_door.py
import pygame
from classes.special_squares.door import Door

class ObjectiveDoor(Door): # Objective Door object extends Door object
    def __init__(self, x, y, hinge_corner, starting_dir, room_location, colour=None, side = None):
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        # Initiate self as Door
        Door.__init__(self, x, y, hinge_corner, starting_dir, room_location, "objective_")
        
        # Set attributes
        self.manual = False
        self.colour = colour
        self.side = side
        self.starting_dir = starting_dir
        
        # Generate textures based on colour
        if colour is not None:
            overlay_textures = {"h": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/squares/objective_door_right_overlay.png").convert(), constants.SQUARE_SIZE),
                                "v": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/squares/objective_door_up_overlay.png").convert(), (constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 2))}
        
            for texture in overlay_textures:
                temp_surface = pygame.Surface((overlay_textures[texture].get_width(), overlay_textures[texture].get_height()), pygame.SRCALPHA)
                temp_surface.blit(overlay_textures[texture], (0,0))
                temp_surface.fill(colour, special_flags=pygame.BLEND_MULT)
                temp_surface_2 = pygame.Surface((self.textures[texture].get_width(), self.textures[texture].get_height()), pygame.SRCALPHA)
                temp_surface_2.blit(self.textures[texture], (0,0))
                temp_surface_2.blit(temp_surface, (0,0))
                self.textures[texture] = temp_surface_2
        
    def save(self):
        # Generate position string
        pos = self.state
        pos += self.corner[0]
        if "left" in self.corner:
            pos += "l"
        else:
            pos += "r"
            
        data = {"id": 9,
                "pos": pos,
                "colour": self.colour}
        return data




File: projects/final/classes/special_squares/mechanical_door.py


import pygame
from classes.special_squares.door import Door

class MechanicalDoor(Door): # Mechanical Door object extends Door object
    def __init__(self, x, y, hinge_corner, starting_dir, room_location, colour, door_type = "button", objective_side = None, is_open = False):
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        # Initiate self as Door
        Door.__init__(self, x, y, hinge_corner, starting_dir, room_location)

        # Set attributes
        self.type = door_type
        self.side = objective_side
        self.manual = False
        self.colour = colour
        self.is_open = is_open
        self.starting_dir = starting_dir

        # Account for state
        if is_open:
            self.starting_dir = "v"
            if starting_dir == "v":
                self.starting_dir = "h"
            
        
        # Calculate textures
        self.textures = {"h": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/squares/mechanical_door_right_base.png").convert(), constants.SQUARE_SIZE),
                        "v": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + "project_lib/assets/squares/mechanical_door_up_base.png").convert(), (constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 2))}
        
        overlay_textures = {"h": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/mechanical_door_right_overlay_{self.type}.png").convert(), constants.SQUARE_SIZE),
                        "v": pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/mechanical_door_up_overlay_{self.type}.png").convert(), (constants.SQUARE_SIZE[0], constants.SQUARE_SIZE[1] * 2))}
        
        for texture in overlay_textures:
            temp_surface = pygame.Surface((overlay_textures[texture].get_width(), overlay_textures[texture].get_height()), pygame.SRCALPHA)
            temp_surface.blit(overlay_textures[texture], (0,0))
            temp_surface.fill(colour, special_flags=pygame.BLEND_MULT)
            temp_surface_2 = pygame.Surface((self.textures[texture].get_width(), self.textures[texture].get_height()), pygame.SRCALPHA)
            temp_surface_2.blit(self.textures[texture], (0,0))
            temp_surface_2.blit(temp_surface, (0,0))
            self.textures[texture] = temp_surface_2
        
        
            
    def save(self):
        # Generate position string
        pos = self.state
        pos += self.corner[0]
        if "left" in self.corner:
            pos += "l"
        else:
            pos += "r"
            
        # Return different ID depending on mechanical door type
        id = 11
        if self.type == "button":
            id = 8
            
        data = {"id": id,
                "pos": pos,
                "open": self.is_open,
                "colour": self.colour}
        return data
        
    



File: projects/final/classes/special_squares/ladder.py
import pygame

class Ladder:
    def __init__(self, x, y, room_loc):
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        self.texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/squares/ladder.png").convert(), constants.SQUARE_SIZE)
        
        # Pre-calculate screen coordinates from grid coordinates
        self.grid_coords = (x, y)
        self.x_pos = (x * constants.SQUARE_SIZE[0]) + room_loc[0]
        self.y_pos = (y * constants.SQUARE_SIZE[1]) + room_loc[1]
    
    def player_proximity(self, player_loc):
        from math import sqrt
        
        # Use Pythagoras's theorem to calculate direct distance from the player
        return sqrt(((player_loc[0] - self.x_pos - (self.texture.get_width()//2))**2) + ((player_loc[1] - self.y_pos - (self.texture.get_height()//2))**2))
        
    def get_rendering_row(self):
        return self.y_pos
        
    def draw(self, screen):
        from classes.global_data import constants_structure
        constants = constants_structure()
        
        temp_surface = pygame.Surface((constants.SQUARE_SIZE), pygame.SRCALPHA)
        temp_surface.blit(self.texture, [0,0])
        screen.blit(temp_surface, (self.x_pos, self.y_pos))
        
        return screen




File: projects/final/classes/items/living_item.py
import pygame
from functions.algorithms.collision_detection import is_colliding

class LivingItem:
    def __init__(self, x, y, item, velocity=[0,0]):
        self.item = item
        
        self.x_pos = x
        self.y_pos = y
        self.size = (40,40)
        self.velocity = velocity
        # hitbox is the same width but only the bottom half of height. This is derived from location and size when required
        
        
    def move(self, room_layout, room_location, constants):
        DECELERATION = 1
        
        hitbox = {"size": [self.size[0],self.size[1]//2],
                            "location": [self.x_pos,self.y_pos]}
        
        # Check collisions for X and Y movement
        if not is_colliding({"size": [self.size[0],self.size[1]//2],
                            "location": [self.x_pos + self.velocity[0], self.y_pos]}, 
                            room_layout, room_location, constants.SQUARE_SIZE):
            self.x_pos += self.velocity[0]
        if not is_colliding({"size": [self.size[0],self.size[1]//2],
                            "location": [self.x_pos, self.y_pos + self.velocity[1]]}, 
                            room_layout, room_location, constants.SQUARE_SIZE):
            self.y_pos += self.velocity[1]
        
        # Tend velocity towards 0 for X and Y
        if self.velocity[0] < 0:
            self.velocity[0] += DECELERATION
        elif self.velocity[0] > 0:
            self.velocity[0] -= DECELERATION
        
        if self.velocity[1] < 0:
            self.velocity[1] += DECELERATION
        elif self.velocity[1] > 0:
            self.velocity[1] -= DECELERATION
            
    def save(self, room_loc):
        
        data = {
            "name": "item",
            "x": self.x_pos,
            "y": self.y_pos,
            "item": self.item.type,
            "payload": self.item.payload
        }
        
        return data
    
    def get_rendering_row(self):
        return self.y_pos
        
    def draw(self, screen):
        temp_surface = pygame.Surface(self.size, pygame.SRCALPHA)
        
        # Shadow (create translucent rectangle)
        pygame.draw.rect(temp_surface, (0, 0, 0, 128), (0, self.size[1]//8*7, self.size[0], self.size[1]//8))
        # Texture
        temp_surface.blit(pygame.transform.scale(self.item.game_texture, self.size), (0,0))
        
        # Apply to screen
        screen.blit(temp_surface, (self.x_pos, self.y_pos))
        
        return screen
    



File: projects/final/classes/items/items.py


import pygame
from classes.item import Item

# All items have their own small class with its own individual details
# Creating a new item is as easy as adding a new class and setting the details correctly. The game handles the rest

# ARMOUR
# Wooden Armour
class WoodenHelmet(Item):
    def __init__(self, payload):
        
        # Define data
        self.type = "wood_head"
        self.name = "Wooden Helmet"
        
        # Initiate self as item
        Item.__init__(self, self.type)
        
        self.sort = "helmet"
        
        # Set multipliers
        self.speed_multiplier = 0.9
        self.mele_armour_multiplier = 0.95
        
class WoodenChestplate(Item):
    def __init__(self, payload):
        
        self.type = "wood_chest"
        self.name = "Wooden Chestplate"
        
        Item.__init__(self, self.type)
        
        self.sort = "chestplate"
        
        self.speed_multiplier = 0.85
        self.mele_armour_multiplier = 0.9
        
class WoodenBoots(Item):
    def __init__(self, payload):
        
        self.type = "wood_feet"
        self.name = "Wooden Boots"
        
        Item.__init__(self, self.type)
        
        self.sort = "boots"
        
        self.speed_multiplier = 0.9
        self.mele_armour_multiplier = 0.95

# Chainmail Armour
class ChainmailHelmet(Item):
    def __init__(self, payload):
        
        self.type = "chain_head"
        self.name = "Chainmail Helmet"
        
        Item.__init__(self, self.type)
        
        self.sort = "helmet"
        
        self.speed_multiplier = 0.85
        self.mele_armour_multiplier = 0.97
        self.ranged_armour_multiplier = 0.95
        
class ChainmailChestplate(Item):
    def __init__(self, payload):
        
        self.type = "chain_chest"
        self.name = "Chainmail Chestplate"
        
        Item.__init__(self, self.type)
        
        self.sort = "chestplate"
        
        self.speed_multiplier = 0.8
        self.mele_armour_multiplier = 0.95
        self.ranged_armour_multiplier = 0.92
        
class ChainmailBoots(Item):
    def __init__(self, payload):
        
        self.type = "chain_feet"
        self.name = "Chainmail Boots"
        
        Item.__init__(self, self.type)
        
        self.sort = "boots"
        
        self.speed_multiplier = 0.85
        self.mele_armour_multiplier = 0.97
        self.ranged_armour_multiplier = 0.95
        
# Iron Armour
class IronHelmet(Item):
    def __init__(self, payload):
        
        self.type = "metal_head"
        self.name = "Iron Helmet"
        
        Item.__init__(self, self.type)
        
        self.sort = "helmet"
        
        self.speed_multiplier = 0.8
        self.mele_armour_multiplier = 0.9
        self.ranged_armour_multiplier = 0.83
        
class IronChestplate(Item):
    def __init__(self, payload):
        
        self.type = "metal_chest"
        self.name = "Iron Chestplate"
        
        Item.__init__(self, self.type)
        
        self.sort = "chestplate"
        
        self.speed_multiplier = 0.7
        self.mele_armour_multiplier = 0.85
        self.ranged_armour_multiplier = 0.75
        
class IronBoots(Item):
    def __init__(self, payload):
        
        self.type = "metal_feet"
        self.name = "Iron Boots"
        
        Item.__init__(self, self.type)
        
        self.sort = "boots"
        
        self.speed_multiplier = 0.8
        self.mele_armour_multiplier = 0.9
        self.ranged_armour_multiplier = 0.8
        

# WEAPONS
class StickSword(Item):
    def __init__(self, payload):
        
        self.type = "stick"
        self.name = "Stick"
        
        Item.__init__(self, self.type)
        
        self.sort = "mele"
        
        self.damage_multiplier = 2
        
class LongSword(Item):
    def __init__(self, payload):
        
        self.type = "long_sword"
        self.name = "Long Sword"
        
        Item.__init__(self, self.type)
        
        self.sort = "mele"
        
        self.damage_multiplier = 3.5
        self.attack_speed_multiplier = 0.9
        self.mele_range_multiplier = 1.2

class Axe(Item):
    def __init__(self, payload):
        
        self.type = "metal_axe"
        self.name = "Axe"
        
        Item.__init__(self, self.type)
        
        self.sort = "mele"
        
        self.damage_multiplier = 5
        self.attack_speed_multiplier = 0.5
        self.mele_range_multiplier = 1.2
        
class Dagger(Item):
    def __init__(self, payload):
        
        self.type = "dagger"
        self.name = "Dagger"
        
        Item.__init__(self, self.type)
        
        self.sort = "mele"
        
        self.damage_multiplier = 2.5
        self.attack_speed_multiplier = 2.5
        self.mele_range_multiplier = 0.7
        
class Mace(Item):
    def __init__(self, payload):
        
        self.type = "mace"
        self.name = "Mace"
        
        Item.__init__(self, self.type)
        
        self.sort = "mele"
        
        self.damage_multiplier = 2
        self.attack_speed_multiplier = 0.75
        self.mele_range_multiplier = 2
        

class Key(Item):
    def __init__(self, payload):
        
        self.type = "key"
        self.name = "Key"
        self.colour = payload["colour"]
        
        Item.__init__(self, self.type, payload)
        
        self.sort = "tool"
        
        # Texture is shaded according to colour data
        temp_surface = pygame.Surface((self.inv_texture.get_width(), self.inv_texture.get_height()), pygame.SRCALPHA)
        temp_surface.blit(self.inv_texture, (0,0))
        temp_surface.fill(self.colour, special_flags=pygame.BLEND_MULT)
        self.inv_texture = temp_surface
        self.game_texture = temp_surface
    
    def save(self): # Save method is overridden since payload contains more data
        return {
            "item": self.type, 
            "payload": {"colour": self.colour}
            }
    
    
# SPACE TO ADD MORE ITEMS LATER





File: projects/final/classes/entities/enemy.py
from classes.entity import Entity
import functions.algorithms.a_star_pathfind as path_finding
from math import sqrt

class Enemy(Entity): # Enemy class extends Entity
    def __init__(self, x, y, type, room_loc, drops):
        # Initiate object as an Entity
        Entity.__init__(self, x, y, type, room_loc, drops)
        
        # Set default attributes (inheriting classes will change these in their constructors)
        self.player_memory = 0
        self.max_player_memory = 45
        self.run_speed = 4
        self.walk_speed = 2
        self.idle_destination = []
        self.team = "enemy"
        self.attack_damage = 5
        self.max_attack_cooldown = 30
        self.attack_cooldown = self.max_attack_cooldown
        self.attack_frame = 0
        self.player_remembered_location = [x, y] # temporary, till replaced
        
    def think(self, player, entities, crates, doors, room, constants):
        
        # Check for frozen states (enemy doesn't do any other processing when spawning or dying)
        if self.state == "death":
            if self.animation_frame == len(self.assets["death"])-1:
                return True
            else:
                return False
        if self.state == "spawn":
            if self.animation_frame == len(self.assets["spawn"])-1:
                self.change_state("idle")
            return False
        
    
        # Priority order: attack, hunt player, wander, idle
        self.location = self.collision_box["location"]
        
        player_location = player.collision_box["location"] # Get player real location
            
        from functions.algorithms.a_star_pathfind import path_possible
        
        
        # Hunt player if player is within line of sight or has been within enemy memory time
        
        # Check if player is in line of sight
        LOS_result = path_finding.line_of_sight([self.location[0] + (self.collision_box["size"][0]//2), self.location[1] + (self.collision_box["size"][1]//2)], player_location, room, constants, [*crates, *doors])
        if LOS_result == "possible":
            # Check if path to player is possible
            if path_possible(self.get_square(room), player.get_square(room), room.layout): # check if path to player possible
                # If player is being hunted and path is possible, update remembered location
                self.player_remembered_location = player_location # if it is, update memory. If it is not, then memory will not be updated and will therefore be the same
            # Set enemy to be hunting 
            self.speed = self.run_speed
            self.player_memory = self.max_player_memory
            
        elif self.player_memory > 0:
            # If enemy is not hunting, set to wandering and begin to reduce memory
            self.speed = self.walk_speed
            self.player_memory -= 1
        
        # If player is being hunted
        if self.player_memory > 0:
            
            if self.attack_cooldown >= 0:
                self.attack_cooldown -= 1
            
            # If player can be attacked, do the attack
            if (self.attack_cooldown <= 0) and (sqrt(((self.x_pos - player.x_pos)**2) + ((self.y_pos - player.y_pos)**2)) < 45):
                self.attack(player, entities, room)
                self.attack_cooldown = self.max_attack_cooldown
            
            
            # If enemy is not attacking, continue to chase player
            if self.attack_timer == 0:
                
                self.path_to_player = path_finding.a_star(self.location, self.player_remembered_location, room, self.collision_box["size"], crates, doors) 
                
                # Path is an array of direct points to player location. Carry out path
                if len(self.path_to_player) > 1:
                    self.move(self.path_to_player[1], room, crates, doors)
                else:
                    self.move(self.player_remembered_location, room, crates, doors)
            else:
                self.attack_timer -= 1
            
            

        else: # idle
            self.speed = self.walk_speed
            
            # SPACE TO ADD PASSIVE WALKING FEATURE
            
            self.move(self.location, room, crates, doors)
            
            
        return False
            




File: projects/final/classes/entities/moveable_squares/crate.py
from classes.entity import Entity
from classes.global_data import constants_structure
import pygame

class Crate(Entity): # The Crate class extends the Entity class
    def __init__(self, x, y, room_loc):
        # x and y parameters are grid locations, not screen coordinates (they will be translated to screen coordinates)
        constants = constants_structure()
        self.texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/entities/crate.png").convert(), constants.SQUARE_SIZE)
        
        # Pre-calculate all coordinates
        self.x_pos = (x * constants.SQUARE_SIZE[0]) + room_loc[0]
        self.y_pos = (y * constants.SQUARE_SIZE[1])+ room_loc[1]
        self.width = constants.SQUARE_SIZE[0]
        self.height = constants.SQUARE_SIZE[1]
        self.size = [self.width, self.height]
        
        self.collision_box = {"location": [self.x_pos + (self.width * 0.05), self.y_pos + (self.height //2)],
                                "size": [constants.SQUARE_SIZE[0] * 0.9, constants.SQUARE_SIZE[1]//2]}
        
        
    def move(self, direction, speed, room, crates, doors, entities, moved_crates = []):
        from functions.algorithms.collision_detection import is_colliding, collision
        constants = constants_structure()
        # Checks if move can be done, and then carries it out. Whether it can and has been done is returned to the player
        
        moved_crates.append(self)
        
        # Do movement
        if direction == "left":
            self.collision_box["location"][0] -= speed
        elif direction == "right":
            self.collision_box["location"][0] += speed
        elif direction == "up":
            self.collision_box["location"][1] -= speed
        elif direction == "down":
            self.collision_box["location"][1] += speed
        
        # Check if the crate is colliding with any squares
        colliding = is_colliding(self.collision_box, room.layout, room.location, constants.SQUARE_SIZE)
        
        # If not, check other squares and entities to see if they are colliding
        if not colliding:
            for crate in crates: # Check other crates
                if not crate in moved_crates:
                    if collision([*self.collision_box["location"], *self.collision_box["size"]], 
                                [*crate.collision_box["location"], *crate.collision_box["size"]]):
                        if not crate.move(direction, speed, room, crates, entities, moved_crates): 
                            # Recursively checks other crates to check if they can be pushed. Will only not push if the chain is blocked
                            colliding = True
            
            if not colliding:
                for door in doors: # Check doors
                    if collision([*self.collision_box["location"], *self.collision_box["size"]], [*door.collision_box["location"], *door.collision_box["size"]]):
                        colliding = True
                            
            if not colliding:
                for entity in entities: # Check entities
                    if collision([*self.collision_box["location"], *self.collision_box["size"]], 
                                    [*entity.collision_box["location"], *entity.collision_box["size"]]):
                        if not entity.push(direction, speed, room, crates, doors):
                            # Checks if entities can be added to push chain
                            colliding = True
                            
            # If still not colliding, carry out movement
            if not colliding:
                self.x_pos = self.collision_box["location"][0] - (self.width * 0.05)
                self.y_pos = self.collision_box["location"][1] - (self.height //2)
            
        # Update collision box
        self.collision_box = {"location": [self.x_pos + (self.width * 0.05), self.y_pos + (self.height //2)],
                                "size": [constants.SQUARE_SIZE[0] * 0.9, constants.SQUARE_SIZE[1]//2]}
        
        return not colliding # can move
        
    
    def save(self, room_loc):
        constants = constants_structure()
        # Collect important data
        data = {
            "name": "crate",
            "x": (self.x_pos - room_loc[0]) / constants.SQUARE_SIZE[0],
            "y": (self.y_pos - room_loc[1]) / constants.SQUARE_SIZE[1]
        }
        
        return data
    
    def get_rendering_row(self):
        return self.collision_box["location"][1]
        
    def draw(self, screen):
        # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
        temp_surface = pygame.Surface([self.width, self.height], pygame.SRCALPHA) 
        temp_surface.blit(pygame.transform.scale(self.texture, [self.width, self.height]),(0,0))
        
        # Code to show collision box (for development purposes):
        # pygame.draw.rect(temp_surface, (255, 0, 0, 127), (self.collision_box["location"][0] - self.x_pos, self.collision_box["location"][1] - self.y_pos, *self.collision_box["size"]))
        
        screen.blit(temp_surface, (self.x_pos, self.y_pos))
        return screen



File: projects/final/classes/entities/enemies/goblin.py
from classes.entities.enemy import Enemy
from classes.global_data import constants_structure
from random import randint

class Goblin(Enemy): # The goblin class extends the Enemy class
    
    def __init__(self, x, y, health, room_loc, drops = {}):
        # Initiate the object as an enemy
        Enemy.__init__(self, x, y, "goblin", room_loc, drops)
        
        import json
        constants = constants_structure()
        
        # Extract data file
        data = json.load(open(constants.FILE_PATH + "data/entities/enemies/goblin.json", "r"))
        self.max_health = data["health"]
        
        # Extract all data from entity stats file
        self.health = health
        if health == -1: # -1 means default
            self.health = self.max_health
            
        self.walk_speed = data["walk_speed"]
        self.run_speed = data["run_speed"]
        self.max_player_memory = randint(data["max_player_memory_range"][0], data["max_player_memory_range"][1])
        self.size = data["size"]
        self.collision_box["size"] = data["collision_box_size"]
        self.team = data["team"]
        self.mele_reach = data["mele_reach"]
        self.attack_damage = data["attack_damage"]
        self.max_attack_cooldown = data["attack_cooldown"]
        



File: projects/final/functions/algorithms/delete_savegame.py
import json
import shutil

def delete_savegame(account_id, savegame_id):
    from classes.global_data import constants_structure
    constants = constants_structure()
    
    # Load accounts
    with open(constants.FILE_PATH + "data/accounts.json", 'r') as accountsDB:
        accountsDBJson = json.load(accountsDB)
        
    # Remove savegame on account data
    for i, account in enumerate(accountsDBJson):
        if account["UUID"] == account_id:
            for j, savegame in enumerate(account["savegames"]):
                if savegame["display_details"]["id"] == savegame_id:
                    accountsDBJson[i]["savegames"].pop(j)
                    break
    # Save accounts
    with open(constants.FILE_PATH + "data/accounts.json", 'w') as accountsDB:
        json.dump(accountsDBJson, accountsDB, indent=4)
        accountsDB.close()
        
    # Delete savegame files
    shutil.rmtree(constants.FILE_PATH + f"data/account_games/{account_id}_games/{savegame_id}_levels")




File: projects/final/functions/algorithms/getMovementVector.py
def get_movement_vector(speed, directionVector):
    if directionVector == [0,0]:
        return directionVector # Return nothing if the vector has no direction
    
    # Calculate original vector distance
    from math import sqrt
    directionDistance = sqrt((directionVector[0] ** 2) + 
			                 (directionVector[1] ** 2))

    # Calculate multiplier
    multiplier = speed / directionDistance
    
    # Multiply axis of original vector by scaler multiplier to scale them correctly
    movementVector = [directionVector[0] * multiplier, 
		      directionVector[1] * multiplier]

    return movementVector




File: projects/final/functions/algorithms/hashPassword.py
def hashPassword(password):
    # Put the first and last two letters in the middle of the password
    # AppleSeed337 -> AppleSAp37eed337
    password = password[:len(password)//2] + password[:2] + password[-2:] + password[len(password)//2:]

    # Put the product of all the numbers in the password at the start of it
    # AppleSeed337 -> 63AppleSeed337
    passwordCharacters = list(password)
    product = 1
    for character in passwordCharacters:
        if character.isdigit():	
            product *= int(character)
    password = str(product) + password

    # Reduce the ascii value of each of the characters by 10
    # AppleSeed337 -> 7ffb[I[[Z))-
    passwordCharacters = list(password)
    passwordCharacters = [chr(ord(character) - 10) for character in passwordCharacters]
    password = "".join(passwordCharacters)

    # Add a salt of "Xj8/" to the end of the password
    # AppleSeed337 -> AppleSeed337Xj8/
    password += "Xj8/"

    # Move the last letter to the front of the password for the the ascii 
    # total of the password number divided and rounded by 100 of turns
    # AppleSeed337 -> pleSeed337Ap
    asciiTotal = sum([ord(character) for character in password])
    for i in range(asciiTotal // 100):
        password = password[len(password)-1] + password[:-1]

    # Alternate the first and last letters of the password, moving inwards 
    # (if there are an odd number of letters, add a P to the end to make it even)
    # AppleSeed337 - > A7p3p3ldeeSe
    if len(password) % 2 != 0:
        password = password + "P"	
        tempPassword = ""
        for i in range(len(password)//2):
            tempPassword += password[i] + password[-i]

    # Overall, the password is very scrambled:
    # AppleSeed337 -> AppleSAp37eed337 -> 1323AppleSAp37eed337 -> ')()7ffb[I7f)-[[Z))- 
    # -> ')()7ffb[I7f)-[[Z))-Xj8/ -> ')()7ffb[I7f)-[[Z))-Xj8/ -> [I7f)-[[Z))-Xj8/')()7ffb 
    # -> [bIf7ff7))-([)['Z/)8)j-X
    
    return password




File: projects/final/functions/algorithms/collision_detection.py
def is_colliding(player, room_collidables, room_coordinates, square_size):
    
    # Turn screen coordinates into grid coordinates
    player_grid_x = int((player["location"][0] - room_coordinates[0]) // square_size[0])
    player_grid_y = int((player["location"][1] - room_coordinates[1]) // square_size[1])
    
    # Create a 2x2 2d array of the 4 squares that surround the player. This is calculated by starting from the 
    # coordinate of the player's top-left corner, and then taking the squares directly to the right and below
    # of that coordinate. This instantly removes a lot of squares that do not need to be checked, making the
    # algorithm far more efficient.
    if player_grid_y < len(room_collidables)-1:
        player_surroundings = [ room_collidables[player_grid_y][player_grid_x: player_grid_x + 2],
                                room_collidables[player_grid_y + 1][player_grid_x: player_grid_x + 2]]
    else:
        player_surroundings = [room_collidables[player_grid_y][player_grid_x: player_grid_x + 2]]
        
    # get values for each side of the player
    x1 = player["location"][0]
    y1 = player["location"][1]
    x1_end = player["size"][0]
    y1_end = player["size"][1]
    
    for row in player_surroundings: # Check the 4 connected squares
        for square in row:
            if square.collidable is False: # If the square isn't a collidable, there is no collision
                continue
            # Find values for each side of the square
            x2 = square.collision_x
            y2 = square.collision_y
            x2_end = square.width
            y2_end = square.height
            
            # Check for a collision between the player and the square
            if collision([x1, y1, x1_end, y1_end],  [x2, y2, x2_end, y2_end]):
                return True
            
    return False
    
    
def collision(square_1, square_2):
    # Get sides of both square
    x1 = square_1[0]
    y1 = square_1[1]
    x1_end = x1 + square_1[2]
    y1_end = y1 + square_1[3]
    
    x2 = square_2[0]
    y2 = square_2[1]
    x2_end = x2 + square_2[2]
    y2_end = y2 + square_2[3]
    
    sorted_xs = [x1,x1_end, x2,x2_end]
    sorted_xs.sort() # Sort all X coordinates
    
    # check that both bounding boxes are not next to eachother
    if not (sorted_xs == [x1,x1_end, x2,x2_end] or sorted_xs == [x2,x2_end, x1,x1_end]):  # If squares are overlapping on X
        
        sorted_ys = [y1,y1_end, y2,y2_end]
        sorted_ys.sort() # Sort all Y coordinates
        
        # check that both bounding boxes are not vertically adjasent to eachother
        if not (sorted_ys == [y1,y1_end, y2,y2_end] or sorted_ys == [y2,y2_end, y1,y1_end]):  # If squares are overlapping on Y
            return True # There is a collison since both dimensions are overlapping
    
    # One axis is not overlapping, meaning there is not a coordinate
    return False




File: projects/final/functions/algorithms/log_in.py
import json

from functions.algorithms.hashPassword import hashPassword
from classes.global_data import constants_structure
constants = constants_structure()

def do_log_in(username, password):
    # Hash password
    hashed_password = hashPassword(password)
    
    # Open accounts file
    with open(constants.FILE_PATH + "data/accounts.json", 'r') as accountsFile:
        accounts = json.load(accountsFile)
        
    for account in accounts: # Check each account with a linear search 
                            # (the list is not sorted by either username or password, so no other kind is possible)
        # Main login check
        if account["username"] == username   and   account["hashed_password"] == hashed_password: 
            return {"returnType": 1,
                    "account_details": account}
            
    # If at this point, the account does not exist
    return {"returnType": -1,
            "returnMessage": "Sorry, your username or password is incorrect"}




File: projects/final/functions/algorithms/entity_lookup.py
def lookup(name):
    the_class = None
    
    if name == "goblin":
        from classes.entities.enemies.goblin import Goblin
        the_class = Goblin
    
    elif name == "crate":
        from classes.entities.moveable_squares.crate import Crate
        the_class = Crate

    elif name == "item":
        from classes.items.living_item import LivingItem
        the_class = LivingItem
        
    # PLACE TO ADD NEW ENTITY TYPES
        
    return the_class




File: projects/final/functions/algorithms/account_creation.py
import pygame
import json

from functions.algorithms.hashPassword import hashPassword
from classes.global_data import constants_structure
constants = constants_structure()

def addAccount(inputUsername, inputPassword, inputPasswordOne, inputDisplayName, inputImageURL):
    # PASSWORD VALIDATION
    # Passwords match
	if inputPassword != inputPasswordOne:
		return {"returnType": -1, 
				"returnMessage": "Passwords do not match"}

    # Password too short
	elif len(inputPassword) < 8:
		return {"returnType": -1,
				"returnMessage": "Password is too short (min 8)"}

    # Password too long
	elif len(inputPassword) > 30:
		return {"returnType": -1,
				"returnMessage": "Password is too long (max 30)"}
    
    # Password does not have digit
	elif not any(char.isdigit() for char in inputPassword):
		return {"returnType": -1,
				"returnMessage": "Password needs to contain a digit"}

    # Password does not have lowercase character
	elif not any(char.islower() for char in inputPassword):
		return {"returnType": -1,
				"returnMessage": "Password needs to contain a lowercase character"}

    # Password does not have uppercase character
	elif not any(char.isupper() for char in inputPassword):
		return {"returnType": -1,
				"returnMessage": "Password needs to contain an uppercase character"}


    # USERNAME VALIDATION
    # Username too short
	elif len(inputUsername) < 3:
		return {"returnType": -1,
				"returnMessage": "Username is too short (min 3)"}

    # Username too long
	elif len(inputUsername) > 16:
		return {"returnType": -1,
				"returnMessage": "Username is too long (max 16)"}

    # Username contains special characters
	elif any(not(c.isalpha() or c.isdigit()) for c in inputUsername):
		return {"returnType": -1,
				"returnMessage": "Usernames cannot contain special characters (only A-Z, a-z and 0-9)"}

    # Username already exists (also gather current highest UUID)
	highestUUID = 0
	for account in json.load(open(constants.FILE_PATH + "data/accounts.json", 'r')):
		highestUUID = max(highestUUID, account["UUID"])
		if account["username"] == inputUsername:
			return {"returnType": -1,
				"returnMessage": "Username already in use"}


    # If the code has made it to this point, then the password is valid and the username is not already being used
    
    # Create the account structure and add it to the database
	account = { "UUID": 	highestUUID + 1,
		"username": 		inputUsername,
		"hashed_password": 	hashPassword(inputPassword),
		"display_name":		inputDisplayName,
		"profileImage":		inputImageURL,
		"config":			json.load(open(constants.FILE_PATH + "data/default_config.json")),
		"savegames":		[]}

	# Save data
	accountsDB = open(constants.FILE_PATH + "data/accounts.json", 'r+') 
	accountsDBJson = json.load(accountsDB)
	accountsDBJson.append(account)
	accountsDB.seek(0)
	json.dump(accountsDBJson, accountsDB, indent=4)
	accountsDB.close()
	# Return pass message
	return {"returnType": 1,
			"returnMessage": "Successfully saved",
			"account_details": account}




File: projects/final/functions/algorithms/aoeScanner.py
from math import sqrt
from classes.global_data import constants_structure

def aoeScanner(origin, entities, room, player, reach, constants, isPlayer = False):
    constants = constants_structure()
    
    # Python lambda statement to determine if a set of coordinates are within the radius distance of the origin coordinate
    isInRange = (lambda x, y, the_reach : sqrt(((origin[0] - x) ** 2) + ((origin[1] - y) ** 2)) <= the_reach)


    # Check each entity
    effectedEntities = []
    for entity in entities:
        if isInRange(entity.collision_box["location"][0] + (entity.collision_box["size"][0]//2), 
                    entity.collision_box["location"][1] + (entity.collision_box["size"][1]//2), reach):
            effectedEntities.append(entity)

    # Check each square
    effectedSquares = []
    for y in range(len(room.layout)):
        for x in range(len(room.layout[y])):
            # Check every corner of the square seperatley
            if (isInRange((x * constants.SQUARE_SIZE[0]) + room.location[0], (y * constants.SQUARE_SIZE[1]) + room.location[1], reach - 20) or # top left
                isInRange((x * constants.SQUARE_SIZE[0]) + room.location[0] + constants.SQUARE_SIZE[0], (y * constants.SQUARE_SIZE[1]) + room.location[1], reach - 20) or # top right
                isInRange((x * constants.SQUARE_SIZE[0]) + room.location[0], (y * constants.SQUARE_SIZE[1]) + room.location[1] + constants.SQUARE_SIZE[1], reach - 20) or # bottom left
                isInRange((x * constants.SQUARE_SIZE[0]) + room.location[0] + constants.SQUARE_SIZE[0], (y * constants.SQUARE_SIZE[1]) + room.location[1] + constants.SQUARE_SIZE[1], reach - 20)):  # bottom right
                effectedSquares.append([x,y])

    # Player
    playerEffected = False # There is only one player, so the player being effected is a boolean
    if (isInRange(player.collision_box["location"][0] + (player.collision_box["size"][0]//2), 
                    player.collision_box["location"][1] + (player.collision_box["size"][1]//2), reach) 
                    and not isPlayer):
        playerEffected = True

    return effectedEntities, effectedSquares, playerEffected




File: projects/final/functions/algorithms/a_star_pathfind.py
from math import sqrt
from copy import deepcopy

def a_star(start, end, room, hitbox_size, crates, doors):
    from classes.global_data import constants_structure
    constants = constants_structure()
    
    # The pathfinding algorithm works in stages:
    
    # Stage 1 - Calculate path from A to B using A* algorithm:
    #           - Attempt path
    #           - If hit a dead end, backstep until a new path can be tried
    
    # Stage 2 - Find shortcuts to shorten path where possible
    
    # Stage 3 - Smooth out path with point to point squares
    
    
    # Define beginning and end (A and B)
    raw_start = deepcopy(start)
    raw_end = deepcopy(end)
    end = [int((end[0] - ((constants.GAME_WINDOW_SIZE[0] - room.size[0])//2)) // constants.SQUARE_SIZE[0]), int((end[1] - ((constants.GAME_WINDOW_SIZE[1] - room.size[1])//2)) // constants.SQUARE_SIZE[1])]
    start = [int((start[0] - ((constants.GAME_WINDOW_SIZE[0] - room.size[0])//2)) // constants.SQUARE_SIZE[0]), int((start[1] - ((constants.GAME_WINDOW_SIZE[1] - room.size[1])//2)) // constants.SQUARE_SIZE[1])]
    
    
    # Stage 1 - A* algorithm:
    pathStartingCoordinates = start
    currentNode = pathStartingCoordinates
    pathLength = 0
    path = [pathStartingCoordinates]
    failed_coordinates = []
    while currentNode != end: # Keep trying until path is complete
        nextNodes = []
        pathLength += 1
        for check in [[-1,0], [1,0], [0,-1], [0,1]]: # Check neighboring squares
            # Get projected coordinate
            projected_node = [currentNode[0] + check[0], currentNode[1] + check[1]]
            projected_node_tuple = tuple(projected_node)

            if projected_node_tuple in failed_coordinates:
                continue # Skip that node it if is failed (we know it leads to a dead end)
            
            if (projected_node[0] < 0 or
                projected_node[0] > len(room.layout[0]) or
                projected_node[1] < 0 or
                projected_node[1] > len(room.layout)):
                continue # Dont check past room boundries
                
            if (room.layout[projected_node[1]][projected_node[0]].collidable):
                continue # Dont check collidable nodes
            
            # use pythagoras to find the direct distance between the node and the player location (the heuristic)
            nodeHeuristic = sqrt(((projected_node[0] - end[0]) ** 2) +
                                    ((projected_node[1] - end[1]) ** 2))      
            
            # Add node to list
            nextNodes.append({"value": nodeHeuristic + pathLength,
                                "location": projected_node})
            
        # Compare nodes and find next node 
        
        if len(nextNodes) == 0: # If there are no more paths found, the square is a dead end
            if len(path) == 0:
                # No more nodes to backtrack, path is not possible
                return None
            if len(path) == 1:
                return [raw_start, raw_end]
            # Remove the last node from the path
            lastNode = path.pop()
            pathLength -= 1
            failed_coordinates.append(tuple(currentNode))
            currentNode = path[-1]
            
        else: # If not a dead end
            closestNode = nextNodes[0]
            for node in nextNodes[1:]:
                # Set the closest node to whichever node has the smallest value
                closestNode = closestNode if closestNode["value"] < node["value"] else node 
            
            # Add node to path
            path.append(closestNode["location"])
            currentNode = closestNode["location"]
            
            # If coordinate is reached again, algorithm will go in a circle which will cause an endless loop
            failed_coordinates.append(tuple(currentNode)) 
    
    
    # Stage 2 - Shortcuts:
    if len(path) == 1: # If the path is only one item long, return it
        return [raw_start, raw_end]
    
    # find shortcuts in the path
    # from the start of the path, traverse every node and work from the end to find one that is next to it
    # if it is next to a node that is several nodes ahead in the path list, then all nodes inbetween can be removed since a shortcut has been found
    new_shortcut = True
    new_path = path
    while new_shortcut:
        path = new_path
        new_shortcut = False
        for i, node in enumerate(path): # Check along the path 
            backwards_path = path[i + 2:]
            backwards_path.reverse() # Check along the path backwards
            for back_i, back_node in enumerate(backwards_path):
                # check surroundings
                for check in [[-1,0], [1,0], [0,-1], [0,1]]:
                    projected_node_tuple = tuple([node[0] + check[0], node[1] + check[1]])
                    if projected_node_tuple == tuple(back_node):
                        new_path = path[:i+1] + path[len(path)-back_i-1:]
                        new_shortcut = i != len(path) - back_i
    # Update path
    path = new_path
    
    
    # Stage 3 - Path smoothing
    
    # Now smooth path into minimum number of points, allowing overlap
    # Do this by starting at first node, and working backwards from last node until there is direct line of sight (will require line of sight function)
    # Then put the further line of sight node next to the start node in a new faster path
    # repeat again, starting from the new furthest node, until there is line of sight to the end location
    
    # Make copies of the path forwards and backwards
    new_path = [path[0]]
    current_node = path[0]
    backwards_path = deepcopy(path)
    backwards_path.reverse()
    continue_loop = True
    while current_node != path[-1] and continue_loop: # Until the path reaches the end
        for i, node in enumerate(backwards_path): # Move backwards through the path to find furthest direct node
            if node == current_node:
                if path.index(currentNode) == len(path)-1:
                    continue_loop = False
                    break
                else:
                    new_path.append(path[path.index(currentNode)+1])
                    current_node = path[path.index(currentNode)+1]
                    break
            
            # Check line if sight to that node
            if line_of_sight([(current_node[0] * constants.SQUARE_SIZE[0]) + room.location[0] + (constants.SQUARE_SIZE[0]//2), (current_node[1] * constants.SQUARE_SIZE[1]) + room.location[1] + (constants.SQUARE_SIZE[1]//2)], 
                            [(node[0] * constants.SQUARE_SIZE[0]) + room.location[0]  + constants.SQUARE_SIZE[0]//2, (node[1] * constants.SQUARE_SIZE[1]) + room.location[1] + constants.SQUARE_SIZE[1]//2], 
                            room, constants, [*crates, *doors], hitbox_size) == "possible":
                new_path.append(node)
                current_node = node # Continue checking from the new node, since nodes between the old and new one can be removed
                break
    # Update path
    path = new_path
    
        
    # Turn all nodes in path from grid coordinates to screen coordinates
    path = [[((node[0]+0.5) * constants.SQUARE_SIZE[0]) + room.location[0], 
            ((node[1]+0.5) * constants.SQUARE_SIZE[1]) + room.location[1]]  for node in path]
    
    return path


def line_of_sight(start, end, room, constants, collidables, hitbox_size=[2,2]):
    from functions.algorithms.getMovementVector import get_movement_vector
    from functions.algorithms.collision_detection import is_colliding, collision
    # use a ray-tracing algorithm to check every few pixels directly between the two nodes
    
    # Create particle data
    check = start
    total_vector = [end[0] - start[0], end[1] - start[1]]
    vector = get_movement_vector(3 , total_vector)
    
    while sqrt(((check[0]-end[0])**2) + ((check[1]-end[1])**2)) > 5:
        # Check if particle has collided with collidable entities
        for collidable in collidables:
            if collision([check[0] - (hitbox_size[0]//2),  check[1] - (hitbox_size[1]//2), *hitbox_size], [*collidable.collision_box["location"], *collidable.collision_box["size"]]):
                return "collidable"

        # Check if particle has collided with squares
        if is_colliding({"size": hitbox_size, "location": [check[0] - (hitbox_size[0]//2),  check[1] - (hitbox_size[1]//2)]}, room.layout, room.location, constants.SQUARE_SIZE):
            return "wall"
        
        # If there has not been a collision, move particle
        check = [check[0] + vector[0], check[1] + vector[1]]
        
    return "possible" # if particle reaches destination without colliding, return that the line of sight exists

def path_possible(loc1, loc2, room_layout):
    # loc1 and loc2 parameters should be given as grid coordinates
    
    # Searches every square to see if path is possible
    
    current_loc = []
    next_locs = [loc1]
    used_locs = []
    
    # Use a depth-first search (using a queue) to search all surrounding squares to see if two squares are connected by non-colliding squares
    # If they are connected, then a path could be calculated between the two points. Otherwise, the path may be impossible
    while len(next_locs) > 0:
        current_loc = next_locs.pop(0)
        for relative in [[1,0], [-1,0], [0, 1], [0,-1]]:
            to_search = [current_loc[0] + relative[0],  current_loc[1] + relative[1]]
            if to_search[0] >= 0 and to_search[1] >= 0 and to_search[0] < len(room_layout[0]) and to_search[1] < len(room_layout):
                if not (room_layout[to_search[1]][to_search[0]].collidable  or  to_search in used_locs):
                    if loc2 == to_search:
                        return True # If the destination has been reached, return true
                    used_locs.append(to_search)
                    next_locs.append(to_search)
                    
    # If queue is completely empty, the all nodes have been checked and points are not connected
    return False




File: projects/final/functions/algorithms/item_lookup.py
def lookup(name):
    the_class = None
    
    if name == "stick":
        from classes.items.items import StickSword
        the_class = StickSword
        
    # Wooden armour
    elif name == "wood_head":
        from classes.items.items import WoodenHelmet
        the_class = WoodenHelmet
    elif name == "wood_chest":
        from classes.items.items import WoodenChestplate
        the_class = WoodenChestplate
    elif name == "wood_feet":
        from classes.items.items import WoodenBoots
        the_class = WoodenBoots
        
    # Chainmail armour
    elif name == "chain_head":
        from classes.items.items import ChainmailHelmet
        the_class = ChainmailHelmet
    elif name == "chain_chest":
        from classes.items.items import ChainmailChestplate
        the_class = ChainmailChestplate
    elif name == "chain_feet":
        from classes.items.items import ChainmailBoots
        the_class = ChainmailBoots
    
    # Metal armour
    elif name == "metal_head":
        from classes.items.items import IronHelmet
        the_class = IronHelmet
    elif name == "metal_chest":
        from classes.items.items import IronChestplate
        the_class = IronChestplate
    elif name == "metal_feet":
        from classes.items.items import IronBoots
        the_class = IronBoots
        
    # Mele weapons
    elif name == "long_sword":
        from classes.items.items import LongSword
        the_class = LongSword
    elif name == "metal_axe":
        from classes.items.items import Axe
        the_class = Axe
    elif name == "dagger":
        from classes.items.items import Dagger
        the_class = Dagger
    elif name == "mace":
        from classes.items.items import Mace
        the_class = Mace
        
    # Misc
    elif name == "key":
        from classes.items.items import Key
        the_class = Key
    
    # SPACE TO ADD NEW ITEMS
        
    return the_class




File: projects/final/functions/algorithms/new_savegame.py
def load_new_savegame(constants, game_id, name="Untitled Savegame"):
    from json import load
    from datetime import datetime
    now = datetime.now()
    
    # Get default savegame data
    with open(constants.FILE_PATH + "data/default_savegame.json", "r") as default_file:
        default_json = load(default_file)
    
    # Set display data and ID
    default_json["display_details"]["name"] = name
    default_json["display_details"]["id"] = game_id
    default_json["display_details"]["last_save"] = "Not saved"
    default_json["display_details"]["created"] = now.strftime("%d/%m/%Y") # Get current time
    
    print("created new savegame called \"" + name + "\"")
    return default_json

def create_new_game_files(account_id, destination_level_id):
    import shutil
    from classes.global_data import constants_structure
    constants = constants_structure()

    # Create files
    shutil.copytree(constants.FILE_PATH + f"data/account_games/default_games/default_levels",  # source
                    constants.FILE_PATH + f"data/account_games/{account_id}_games/{destination_level_id}_levels")  # destination

def entry_loop(screen, account_details):
    print("creating new savegame")
    
    import pygame
    import time
    from json import dump, load
    
    import classes.menu as menu_classes
    from classes.global_data import constants_structure, draw_text
    constants = constants_structure()

    # Define sub-window
    over_screen_size = (constants.DEFAULT_SCREEN_SIZE[0]*0.8, constants.DEFAULT_SCREEN_SIZE[1]*0.8)
    over_screen = pygame.Surface(over_screen_size) 
    background_texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/buttons/ratio1-2.0.png").convert(), over_screen_size) # Use text input button design
    over_screen.blit(background_texture, (0,0))

    # Buttons
    menu_buttons = [
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*5), 
                            size=(600, 100), 
                            text="Create Savegame", 
                            response_function=load_new_savegame,
                            font=constants.TITLE_FONT),
        menu_classes.textInputBox(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*3),
                            size=(600,100),
                            button_name="Name"),
        menu_classes.button(location=(constants.DEFAULT_SCREEN_SIZE[0]*0.1 + 10, constants.DEFAULT_SCREEN_SIZE[1]*0.1 + 10), 
                            size=(150, 50), 
                            text="Back")
        
    ]
    
    # Shade over previous window
    temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA) 
    pygame.draw.rect(temp_surface, (0, 0, 0, 80), (0, 0, *constants.DEFAULT_SCREEN_SIZE))
    screen.blit(temp_surface, (0,0))
    
    
    
    loop = True
    tickCount = 0
    while loop: # Window loop
        tick_start = time.time()
        tickCount += 1
        keysPressed = []
        mouse_pos = pygame.mouse.get_pos()
        
        # Check events
        for event in pygame.event.get():
            if event.type == pygame.QUIT: # Quit program if window closed
                print("Closing program, goodbye!")
                quit()
                
            if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
                if menu_buttons[2].under_pointer: # Back button
                    return
                
                elif menu_buttons[0].under_pointer: # Create game button
                    game_id = account_details["savegames"][len(account_details["savegames"])-1]["display_details"]["id"] + 1 # automatically makes the ID 1 larger than the largest ID saved (which will always be the last one)
                    account_details["savegames"].append(load_new_savegame(constants, game_id, menu_buttons[1].content))
                    # resave account - TURN THIS INTO SAVE FUNCTION WHEN ACCOUNT OBJECT IS CREATED
                    with open(constants.FILE_PATH + "data/accounts.json", 'r+') as accountsDB:
                        accountsDBJson = load(accountsDB)
                        for i, account in enumerate(accountsDBJson):
                            if account["UUID"] == account_details["UUID"]:
                                accountsDBJson[i] = account_details
                        accountsDB.seek(0)
                        dump(accountsDBJson, accountsDB, indent=4)
                        accountsDB.close()
                        
                    create_new_game_files(account_details["UUID"], game_id)
                    
                    return
                
                elif menu_buttons[1].under_pointer: # Name input box
                    menu_buttons[1].response_function()
                else:
                    menu_buttons[1].selected = False
                
            if event.type == pygame.KEYDOWN:
                keysPressed.append(event.unicode) # Track keys pressed for text input
        
        # PROCESS
        for button in menu_buttons:
            button.update(mouse_pos, keysPressed)
        
        # RENDER
        # Draw background
        screen.blit(over_screen, (constants.DEFAULT_SCREEN_SIZE[0]*0.1, constants.DEFAULT_SCREEN_SIZE[1]*0.1))
        
        # Draw buttons
        for button in menu_buttons:
            screen = button.draw(screen, tickCount)
        
        # Draw text
        screen = draw_text("New Savegame", screen, constants.TITLE_FONT, 
                            (constants.DEFAULT_SCREEN_SIZE[0]//2, (constants.DEFAULT_SCREEN_SIZE[1]-over_screen_size[1])//2 + 70),
                            (0,0,0),
                            "centre", "centre")
        
        pygame.display.flip()

        # Wait for remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))




File: projects/final/functions/loops/options.py
def save_buttons_to_options(menu_buttons, account_details):
    
    keybindings = {}
    for button in menu_buttons[1:]: # buttons not including back button
        keybindings[ord(button.key)] = button.name
        
    # Re-include other keys that do not have buttons
    keybindings["1073742049"] = "sprint"
    keybindings["L_CLICK"] = "attack"
    
    # Update account details
    account_details["config"]["key_bindings"] = keybindings
    
    # Save over account with new details
    import json
    from classes.global_data import constants_structure
    constants = constants_structure()
    
    # get accounts
    with open(constants.FILE_PATH + "data/accounts.json", 'r') as accountsFile:
        accounts = json.load(accountsFile)
        
    for i, account in enumerate(accounts): # find account
        if account["UUID"] == account_details["UUID"]:
            accounts[i] = account_details # save over old account
            
    # save file
    with open(constants.FILE_PATH + "data/accounts.json", 'w') as accountsFile:
        json.dump(accounts, accountsFile, indent=4)
        accountsFile.close()
    
    return account_details


def run(screen, account_details):
    print("opened options")
    
    # Libraries
    import pygame
    import time

    # Local modules
    import classes.menu as menu_classes
    from classes.global_data import constants_structure, draw_text
    # Constants
    constants = constants_structure()
    
    # Buttons
    menu_buttons = [
        menu_classes.button(location=(10,10), 
                            size=(150, 50), 
                            text="Back",
                            font=constants.NORMAL_FONT)
    ]       
    
    # Generate buttons based off of keys
    listed_bindings = {}
    for key in account_details["config"]["key_bindings"]:
        if key.isnumeric() and int(key) < 110000: # not including attack key or sprint key
            listed_bindings[key] = account_details["config"]["key_bindings"][key]
            
    for i, key in enumerate(listed_bindings):
        menu_buttons.append(menu_classes.KeyBindingInput(location=(constants.DEFAULT_SCREEN_SIZE[0]//2 - 100  if i < len(listed_bindings)//2 else constants.DEFAULT_SCREEN_SIZE[0] - 100, ((constants.DEFAULT_SCREEN_SIZE[1]+ 30)//(len(listed_bindings)//2+4)*((i if i < len(listed_bindings)//2 else i - (len(listed_bindings)//2))+2))+ 50), 
                                                        size=(75,75),
                                                        name=listed_bindings[key],
                                                        key=chr(int(key))))

    # SPACE TO ADD MORE OPTIONS BUTTONS
        
    displayedError = None
    current_button = None
    tickCount = 0
    
    loop = True
    while loop:
        tick_start = time.time()
        tickCount += 1
        mouse_pos = pygame.mouse.get_pos()
        
        # CHECK EVENTS
        for event in pygame.event.get():
            if event.type == pygame.QUIT: # Quit program
                save_buttons_to_options(menu_buttons, account_details)
                print("Closing program, goodbye!")
                quit()
                
            if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
                if menu_buttons[0].under_pointer: # Back button
                    save_buttons_to_options(menu_buttons, account_details) # Save before menu is quit
                    return 
                
                a_button_pressed = False
                for i, button in enumerate(menu_buttons):
                    if button.under_pointer:
                        if button.response_function(): # Will return true if the button is being selected (false if being unselected)
                            current_button = i
                            a_button_pressed = True
                        else:
                            current_button = None # If button is deselected, there is no button
                    else:
                        button.selected = False
                        
                if not a_button_pressed:
                    current_button = None
                            
            if event.type == pygame.KEYDOWN:
                if current_button is not None:
                    if event.key < 110000:
                        key = chr(event.key)
                        # Check that key is not in use
                        possible = True
                        for button in menu_buttons[1:]:
                            if button.key == key and button != menu_buttons[current_button]:
                                possible = False
                                break
                        if possible: # Key is usable so change button data
                            menu_buttons[current_button].key = key
                            menu_buttons[current_button].selected = False
                            current_button = None
                        else: # Create error if key cannot be changed
                            displayedError = menu_classes.displayedError("This key is already in use", tickCount)
                        
        # PROCESS
        for button in menu_buttons:
            button.update(mouse_pos)
        
        # RENDER
        screen.fill("gray")
        
        # Draw error
        if displayedError != None:
            screen = displayedError.draw(screen)
        
        # Draw buttons
        for button in menu_buttons:
            screen = button.draw(screen)
            
        # Draw text
        screen = draw_text("Options", screen, constants.TITLE_FONT, [constants.DEFAULT_SCREEN_SIZE[0]//2, constants.DEFAULT_SCREEN_SIZE[1]//5], (0,0,0), "centre", "above")
        screen = draw_text("Keybindings", screen, constants.NORMAL_FONT, [constants.DEFAULT_SCREEN_SIZE[0]//2, constants.DEFAULT_SCREEN_SIZE[1]//5], (0,0,0), "centre", "below")
        
        pygame.display.flip()

        # Pause for remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))




File: projects/final/functions/loops/main_menu.py
def run(screen, account_details):
    print("Logged into account with UUID " + str(account_details["UUID"]) + 
        "\nAccount username is " + account_details["username"])
    
    # Libraries
    import pygame
    import time
    import json

    # Local modules
    import classes.menu as menu_classes
    from functions.loops.savegames import run as savegames
    from functions.loops.options import run as options
    from functions.loops.credits import run as game_credits
    from classes.global_data import constants_structure
    # Constants
    constants = constants_structure()


    # Buttons
    menu_buttons = [
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*3), 
                            size=(600, 100), 
                            text="Savegames", 
                            response_function=savegames,
                        font=constants.TITLE_FONT),
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*4), 
                            size=(600, 100), 
                            text="Options", 
                            response_function=options,
                        font=constants.TITLE_FONT),
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*5), 
                            size=(600, 100), 
                            text="Credits", 
                            response_function=game_credits,
                        font=constants.TITLE_FONT),
        menu_classes.button(location=(10,10), 
                            size=(300, 50), 
                            text="Log Out")
        
    ]



    
    loop = True
    while loop:
        tick_start = time.time()
        
        # FRAME CONSTANTS ONE
        mouse_pos = pygame.mouse.get_pos()
        
        # CHECK EVENTS
        for event in pygame.event.get():
            if event.type == pygame.QUIT: # Quit program
                print("Closing program, goodbye!")
                quit()
                
            if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
                for button in menu_buttons:
                    if button.under_pointer:
                        if button == menu_buttons[3]: # Back button
                            return
                        button.response_function(screen, account_details)
                        
                        # reset account details incase of changes
                        with open(constants.FILE_PATH + "data/accounts.json", 'r') as accountsFile:
                            accounts = json.load(accountsFile) 
                            
                        for account in accounts: # find account
                            if account["UUID"] == account_details["UUID"]:
                                account_details = account # save over old account data
                    else:
                        button.selected = False
                        
        
        # PROCESS
        for button in menu_buttons:
            button.update(mouse_pos)
        
        # RENDER
        screen.fill("gray")
        # Draw buttons
        for button in menu_buttons:
            screen = button.draw(screen)
            
        # Draw text
        content = constants.TITLE_FONT.render("Main Menu", True, (0,0,0))
        screen.blit(content,((constants.DEFAULT_SCREEN_SIZE[0]-content.get_width())//2, int((constants.DEFAULT_SCREEN_SIZE[1]-200)//5*1.5)))
        
        pygame.display.flip()

        # Pause for remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))




File: projects/final/functions/loops/pause_screen.py
def run(screen, key_bindings):
    import pygame
    import time
    
    import classes.menu as menu_classes
    
    from classes.global_data import constants_structure, draw_text
    constants = constants_structure()
    
    # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
    temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA) 
    temp_surface.fill((100,100,100,100))
    screen.blit(temp_surface, [0,0])
    
    # Buttons
    menu_buttons = [
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*3), 
                            size=(600, 100), 
                            text="Save and Quit", 
                            font=constants.TITLE_FONT),
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*5), 
                            size=(600, 100), 
                            text="Back",
                            font=constants.NORMAL_FONT)
    ]
    
    keysPressed = []
    loop = True
    while loop:
        tick_start = time.time()
        mouse_pos = pygame.mouse.get_pos()
        
        
        # CHECK EVENTS
        events = pygame.event.get()
        for event in events:
            if event.type == pygame.QUIT: # Quit program
                print("Closing program, goodbye!")
                quit()
                
            if event.type == pygame.KEYDOWN:
                if key_bindings.get(str(event.key)) == "pause":
                    loop = False
                    
            if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
                if menu_buttons[1].under_pointer: # Back button
                    return True # True means the game can continue and doesn't have to quit
                
                elif menu_buttons[0].under_pointer: # Save and quit button
                    return False # False means game must save and quit
        
        # PROCESS
        for button in menu_buttons:
            button.update(mouse_pos, keysPressed)
        
        # RENDER
        
        # Draw text
        screen = draw_text("Game Paused", screen, constants.TITLE_FONT, [constants.DEFAULT_SCREEN_SIZE[0]//2, constants.DEFAULT_SCREEN_SIZE[1]//3], (0,0,0), "centre", "above")
        pause_key = "P"
        screen = draw_text(f"Press {pause_key} to unpause", screen, constants.NORMAL_FONT, [constants.DEFAULT_SCREEN_SIZE[0]//2, constants.DEFAULT_SCREEN_SIZE[1]//3], (0,0,0), "centre", "below")
        
        # Draw buttons
        for button in menu_buttons:
            screen = button.draw(screen, 0)
        
        pygame.display.flip()
        
        # Pause for remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))
    return




File: projects/final/functions/loops/savegames.py
def run(screen, account_details):
    print("opened savegames")
    
    # Libraries
    import pygame
    import time

    # Local modules
    import classes.menu as menu_classes
    from classes.global_data import draw_text
    from classes.global_data import constants_structure
    import functions.algorithms.new_savegame
    # Constants
    constants = constants_structure()

    only_refreshing = True
    while only_refreshing: # Allows the page to be refreshed later so that the a savegame can be added to the list when it is created
        
        # Savegame buttons
        index = -1
        savegame_buttons = []
        savegame_button_size = (400, 200)
        for i, savegame in enumerate(account_details["savegames"]):
            if i%2 == 0:
                x_loc = (constants.DEFAULT_SCREEN_SIZE[0]//2) - savegame_button_size[0] - 5
            else:
                x_loc = (constants.DEFAULT_SCREEN_SIZE[0]//2) + 5
            savegame_buttons.append(menu_classes.savegameButton(location=( x_loc, 150 + ((len(savegame_buttons)//2) * (savegame_button_size[1] + 15)) ), 
                                                                size=savegame_button_size, 
                                                                savegame_display_details=savegame["display_details"],
                                                                game_data=[account_details["UUID"], savegame["display_details"]["id"]]))
            index = i
        
        # Calculate button position based on index
        index += 1
        if index%2 == 0:
            x_loc = (constants.DEFAULT_SCREEN_SIZE[0]//2) - savegame_button_size[0] - 5
        else:
            x_loc = (constants.DEFAULT_SCREEN_SIZE[0]//2) + 5
        new_savegame_location = ( x_loc, 
                                150 + ((len(savegame_buttons)//2) * (savegame_button_size[1] + 15)) )
        
        # Buttons
        menu_buttons = [
            menu_classes.button(location=(10,10), 
                                size=(150, 50), 
                                text="Back",
                                font=constants.NORMAL_FONT),
            menu_classes.button(location=new_savegame_location, 
                                size=(400, 200), 
                                text="+", 
                                response_function=functions.algorithms.new_savegame.entry_loop,
                                font=constants.TITLE_FONT)
        ]
        
        loop = True
        while loop:
            tick_start = time.time()
            mouse_pos = pygame.mouse.get_pos()
            
            # CHECK EVENTS
            for event in pygame.event.get():
                if event.type == pygame.QUIT: # Quit the program
                    print("Closing program, goodbye!")
                    quit()
                    
                if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
                    if menu_buttons[0].under_pointer: # Back button
                        return
                    elif menu_buttons[1].under_pointer: # New savegame button
                        menu_buttons[1].response_function(screen, account_details)
                        loop = False
                        break
                    else: # Check savegame buttons
                        for i, savegame in enumerate(savegame_buttons):
                            if savegame.under_pointer:
                                savegame.response_function(screen) # Open savegame details window
                                
                                # Update time for most recently opened
                                from datetime import datetime
                                now = datetime.now()
                                account_details["savegames"][i]["display_details"]["last_save"] = now.strftime("%d/%m/%Y, %H:%M")
                                loop = False
                                break
            
            # PROCESS
            for button in menu_buttons:
                button.update(mouse_pos)
            for button in savegame_buttons:
                button.update(mouse_pos)
            
            # RENDER
            screen.fill("gray")
            
            # Draw buttons
            for button in menu_buttons:
                screen = button.draw(screen)
            for button in savegame_buttons:
                screen = button.draw(screen)
                
            # Draw text
            screen = draw_text("Savegames", screen, constants.TITLE_FONT, 
                                (constants.DEFAULT_SCREEN_SIZE[0]//2, 70),
                                (0,0,0),
                                "centre", "centre")
            
            pygame.display.flip()

            # Pause for remainder of tick
            time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))




File: projects/final/functions/loops/savegame_options.py
def open_savegame(account_id, savegame_id, display_data, screen):
    print("editing savegame")
    
    # Libraries
    import pygame
    import time
    from json import load, dump
    
    # Local modules
    import classes.menu as menu_classes
    from classes.global_data import draw_text
    from classes.global_data import constants_structure
    # Constants
    constants = constants_structure()

    # Create background
    over_screen_size = (constants.DEFAULT_SCREEN_SIZE[0]*0.8, constants.DEFAULT_SCREEN_SIZE[1]*0.8)
    over_screen = pygame.Surface(over_screen_size) 
    background_texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/buttons/ratio1-2.0.png").convert(), over_screen_size) # Use text input button design
    over_screen.blit(background_texture, (0,0))

    # Buttons
    from game_main import main_game
    from functions.algorithms.delete_savegame import delete_savegame
    menu_buttons = [
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*3), 
                            size=(600, 100), 
                            text="Play", 
                            response_function=main_game,
                            font=constants.TITLE_FONT),
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-300)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*4.5),
                            size=(300,100),
                            text="Delete",
                            response_function=delete_savegame,
                            font=constants.NORMAL_FONT),
        menu_classes.button(location=(constants.DEFAULT_SCREEN_SIZE[0]*0.1 + 10, constants.DEFAULT_SCREEN_SIZE[1]*0.1 + 10), 
                            size=(150, 50), 
                            text="Back")
        
    ]
    
    # shade over menu
    temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA) 
    pygame.draw.rect(temp_surface, (0, 0, 0, 80), (0, 0, *constants.DEFAULT_SCREEN_SIZE))
    screen.blit(temp_surface, (0,0))
    
    loop = True
    tickCount = 0
    while loop:
        tick_start = time.time()
        tickCount += 1
        keysPressed = []
        mouse_pos = pygame.mouse.get_pos()
        
        # CHECK EVENTS
        for event in pygame.event.get():
            if event.type == pygame.QUIT: # Quit progra 
                print("Closing program, goodbye!")
                quit()
                
            if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
                if menu_buttons[2].under_pointer: # Back button
                    return
                
                elif menu_buttons[0].under_pointer:
                    main_game(account_id, savegame_id, screen) # Run game loop
                    return
                
                elif menu_buttons[1].under_pointer:
                    delete_savegame(account_id, savegame_id) # Delete game
                    return
                
            if event.type == pygame.KEYDOWN:
                keysPressed.append(event.unicode) # Track key
        
        # PROCESS
        for button in menu_buttons:
            button.update(mouse_pos, keysPressed)
        
        # RENDER
        # Draw background
        screen.blit(over_screen, (constants.DEFAULT_SCREEN_SIZE[0]*0.1, constants.DEFAULT_SCREEN_SIZE[1]*0.1))
        
        # Draw buttons
        for button in menu_buttons:
            screen = button.draw(screen, tickCount)
        
        # Draw text
        screen = draw_text(display_data["name"], screen, constants.TITLE_FONT, 
                            (constants.DEFAULT_SCREEN_SIZE[0]//2, (constants.DEFAULT_SCREEN_SIZE[1]-over_screen_size[1])//2 + 140),
                            (0,0,0),
                            "centre", "centre")
        
        pygame.display.flip()

        # Wait for remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))




File: projects/final/functions/loops/log_in_loop.py
def run(screen):
    print("log in button pressed")
    # Libraries
    import pygame
    import time

    # Local modules
    import classes.menu as menu_classes
    from functions.algorithms.log_in import do_log_in
    from classes.global_data import constants_structure
    from functions.loops.main_menu import run as main_menu
    # Constants
    constants = constants_structure()

    # Buttons
    menu_buttons = [
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*5), 
                            size=(600, 100), 
                            text="Log-In", 
                            response_function=do_log_in,
                            font=constants.TITLE_FONT),
        menu_classes.textInputBox(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*3),
                            size=(600,100),
                            button_name="Password",
                            protected=True),
        menu_classes.textInputBox(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*2),
                            size=(600,100),
                            button_name="Username"),
        menu_classes.button(location=(10,10), 
                            size=(150, 50), 
                            text="Back")
    ]

    displayedError = None

    
    loop = True
    tickCount = 0
    responce = {}
    while loop:
        tick_start = time.time()
        tickCount += 1
        
        # FRAME CONSTANTS ONE
        mouse_pos = pygame.mouse.get_pos()
        keysPressed = []
        
        # CHECK EVENTS
        for event in pygame.event.get():
            if event.type == pygame.QUIT: # Program quit
                print("Closing program, goodbye!")
                quit()
                
            if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
                if menu_buttons[0].under_pointer: # Log-in button
                    
                    responce = menu_buttons[0].response_function(menu_buttons[2].content, # Username
                                                                menu_buttons[1].content)  # Password
                
                elif menu_buttons[3].under_pointer: # back button
                    return
                    
                for button in menu_buttons[1:]: # Text inputs
                    if button.under_pointer:
                        button.response_function()
                    else:
                        button.selected = False
                        
            if event.type == pygame.KEYDOWN:
                keysPressed.append(event.unicode)
                
        # PROCESS
        for button in menu_buttons:
            button.update(mouse_pos, keysPressed)
            
        # Wait for responce from login button
        if responce != {}:
            if responce["returnType"] == 1:
                main_menu(screen, responce["account_details"])
                
                return # After main menu loop is finished, create account section should be skipped in exchange for going directly back to account select
            else:
                displayedError = menu_classes.displayedError(responce["returnMessage"], tickCount)
                
        
        # RENDER
        screen.fill("gray")
        
        # Draw buttons
        for button in menu_buttons:
            screen = button.draw(screen, tickCount)
        
        # Draw error
        if displayedError != None:
            screen = displayedError.draw(screen)
            
        # Draw text
        content = constants.TITLE_FONT.render("Log-In", True, (0,0,0))
        screen.blit(content,((constants.DEFAULT_SCREEN_SIZE[0]-content.get_width())//2, int((constants.DEFAULT_SCREEN_SIZE[1]-200)//10*1.25)))
        
        pygame.display.flip()

        # Pause for remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))




File: projects/final/functions/loops/create_account_loop.py
def run(screen):
    print("create account button pressed")
    # Libraries
    import pygame
    import time

    # Local modules
    import classes.menu as menu_classes
    from functions.algorithms.account_creation import addAccount as account_creation_check
    from classes.global_data import constants_structure
    from functions.loops.main_menu import run as main_menu
    # Constants
    constants = constants_structure()


    # Buttons
    menu_buttons = [
        menu_classes.button(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*5.5), 
                            size=(600, 100), 
                            text="Create", 
                            response_function=account_creation_check,
                        font=constants.TITLE_FONT),
        menu_classes.textInputBox(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*4.5),
                            size=(600,100),
                            button_name="Re-enter Password",
                            protected=True),
        menu_classes.textInputBox(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*3.5),
                            size=(600,100),
                            button_name="Password",
                            protected=True),
        menu_classes.textInputBox(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*2.5),
                            size=(600,100),
                            button_name="Display Name"),
        menu_classes.textInputBox(location=((constants.DEFAULT_SCREEN_SIZE[0]-600)//2, (constants.DEFAULT_SCREEN_SIZE[1]-200)//5*1.5),
                            size=(600,100),
                            button_name="Username"),
        menu_classes.button(location=(10,10), 
                            size=(150, 50), 
                            text="Back")
        
    ]

    displayedError = None


    
    loop = True
    tickCount = 0
    responce = {}
    while loop: # Meny loop
        tick_start = time.time()
        tickCount += 1
        mouse_pos = pygame.mouse.get_pos()
        keysPressed = []
        
        # CHECK EVENTS
        for event in pygame.event.get():
            if event.type == pygame.QUIT: # Quit program
                print("Closing program, goodbye!")
                quit()
                
            if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
                if menu_buttons[0].under_pointer: # Create button
                    responce = menu_buttons[0].response_function(menu_buttons[4].content,   # Username
                                                        menu_buttons[1].content,            # Re-enter password
                                                        menu_buttons[2].content,            # Password (order is unnecessary)
                                                        menu_buttons[3].content,            # Display name
                                                        "")
                elif menu_buttons[5].under_pointer: # back button
                    return
                for button in menu_buttons[1:]: # All text inputs
                    if button.under_pointer:
                        button.response_function()
                    else:
                        button.selected = False
                        
            if event.type == pygame.KEYDOWN:
                keysPressed.append(event.unicode)
                
        # PROCESS
        for button in menu_buttons:
            button.update(mouse_pos, keysPressed)
            
        # Check responce if account has been created
        if responce != {}:
            if responce["returnType"] == 1:
                main_menu(screen, responce["account_details"])
                
                return # After main menu loop is finished, create account section should be skipped in exchange for going directly back to account select
            else:
                displayedError = menu_classes.displayedError(responce["returnMessage"], tickCount)
                
        
        # RENDER
        screen.fill("gray")
        
        # Draw buttons
        for button in menu_buttons:
            screen = button.draw(screen, tickCount)
        
        # Draw error
        if displayedError != None:
            screen = displayedError.draw(screen)
        
        # Draw title
        content = constants.TITLE_FONT.render("Create Account", True, (0,0,0))
        screen.blit(content,((constants.DEFAULT_SCREEN_SIZE[0]-content.get_width())//2, int((constants.DEFAULT_SCREEN_SIZE[1]-200)//10)))
        
        # Draw screen to actual window
        pygame.display.flip()

        # Wait for remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))




File: projects/final/functions/loops/transition_animation.py
import pygame
import time

def animation(screen, player_loc, game_window, last_room_screenshot, gui_window, background, player):
    from classes.global_data import constants_structure, draw_text
    constants = constants_structure()
    processTime = 1
    
    if player_loc == "top":
        player_loc = "up"
    elif player_loc == "bottom":
        player_loc = "down"
    
    # First part is screen sliding, second part is player walking in
    first_part_frames = 10
    second_part_frames = 20
    
    # Run each frame
    for frame in range(first_part_frames + second_part_frames): 
        tick_start = time.time()
        screen.blit(background, (0,0))
        if frame <= first_part_frames: # If first animation
            # Do move according to direction
            if player_loc == "up":
                screen.blit(last_room_screenshot, (0, 0 + (frame * (constants.GAME_WINDOW_SIZE[1]//first_part_frames))))
                screen.blit(game_window, (0, 0 - constants.GAME_WINDOW_SIZE[1] + (frame * (constants.GAME_WINDOW_SIZE[1]//first_part_frames))))
            elif player_loc == "down":
                screen.blit(last_room_screenshot, (0, 0 - (frame * (constants.GAME_WINDOW_SIZE[1]//first_part_frames))))
                screen.blit(game_window, (0, constants.GAME_WINDOW_SIZE[1] - (frame * (constants.GAME_WINDOW_SIZE[1]//first_part_frames))))
            elif player_loc == "left":
                screen.blit(last_room_screenshot, (0 + (frame * (constants.GAME_WINDOW_SIZE[0]//first_part_frames)), 0))
                screen.blit(game_window, (0 - constants.GAME_WINDOW_SIZE[0] + (frame * (constants.GAME_WINDOW_SIZE[0]//first_part_frames)), 0))
            elif player_loc == "right":
                screen.blit(last_room_screenshot, (0 - (frame * (constants.GAME_WINDOW_SIZE[0]//first_part_frames)), 0))
                screen.blit(game_window, (constants.GAME_WINDOW_SIZE[0] - (frame * (constants.GAME_WINDOW_SIZE[0]//first_part_frames)), 0))
        
        else: # If second half of animation
            screen.blit(game_window,(0,0))
            # Find animation frame
            anim_frame = (frame-first_part_frames) // 3
            while anim_frame >= len(player.assets[f"run_{player_loc}"]):
                anim_frame -= len(player.assets[f"run_{player_loc}"])
            
            # Move player to position and draw
            pos = [player.x_pos, player.y_pos]
            if player_loc == "up":
                pos[1] = game_window.get_height() - ((frame-first_part_frames) / second_part_frames * (game_window.get_height() - player.y_pos))
            elif player_loc == "down":
                pos[1] =  ((frame-first_part_frames) / second_part_frames * (player.y_pos + player.size[1])) - player.size[1]
            elif player_loc == "left":
                pos[0] = game_window.get_width() - ((frame-first_part_frames) / second_part_frames * (game_window.get_width() - player.x_pos))
            elif player_loc == "right":
                pos[0] = ((frame-first_part_frames) / second_part_frames * (player.x_pos + player.size[0])) - player.size[0]
            screen.blit(player.hand_texture, pos)
            # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
            temp_surface = pygame.Surface(player.size, pygame.SRCALPHA) 
            temp_surface.blit(pygame.transform.scale(player.assets[f"run_{player_loc}"][anim_frame], player.size),(0,0))
            screen.blit(temp_surface, pos)
            
        screen.blit(gui_window,(constants.GAME_WINDOW_SIZE[0], 0) if constants.LANDSCAPE else (0, constants.GAME_WINDOW_SIZE[1]))

        # Draw FPS
        thefps = int((1 / processTime)*100)/100
        draw_text(f"FPS: {thefps}", screen, constants.SMALL_FONT, (10,10), (255,255,255), "left", "below")
        
        pygame.display.flip()
        
        processTime = time.time()-tick_start
        time.sleep(max(0, (1/(constants.MENU_FPS*2))-(time.time()-tick_start)))




File: projects/final/functions/loops/credits.py
def run(screen, account_details):
    print("entered credits screen")
    
    # Libraries
    import pygame
    import time

    # Local modules
    import classes.menu as menu_classes
    from classes.global_data import constants_structure
    # Constants
    constants = constants_structure()


    # Buttons
    menu_buttons = [
        menu_classes.button(location=(10,10), 
                            size=(150, 50), 
                            text="Back",
                            font=constants.NORMAL_FONT)
    ]


    creditsText = "This game was designed\nand written by George Berkeley\n\nAssets were taken and derived from \nhttps://secrethideout.itch.io/\nrogue-dungeon-tileset-16x16"
    lines = creditsText.split("\n")
    
    loop = True
    while loop:
        tick_start = time.time()
        
        # FRAME CONSTANTS ONE
        mouse_pos = pygame.mouse.get_pos()
        
        # CHECK EVENTS
        for event in pygame.event.get():
            if event.type == pygame.QUIT: # Quit program
                print("Closing program, goodbye!")
                quit()
                
            if event.type == pygame.MOUSEBUTTONDOWN: # Check buttons being pressed
                if menu_buttons[0].under_pointer: # Back button
                    return
        
        # PROCESS
        for button in menu_buttons:
            button.update(mouse_pos)
        
        # RENDER
        screen.fill("gray")
        
        # Draw buttons
        for button in menu_buttons:
            screen = button.draw(screen)
        
        # Draw text
        for line_index, line in enumerate(lines):
            content = constants.NORMAL_FONT.render(line, True, (0,0,0))
            screen.blit(content, ((constants.DEFAULT_SCREEN_SIZE[0] - content.get_width())//2, (constants.DEFAULT_SCREEN_SIZE[1] - (content.get_height()*len(lines)))//2 + (content.get_height()*line_index)))
        
        
        pygame.display.flip()

        # Wait for remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))




File: projects/final/functions/loops/inventory.py
import pygame
import time

def run(inventory, screen, key_bindings):
    
    from classes.global_data import constants_structure, draw_text
    constants = constants_structure()
    
    # Load textures
    inv_texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/inventory.png").convert(), ((constants.DEFAULT_SCREEN_SIZE[1] * 0.9)//5*3, constants.DEFAULT_SCREEN_SIZE[1] * 0.9))
    square_size = (inv_texture.get_width()//3, inv_texture.get_height()//5)
    inv_location = ((constants.DEFAULT_SCREEN_SIZE[0] - inv_texture.get_width())//2, (constants.DEFAULT_SCREEN_SIZE[1] - inv_texture.get_height())//2)
    selected_inv_texture = pygame.transform.scale(pygame.image.load(constants.FILE_PATH + f"project_lib/assets/menu/inventory_highlighted.png").convert(), square_size)
    
    # Creating translucent shapes requires a custom surface to be created that can take in Alpha colours
    temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA)
    temp_surface.fill((100,100,100,200))
    screen.blit(temp_surface, [0,0])
    background = screen.copy()
    
    # Loop constants
    selected_item = None
    throw_away_items = []
        
    loop = True
    while loop:
        tick_start = time.time()
        mouse_pos = pygame.mouse.get_pos()
        
        # Calculate what square mouse is on
        selected_square = (((mouse_pos[0] - inv_location[0])//square_size[0]),   (mouse_pos[1] - inv_location[1])//square_size[1]) 
        selected_index = None
        
        # Then calculate what inventory index that square is
        if (selected_square[0] >= 0 and selected_square[0] < 3) and (selected_square[1] >= 0 and selected_square[1] < 4) : # for top 12
            selected_index = selected_square[1] * 3 + selected_square[0] + 2
        elif ((selected_square[0] == 0) or (selected_square[0] == 2)) and (selected_square[1] == 4): # for lower two
            selected_index = selected_square[0]//2
            
        
        # CHECK EVENTS
        events = pygame.event.get()
        for event in events:
            if event.type == pygame.QUIT: # Quit program
                print("Closing program, goodbye!")
                quit()
                
            if event.type == pygame.KEYDOWN:
                if key_bindings.get(str(event.key)) == "inventory":
                    loop = False # If quit button is pressed
                    
            if event.type == pygame.MOUSEBUTTONUP: # When mouse is released
                if selected_index != None: # If an item is being hovered over
                    if selected_item == None: # If there is no item being held, pick that item up
                        selected_item = inventory[selected_index]
                        inventory[selected_index] = None
                    else: # If there is an item being held, check that the item can be placed in that square
                        temp = None
                        if inventory[selected_index] != None: # Check place is empty
                            temp = inventory[selected_index]
                            
                        do_move = True
                        # Check type fits square
                        if selected_index == 8:
                            if selected_item.sort != "ring":
                                do_move = False
                        elif selected_index == 9:
                            if selected_item.sort != "necklace":
                                do_move = False
                        elif selected_index == 10:
                            if selected_item.sort != "bracelet":
                                do_move = False
                        elif selected_index == 11:
                            if selected_item.sort != "helmet":
                                do_move = False
                        elif selected_index == 12:
                            if selected_item.sort != "chestplate":
                                do_move = False
                        elif selected_index == 13:
                            if selected_item.sort != "boots":
                                do_move = False
                        if do_move: # If all tests pass, place item there
                            inventory[selected_index] = selected_item
                            selected_item = temp
                            
                        
                elif selected_item != None: # If square is not being hovered over, but mouse has an item, then item is being dropped
                    throw_away_items.append(selected_item)
                    selected_item = None
                    
        
        # RENDER
        screen.blit(background, (0,0))
        
        # Draw inventory
        inv_location = ((constants.DEFAULT_SCREEN_SIZE[0] - inv_texture.get_width()) //2, (constants.DEFAULT_SCREEN_SIZE[1] - inv_texture.get_height()) //2)
        temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA) 
        temp_surface.blit(inv_texture, inv_location)
        screen.blit(temp_surface, (0,0))
        
        # Draw items
        temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA)
        # Lower two are handled seperatley 
        if inventory[0] != None:
                temp_surface.blit(pygame.transform.scale(inventory[0].inv_texture, (square_size[0]*0.7, square_size[1]*0.7)), 
                                    (((constants.DEFAULT_SCREEN_SIZE[0] - inv_texture.get_width())//2) + square_size[0]*0.15,   (constants.DEFAULT_SCREEN_SIZE[1] + inv_texture.get_height())//2 - square_size[1] + square_size[1]*0.15))
        if inventory[1] != None:
                temp_surface.blit(pygame.transform.scale(inventory[1].inv_texture, (square_size[0]*0.7, square_size[1]*0.7)), 
                                    (((constants.DEFAULT_SCREEN_SIZE[0] - inv_texture.get_width())//2) + (square_size[0] * 2) + square_size[0]*0.15,   (constants.DEFAULT_SCREEN_SIZE[1] + inv_texture.get_height())//2 - square_size[1] + square_size[1]*0.15))
        for i, item in enumerate(inventory[2:]): # Then do all other items
            if item != None:
                temp_surface.blit(pygame.transform.scale(item.inv_texture, (square_size[0]*0.7, square_size[1]*0.7)), 
                                    ((i - (((i)//3)*3)) * square_size[0] + ((constants.DEFAULT_SCREEN_SIZE[0] - inv_texture.get_width())//2) + square_size[0]*0.15,   (i)//3 * square_size[1] + ((constants.DEFAULT_SCREEN_SIZE[1] - inv_texture.get_height())//2) + square_size[1]*0.15))
        
        screen.blit(temp_surface, (0,0))
        
        
        # Item hover
        temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA) 
        if (mouse_pos[0] > inv_location[0]  and  mouse_pos[0] < inv_location[0] + (3*square_size[0])  and 
            mouse_pos[1] > inv_location[1]  and  mouse_pos[1] < inv_location[1] + (5*square_size[1])  and  # within boundries
            selected_square != (1, 4)): # dont use empty square
            temp_surface.blit(selected_inv_texture, (selected_square[0] * square_size[0] + inv_location[0], selected_square[1] * square_size[1] + inv_location[1]))
        
        screen.blit(temp_surface, (0,0))
        
        # Draw hovered over item indicator
        temp_surface = pygame.Surface(constants.DEFAULT_SCREEN_SIZE, pygame.SRCALPHA) 
        if selected_item != None:
            temp_surface.blit(pygame.transform.scale(selected_item.inv_texture, square_size), (mouse_pos[0] - (square_size[0]//2), mouse_pos[1] - (square_size[1]//2)))
        screen.blit(temp_surface, (0,0))
        
        pygame.display.flip()

        # Wait for remainder of tick
        time.sleep(max(0, (1/constants.MENU_FPS)-(time.time()-tick_start)))
        
    return inventory, throw_away_items




File: projects/final/data/default_config.json
{
    "volume":{
        "master_volume": 1,
        "enemy_volume": 0.5,
        "player_volume": 0.5,
        "menu_volume": 0.5,
        "music": 0.5
    },

    "key_bindings":{
        "119": "up",
        "115": "down",
        "97": "left",
        "100": "right",
        "102": "inventory",
        "101": "switch_hand",
        "1073742049": "sprint",
        "112": "pause",
        "49": "main_hand",
        "50": "off_hand",
        "32": "boost",
        "L_CLICK": "attack",
        "114": "interact"
    },

    "max_FPS": 30,

    "mini_map_displayed": true,
    "inventory_displayed": true,
    "armour_displayed": true
}



File: projects/final/data/default_savegame.json
{
    "display_details": {
        "name" : "",
        "level": 0,
        "last_save": "",
        "created": ""
    }
}



File: projects/final/data/accounts.json
[
    {
        "UUID": 1,
        "username": "george",
        "hashed_password": "FWij^Z'imehZ'Xj8/'j^[P",
        "display_name": "George",
        "profileImage": "",
        "config": {
            "volume": {
                "master_volume": 1,
                "enemy_volume": 0.5,
                "player_volume": 0.5,
                "menu_volume": 0.5,
                "music": 0.5
            },
            "key_bindings": {
                "119": "up",
                "115": "down",
                "97": "left",
                "100": "right",
                "102": "inventory",
                "101": "switch_hand",
                "112": "pause",
                "49": "main_hand",
                "50": "off_hand",
                "32": "boost",
                "114": "interact",
                "1073742049": "sprint",
                "L_CLICK": "attack"
            },
            "max_FPS": 30,
            "mini_map_displayed": true,
            "inventory_displayed": true,
            "armour_displayed": true
        },
        "savegames": [
            {
                "display_details": {
                    "name": "My New Savegame",
                    "id": 0,
                    "level": 0,
                    "last_save": "05/01/2024, 10:48",
                    "created": "05/01/2024"
                }
            },
            {
                "display_details": {
                    "name": "My Game",
                    "level": 0,
                    "last_save": "Not saved",
                    "created": "25/04/2024",
                    "id": 1
                }
            },
            {
                "display_details": {
                    "name": "Charlie",
                    "level": 0,
                    "last_save": "Not saved",
                    "created": "26/04/2024",
                    "id": 2
                }
            }
        ]
    },
    {
        "UUID": 2,
        "username": "shmung",
        "hashed_password": "kdi^&M]ki&MXj8/&i^cP",
        "display_name": "shmungy",
        "profileImage": "",
        "config": {
            "volume": {
                "master_volume": 1,
                "enemy_volume": 0.5,
                "player_volume": 0.5,
                "menu_volume": 0.5,
                "music": 0.5
            },
            "key_bindings": {
                "119": "up",
                "115": "down",
                "97": "left",
                "100": "right",
                "102": "inventory",
                "101": "switch_hand",
                "1073742049": "sprint",
                "112": "pause",
                "49": "main_hand",
                "50": "off_hand",
                "32": "boost",
                "L_CLICK": "attack",
                "114": "interact"
            },
            "max_FPS": 30,
            "mini_map_displayed": true,
            "inventory_displayed": true,
            "armour_displayed": true
        },
        "savegames": [
            {
                "display_details": {
                    "name": "new game",
                    "id": 0,
                    "level": 0,
                    "last_save": "10/01/2024, 15:26",
                    "created": "10/01/2024"
                }
            },
            {
                "display_details": {
                    "name": "another savegame",
                    "id": 1,
                    "level": 0,
                    "last_save": "10/01/2024, 15:28",
                    "created": "10/01/2024"
                }
            }
        ]
    }
]



File: projects/final/data/account_games/player_default.json
{
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



File: projects/final/data/account_games/1_games/2_levels/rooms_-1/player.json
{
    "lives": 3,
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



File: projects/final/data/account_games/1_games/2_levels/rooms_-1/1.json
{
    "id": 1, 
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null}, 
        "right": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]}, 
        "up": {"type": "keyhole", "complete": false, "colour": [255, 100, 100, 100]}, 
        "down": {"type": "kill_count", "complete": false, "num": 1, "colour": null}
        }, 
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 2, 2, 0, 0, 0, 0, {"id":5,"colour":[255, 100, 100, 100]}, {"id":6,"colour":[255, 100, 100, 100]}, 1], 
        [1, 2, {"id": 3, "pos": "vbr"}, 0, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, {"id": 8, "pos": "htl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 4, 0, 0, 7], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 4, {"id": 12, "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, {"id": 11, "pos": "htl", "colour": [255, 100, 100, 100]}, 0, 2, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 10, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
        ],
    
        "entities": [
            {"name": "goblin", "x": 8, "y": 4},
            {"name": "item", "x": 400, "y": 400, "item": "key", "payload": {"colour": [255, 100, 100, 100]}}
        ]
    }



File: projects/final/data/account_games/1_games/2_levels/rooms_-1/2.json
{
    "id":2,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "up": null,
        "down": null
        
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 1
        },
        {"name": "goblin",
        "x": 8,
        "y": 8
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_-1/layout.json
[   [0, 0, 0, 0, 0],
    [0, 0, 5, 0, 0],
    [0, 2, 1, 3, 0],
    [0, 0, 4, 0, 0],
    [0, 0, 0, 0, 0]
]



File: projects/final/data/account_games/1_games/2_levels/rooms_-1/3.json
{
    "id":3,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "right": null,
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 2, 2, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_-1/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 2, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 4, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, {"id": 3, "pos": "vtl"}, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_-1/5.json
{
    "id":5,
    "doors": {
        "left": null,
        "right": null,
        "up": null,
        "down": {"type": "kill_count", "complete": false, "num": 2, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 4, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_0/6.json
{
    "id":6,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [7, 0, 4, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 4, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 7,
        "y": 4
        },
        {"name": "goblin",
        "x": 7,
        "y": 5
        },
        {"name": "crate",
        "x":2,
        "y":3.5
        },
        {"name": "crate",
        "x":2,
        "y":4.5
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_0/7.json
{
    "id":7,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 1, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "item", "x": 400, "y": 400, "item": "key", "payload": {"colour": [255, 100, 100, 100]}}
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_0/10.json
{
    "id":10,
    "doors": {
        "left": {"type": "powered", "complete": false, "colour": [150, 150, 255, 100]},
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 1, 1, 1, 1, 1], 
        [7, 0, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, {"id": 5, "colour": [150, 150, 255, 100]}, 0, 0, 1], 
        [7, 0, 0, 0, 0, 1, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_0/player.json
{
    "lives": 3,
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



File: projects/final/data/account_games/1_games/2_levels/rooms_0/1.json
{
    "id": 1, 
    "doors": {
        "left": null, 
        "right": {"type": "kill_count", "complete": false, "num": 1, "colour": null}, 
        "up": null, 
        "down": null
        }, 
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, {"id": 3, "pos": "vtr"}, 0, 0, 1, 0, 0, 7], 
        [1, 0, 0, {"id": 3, "pos": "vbr"}, 0, 0, 1, 0, 0, 7], 
        [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ],
    
        "entities": [
            {"name": "goblin", "x": 8, "y": 4}
        ]
    }



File: projects/final/data/account_games/1_games/2_levels/rooms_0/11.json
{
    "id":11,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "kill_count", "complete": false, "num": 7, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 4,
        "y": 2
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_0/2.json
{
    "id":2,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "down": {"type": "keyhole", "complete": false, "colour": [255, 100, 100, 100]}
        
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 1
        },
        {"name": "goblin",
        "x": 8,
        "y": 8
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_0/layout.json
[   [0, 0, 0, 0, 0],
    [0, 4, 5, 6, 0],
    [1, 2, 0, 8, 11],
    [0, 3, 7, 9, 10],
    [0, 0, 0, 0, 0]
]



File: projects/final/data/account_games/1_games/2_levels/rooms_0/3.json
{
    "id":3,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 3, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, 10, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_0/8.json
{
    "id":8,
    "doors": {
        "left": null,
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, {"id":8, "pos": "vbl", "colour": [255, 100, 100, 100]}, {"id":8, "pos": "vbr", "colour": [255, 100, 100, 100]}, 1, 1, 1, 1], 
        [1, 0, {"id": 6, "colour": [255, 100, 100, 100], "flicked": false}, 0, 0, 0, 0, 2, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 1, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 1, 2, 2, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 1,
        "y": 1
        },
        {"name": "goblin",
        "x": 1.5,
        "y": 1
        },
        {"name": "goblin",
        "x": 2.3,
        "y": 1.5
        },
        {"name": "goblin",
        "x": 1,
        "y": 1.7
        },
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 1.4,
        "y": 2
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_0/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 4, "colour": null},
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 2, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 7],
        [1, 1, 1, 1, 1, 4, 1, 0, 0, 7],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, {"id": 3, "pos": "vtl"}, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_0/5.json
{
    "id":5,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [7, 0, 4, 0, 1, 0, 0, 0, 0, 7],
        [7, 0, 0, 0, 1, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_0/9.json
{
    "id":9,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 16, "colour": null},
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 1, {"id":8, "pos": "hbl", "colour": [150, 150, 255, 100]}, {"id":8, "pos": "hbr", "colour": [150, 150, 255, 100]}, 1, 0, 0, 1], 
        [1, 0, {"id": 6, "colour": [255, 100, 100, 100], "flicked": false}, 1, {"id":8, "pos": "hbl", "colour": [150, 255, 150, 100]}, {"id":8, "pos": "hbr", "colour": [150, 255, 150, 100]}, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, {"id": 6, "colour": [150, 150, 255, 100], "flicked": false}, 0, 0, 0, 0, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 6,
        "y": 3
        },
        {"name": "goblin",
        "x": 5,
        "y": 3
        },
        {"name": "goblin",
        "x": 4,
        "y": 3
        },
        {"name": "goblin",
        "x": 6,
        "y": 6
        },
        {"name": "goblin",
        "x": 5,
        "y": 6
        },
        {"name": "goblin",
        "x": 4,
        "y": 6
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_1/6.json
{
    "id":6,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "powered", "complete": false, "colour": [150, 255, 150, 100]}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 1, 1, 1, 1, 1, 1, 1], 
        [7, 0, 0, {"id":11, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 4, 0, 1], 
        [7, 0, 0, {"id":11, "pos": "vbl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 4, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 6
        },
        {"name": "goblin",
        "x": 6,
        "y": 0.5
        },
        {"name": "goblin",
        "x": 3,
        "y": 1
        },
        {"name": "goblin",
        "x": 5,
        "y": 1.5,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 150, 255, 100]},
                        "chance": 1
                        }]
                    }]
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_1/7.json
{
    "id":7,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 3, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 3, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [150, 150, 255, 100]}, 0, 0, 0, 1], 
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 1, 0, 1, 0, 0, 0, 1], 
        [1, 1, 0, 1, 0, 1, 0, 0, 0, 1], 
        [7, 0, 4, 1, 0, 1, 0, 0, 0, 7], 
        [7, 0, 0, 0, 0, 1, 0, 0, 0, 7], 
        [1, {"id":8, "pos": "htl", "colour": [255, 100, 100, 100]}, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 4, 0, 0, 0, 0, 0, {"id": 5, "colour": [150, 150, 255, 100]}, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 1, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 7,
        "y": 8,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 100, 100, 100]},
                        "chance": 1
                        }]
                    }]
        },
        {"name": "goblin",
        "x": 7,
        "y": 3
        },
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 6,
        "y": 2
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_1/10.json
{
    "id":10,
    "doors": {
        "left": {"type": "empty", "complete": false, "num": 1, "colour": null},
        "right": null,
        "up": {"type": "powered", "complete": false, "colour": [150, 255, 150, 100]},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, {"id": 5, "colour": [150, 255, 150, 100]}, 4, {"id":8, "pos": "vtr", "colour": [150, 150, 255, 100]}, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 4, {"id": 5, "colour": [255, 255, 150, 100]}, 1],
        [1, 0, 0, {"id":8, "pos": "vbr", "colour": [150, 150, 255, 100]}, 0, 0, {"id":8, "pos": "vbl", "colour": [255, 100, 100, 100]}, 0, 0, 1],
        [1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 4, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 255, 150, 100]}, 4, {"id": 5, "colour": [150, 150, 255, 100]}, 1],
        [1, 0, 0, 0, 0, 0, {"id":8, "pos": "vbl", "colour": [255, 255, 150, 100]}, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 7,
        "y": 2
        },
        {"name": "goblin",
        "x": 7,
        "y": 8
        },
        {"name": "item", 
        "x": 140, 
        "y": 160, 
        "item": "key", 
        "payload": {
            "colour": [150, 150, 255, 100]
            }
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_1/player.json
{
    "lives": 3,
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



File: projects/final/data/account_games/1_games/2_levels/rooms_1/1.json
{
    "id": 1, 
    "doors": {
        "left": null, 
        "right": {"type": "empty", "complete": false, "colour": null}, 
        "up": null, 
        "down": null
        }, 
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 1, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, {"id":8, "pos": "vtr", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 0, 1], 
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 1, 1, {"id":8, "pos": "hbl", "colour": [150, 255, 150, 100]}, {"id":8, "pos": "hbr", "colour": [150, 255, 150, 100]}, 1, 1, 1, 1], 
        [1, 0, 1, 0, 0, 0, 0, 0, {"id":8, "pos": "vtr", "colour": [150, 150, 255, 100]}, 7], 
        [1, 0, 1, 0, 0, 0, 0, 0, {"id":8, "pos": "vbr", "colour": [150, 150, 255, 100]}, 7], 
        [1, 4, 1, 1, {"id":11, "pos": "htl", "colour": [255, 255, 150, 100]}, {"id":11, "pos": "htr", "colour": [255, 255, 150, 100]}, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 1], 
        [1, {"id": 5, "colour": [150, 150, 255, 100]}, 1, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ], 
    
    "entities": [
        {"name": "goblin",
        "x": 7.5,
        "y": 4.5,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 255, 150, 100]},
                        "chance": 1
                        }]
                    }]
            }
        ]
    }



File: projects/final/data/account_games/1_games/2_levels/rooms_1/11.json
{
    "id":11,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 2, 0, 1, 0, 0, 1, 0, 4, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [255, 255, 150, 100]}, {"id":11, "pos": "htr", "colour": [255, 255, 150, 100]}, 1, 0, 0, 1],
        [1, 4, 0, 1, {"id":11, "pos": "htl", "colour": [255, 100, 100, 100]}, {"id":11, "pos": "htr", "colour": [255, 100, 100, 100]}, 1, 0, 0, 1],
        [1, 4, 0, 1, {"id":11, "pos": "htl", "colour": [150, 150, 255, 100]}, {"id":11, "pos": "htr", "colour": [150, 150, 255, 100]}, 1, 0, 0, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [150, 255, 150, 100]}, {"id":11, "pos": "htr", "colour": [150, 255, 150, 100]}, 1, 0, 2, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [255, 150, 255, 100]}, {"id":11, "pos": "htr", "colour": [255, 150, 255, 100]}, 1, 0, 2, 1],
        [1, 0, 0, 1, 0, 10, 1, 0, 4, 1],
        [1, 0, 4, 1, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "crate",
        "x": 1,
        "y": 3.5
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_1/2.json
{
    "id":2,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "up": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "down": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null}
        
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 2, 1, 0, 0, 1, 0, 0, 1],
        [1, 0, 1, 1, 0, 0, 1, 1, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [1, 0, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, 0, 0, 1, 0, 0, 1, 2, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 4,
        "y": 4
        },
        {"name": "goblin",
        "x": 4,
        "y": 5
        },
        {"name": "goblin",
        "x": 5,
        "y": 4
        },
        {"name": "goblin",
        "x": 5,
        "y": 5
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_1/layout.json
[   [0, 0, 0, 0, 0],
    [0, 4, 5, 6, 0],
    [1, 2,10, 8, 0],
    [0, 3, 7, 9, 0],
    [0,11, 0, 0, 0]
]



File: projects/final/data/account_games/1_games/2_levels/rooms_1/3.json
{
    "id":3,
    "doors": {
        "left": null,
        "right": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]},
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "powered", "complete": false, "colour": [150, 150, 255, 100]}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, {"id":8, "pos": "htl", "colour": [255, 100, 100, 100]}, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 4, 0, 0, 0, 0, 7],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 4, 0, 0, 0, 0, 7],
        [1, {"id":8, "pos": "hbl", "colour": [255, 100, 100, 100]}, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, {"id": 6, "colour": [150, 150, 255, 100], "flicked": false}, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, {"id":8, "pos": "hbl", "colour": [150, 255, 150, 100]}, {"id":8, "pos": "hbr", "colour": [150, 255, 150, 100]}, 1, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 4
        },
        {"name": "goblin",
        "x": 2,
        "y": 5
        },
        {"name": "goblin",
        "x": 3,
        "y": 5
        },
        {"name": "crate",
        "x": 4,
        "y": 3.5
        },
        {"name": "crate",
        "x": 4,
        "y": 4.5
        },
        {"name": "goblin",
        "x": 8,
        "y": 2
        },
        {"name": "goblin",
        "x": 8,
        "y": 7
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_1/8.json
{
    "id":8,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 1, {"id":8, "pos": "hbl", "colour": [255, 100, 100, 100]}, {"id":8, "pos": "hbr", "colour": [255, 100, 100, 100]}, 1, 4, 0, 1], 
        [1, 1, 1, 1, {"id": 5, "colour": [255, 100, 100, 100]}, {"id": 5, "colour": [255, 100, 100, 100]}, 1, 0, 0, 1], 
        [1, 0, 0, 1, {"id": 5, "colour": [150, 150, 255, 100]}, {"id": 5, "colour": [150, 150, 255, 100]}, 1, 1, 1, 1], 
        [1, 0, 4, 1, {"id":8, "pos": "htl", "colour": [150, 150, 255, 100]}, {"id":8, "pos": "htr", "colour": [150, 150, 255, 100]}, 1, {"id": 5, "colour": [150, 150, 255, 100]}, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 2,
        "y": 7
        },
        {"name": "goblin",
        "x": 7,
        "y": 2
        },
        {"name": "goblin",
        "x": 7,
        "y": 7
        },
        {"name": "item", 
        "x": 340, 
        "y": 340, 
        "item": "key", 
        "payload": {
            "colour": [150, 150, 255, 100]
            }
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_1/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": {"type": "empty", "complete": false, "num": 4, "colour": null},
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 4, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 4, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 1, 2, 0, 1, 0, 0, 7], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 7], 
        [1, 4, 4, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 4, 0, 0, 1, 0, 4, 1], 
        [1, 0, 0, 4, 0, 0, 1, 0, 2, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "crate",
        "x": 3,
        "y": 6.5
        },
        {"name": "crate",
        "x": 3,
        "y": 7.5
        },
        {"name": "crate",
        "x": 3,
        "y": 0.5
        },
        {"name": "crate",
        "x": 3,
        "y": 1.5
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_1/5.json
{
    "id":5,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null},
        "up": null,
        "down": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1], 
        [1, 0, 4, 0, 1, 0, 0, 0, 0, 1], 
        [7, 0, 0, 1, 1, 2, 0, 0, 0, 7], 
        [7, 0, 0, 0, 2, 1, 1, 0, 0, 7], 
        [1, 0, 0, 0, 0, 1, 0, 4, 0, 1], 
        [1, 0, 0, 0, 0, 1, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 6
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 5,
        "y": 8
        },
        {"name": "goblin",
        "x": 4,
        "y": 5
        },
        {"name": "goblin",
        "x": 6,
        "y": 3,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 255, 150, 100]},
                        "chance": 1
                        }]
                    }]
        },
        {"name": "goblin",
        "x": 1,
        "y": 2
        },
        {"name": "goblin",
        "x": 3,
        "y": 5
        }
    ]
}



File: projects/final/data/account_games/1_games/2_levels/rooms_1/9.json
{
    "id":9,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 5, "colour": null},
        "right": null,
        "up": {"type": "local_kill_count", "complete": false, "num": 5, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 1, 0, 1, 1, 0, 1, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 1, 0, 1, 1, 0, 1, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 6
        },
        {"name": "goblin",
        "x": 5,
        "y": 1
        },
        {"name": "goblin",
        "x": 5,
        "y": 5
        },
        {"name": "goblin",
        "x": 2,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_-1/player.json
{
    "lives": 3,
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



File: projects/final/data/account_games/1_games/0_levels/rooms_-1/1.json
{
    "id": 1, 
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null}, 
        "right": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]}, 
        "up": {"type": "keyhole", "complete": false, "colour": [255, 100, 100, 100]}, 
        "down": {"type": "kill_count", "complete": false, "num": 1, "colour": null}
        }, 
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 2, 2, 0, 0, 0, 0, {"id":5,"colour":[255, 100, 100, 100]}, {"id":6,"colour":[255, 100, 100, 100]}, 1], 
        [1, 2, {"id": 3, "pos": "vbr"}, 0, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, {"id": 8, "pos": "htl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 4, 0, 0, 7], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 4, {"id": 12, "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, {"id": 11, "pos": "htl", "colour": [255, 100, 100, 100]}, 0, 2, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 10, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
        ],
    
        "entities": [
            {"name": "goblin", "x": 8, "y": 4},
            {"name": "item", "x": 400, "y": 400, "item": "key", "payload": {"colour": [255, 100, 100, 100]}}
        ]
    }



File: projects/final/data/account_games/1_games/0_levels/rooms_-1/2.json
{
    "id":2,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "up": null,
        "down": null
        
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 1
        },
        {"name": "goblin",
        "x": 8,
        "y": 8
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_-1/layout.json
[   [0, 0, 0, 0, 0],
    [0, 0, 5, 0, 0],
    [0, 2, 1, 3, 0],
    [0, 0, 4, 0, 0],
    [0, 0, 0, 0, 0]
]



File: projects/final/data/account_games/1_games/0_levels/rooms_-1/3.json
{
    "id":3,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "right": null,
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 2, 2, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_-1/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 2, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 4, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, {"id": 3, "pos": "vtl"}, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_-1/5.json
{
    "id":5,
    "doors": {
        "left": null,
        "right": null,
        "up": null,
        "down": {"type": "kill_count", "complete": false, "num": 2, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 4, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_0/6.json
{
    "id":6,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [7, 0, 4, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 4, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 7,
        "y": 4
        },
        {"name": "goblin",
        "x": 7,
        "y": 5
        },
        {"name": "crate",
        "x":2,
        "y":3.5
        },
        {"name": "crate",
        "x":2,
        "y":4.5
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_0/7.json
{
    "id":7,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 1, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "item", "x": 400, "y": 400, "item": "key", "payload": {"colour": [255, 100, 100, 100]}}
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_0/10.json
{
    "id":10,
    "doors": {
        "left": {"type": "powered", "complete": false, "colour": [150, 150, 255, 100]},
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 1, 1, 1, 1, 1], 
        [7, 0, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, {"id": 5, "colour": [150, 150, 255, 100]}, 0, 0, 1], 
        [7, 0, 0, 0, 0, 1, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_0/player.json
{
    "lives": 3,
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



File: projects/final/data/account_games/1_games/0_levels/rooms_0/1.json
{
    "id": 1, 
    "doors": {
        "left": null, 
        "right": {"type": "kill_count", "complete": false, "num": 1, "colour": null}, 
        "up": null, 
        "down": null
        }, 
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, {"id": 3, "pos": "vtr"}, 0, 0, 1, 0, 0, 7], 
        [1, 0, 0, {"id": 3, "pos": "vbr"}, 0, 0, 1, 0, 0, 7], 
        [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ],
    
        "entities": [
            {"name": "goblin", "x": 8, "y": 4}
        ]
    }



File: projects/final/data/account_games/1_games/0_levels/rooms_0/11.json
{
    "id":11,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "kill_count", "complete": false, "num": 7, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 4,
        "y": 2
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_0/2.json
{
    "id":2,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "down": {"type": "keyhole", "complete": false, "colour": [255, 100, 100, 100]}
        
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 1
        },
        {"name": "goblin",
        "x": 8,
        "y": 8
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_0/layout.json
[   [0, 0, 0, 0, 0],
    [0, 4, 5, 6, 0],
    [1, 2, 0, 8, 11],
    [0, 3, 7, 9, 10],
    [0, 0, 0, 0, 0]
]



File: projects/final/data/account_games/1_games/0_levels/rooms_0/3.json
{
    "id":3,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 3, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, 10, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_0/8.json
{
    "id":8,
    "doors": {
        "left": null,
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, {"id":8, "pos": "vbl", "colour": [255, 100, 100, 100]}, {"id":8, "pos": "vbr", "colour": [255, 100, 100, 100]}, 1, 1, 1, 1], 
        [1, 0, {"id": 6, "colour": [255, 100, 100, 100], "flicked": false}, 0, 0, 0, 0, 2, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 1, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 1, 2, 2, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 1,
        "y": 1
        },
        {"name": "goblin",
        "x": 1.5,
        "y": 1
        },
        {"name": "goblin",
        "x": 2.3,
        "y": 1.5
        },
        {"name": "goblin",
        "x": 1,
        "y": 1.7
        },
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 1.4,
        "y": 2
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_0/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 4, "colour": null},
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 2, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 7],
        [1, 1, 1, 1, 1, 4, 1, 0, 0, 7],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, {"id": 3, "pos": "vtl"}, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_0/5.json
{
    "id":5,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [7, 0, 4, 0, 1, 0, 0, 0, 0, 7],
        [7, 0, 0, 0, 1, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_0/9.json
{
    "id":9,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 16, "colour": null},
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 1, {"id":8, "pos": "hbl", "colour": [150, 150, 255, 100]}, {"id":8, "pos": "hbr", "colour": [150, 150, 255, 100]}, 1, 0, 0, 1], 
        [1, 0, {"id": 6, "colour": [255, 100, 100, 100], "flicked": false}, 1, {"id":8, "pos": "hbl", "colour": [150, 255, 150, 100]}, {"id":8, "pos": "hbr", "colour": [150, 255, 150, 100]}, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, {"id": 6, "colour": [150, 150, 255, 100], "flicked": false}, 0, 0, 0, 0, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 6,
        "y": 3
        },
        {"name": "goblin",
        "x": 5,
        "y": 3
        },
        {"name": "goblin",
        "x": 4,
        "y": 3
        },
        {"name": "goblin",
        "x": 6,
        "y": 6
        },
        {"name": "goblin",
        "x": 5,
        "y": 6
        },
        {"name": "goblin",
        "x": 4,
        "y": 6
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_1/6.json
{
    "id":6,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "powered", "complete": false, "colour": [150, 255, 150, 100]}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 1, 1, 1, 1, 1, 1, 1], 
        [7, 0, 0, {"id":11, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 4, 0, 1], 
        [7, 0, 0, {"id":11, "pos": "vbl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 4, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 6
        },
        {"name": "goblin",
        "x": 6,
        "y": 0.5
        },
        {"name": "goblin",
        "x": 3,
        "y": 1
        },
        {"name": "goblin",
        "x": 5,
        "y": 1.5,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 150, 255, 100]},
                        "chance": 1
                        }]
                    }]
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_1/7.json
{
    "id":7,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 3, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 3, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [150, 150, 255, 100]}, 0, 0, 0, 1], 
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 1, 0, 1, 0, 0, 0, 1], 
        [1, 1, 0, 1, 0, 1, 0, 0, 0, 1], 
        [7, 0, 4, 1, 0, 1, 0, 0, 0, 7], 
        [7, 0, 0, 0, 0, 1, 0, 0, 0, 7], 
        [1, {"id":8, "pos": "htl", "colour": [255, 100, 100, 100]}, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 4, 0, 0, 0, 0, 0, {"id": 5, "colour": [150, 150, 255, 100]}, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 1, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 7,
        "y": 8,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 100, 100, 100]},
                        "chance": 1
                        }]
                    }]
        },
        {"name": "goblin",
        "x": 7,
        "y": 3
        },
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 6,
        "y": 2
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_1/10.json
{
    "id":10,
    "doors": {
        "left": {"type": "empty", "complete": false, "num": 1, "colour": null},
        "right": null,
        "up": {"type": "powered", "complete": false, "colour": [150, 255, 150, 100]},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, {"id": 5, "colour": [150, 255, 150, 100]}, 4, {"id":8, "pos": "vtr", "colour": [150, 150, 255, 100]}, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 4, {"id": 5, "colour": [255, 255, 150, 100]}, 1],
        [1, 0, 0, {"id":8, "pos": "vbr", "colour": [150, 150, 255, 100]}, 0, 0, {"id":8, "pos": "vbl", "colour": [255, 100, 100, 100]}, 0, 0, 1],
        [1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 4, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 255, 150, 100]}, 4, {"id": 5, "colour": [150, 150, 255, 100]}, 1],
        [1, 0, 0, 0, 0, 0, {"id":8, "pos": "vbl", "colour": [255, 255, 150, 100]}, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 7,
        "y": 2
        },
        {"name": "goblin",
        "x": 7,
        "y": 8
        },
        {"name": "item", 
        "x": 140, 
        "y": 160, 
        "item": "key", 
        "payload": {
            "colour": [150, 150, 255, 100]
            }
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_1/player.json
{"lives": 3, "max_health": 30, "health": 30, "x": 219.0, "y": 236.0, "current_room": 1, "direction": "right", "speed": 6, "push_pull_speed": 3, "max_sprint_stamina": 45, "sprint_stamina": 45, "max_boost_time": 75, "boost_cooldown": 75, "boost_speed": 8, "mele_reach": 50, "mele_push_strength": 30, "attack_damage": 1, "max_attack_cooldown": 5, "inventory": [null, null, null, null, null, null, null, null, null, null, null, null, null, null], "holding_main_hand": true, "kills": 0}



File: projects/final/data/account_games/1_games/0_levels/rooms_1/1.json
{"id": 1, "doors": {"left": null, "right": {"type": "empty", "complete": false, "colour": null}, "up": null, "down": null}, "squares": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [1, 0, {"id": 8, "pos": "vtr", "open": false, "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 0, 1], [1, {"id": 5, "colour": [255, 100, 100, 100]}, 1, 1, {"id": 8, "pos": "hbl", "open": false, "colour": [150, 255, 150, 100]}, {"id": 8, "pos": "hbr", "open": false, "colour": [150, 255, 150, 100]}, 1, 1, 1, 1], [1, 0, 1, 0, 0, 0, 0, 0, {"id": 8, "pos": "vtr", "open": false, "colour": [150, 150, 255, 100]}, 7], [1, 0, 1, 0, 0, 0, 0, 0, {"id": 8, "pos": "vbr", "open": false, "colour": [150, 150, 255, 100]}, 7], [1, 0, 1, 1, {"id": 11, "pos": "htl", "open": false, "colour": [255, 255, 150, 100]}, {"id": 11, "pos": "htr", "open": false, "colour": [255, 255, 150, 100]}, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 1], [1, {"id": 5, "colour": [150, 150, 255, 100]}, 1, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], "entities": [{"name": "goblin", "x": 3.774409147575024, "y": 3.984607750240343, "health": 5}, {"name": "crate", "x": 1.0, "y": 6.0}]}



File: projects/final/data/account_games/1_games/0_levels/rooms_1/11.json
{
    "id":11,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 2, 0, 1, 0, 0, 1, 0, 4, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [255, 255, 150, 100]}, {"id":11, "pos": "htr", "colour": [255, 255, 150, 100]}, 1, 0, 0, 1],
        [1, 4, 0, 1, {"id":11, "pos": "htl", "colour": [255, 100, 100, 100]}, {"id":11, "pos": "htr", "colour": [255, 100, 100, 100]}, 1, 0, 0, 1],
        [1, 4, 0, 1, {"id":11, "pos": "htl", "colour": [150, 150, 255, 100]}, {"id":11, "pos": "htr", "colour": [150, 150, 255, 100]}, 1, 0, 0, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [150, 255, 150, 100]}, {"id":11, "pos": "htr", "colour": [150, 255, 150, 100]}, 1, 0, 2, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [255, 150, 255, 100]}, {"id":11, "pos": "htr", "colour": [255, 150, 255, 100]}, 1, 0, 2, 1],
        [1, 0, 0, 1, 0, 10, 1, 0, 4, 1],
        [1, 0, 4, 1, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "crate",
        "x": 1,
        "y": 3.5
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_1/2.json
{
    "id":2,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "up": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "down": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null}
        
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 2, 1, 0, 0, 1, 0, 0, 1],
        [1, 0, 1, 1, 0, 0, 1, 1, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [1, 0, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, 0, 0, 1, 0, 0, 1, 2, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 4,
        "y": 4
        },
        {"name": "goblin",
        "x": 4,
        "y": 5
        },
        {"name": "goblin",
        "x": 5,
        "y": 4
        },
        {"name": "goblin",
        "x": 5,
        "y": 5
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_1/layout.json
[   [0, 0, 0, 0, 0],
    [0, 4, 5, 6, 0],
    [1, 2,10, 8, 0],
    [0, 3, 7, 9, 0],
    [0,11, 0, 0, 0]
]



File: projects/final/data/account_games/1_games/0_levels/rooms_1/3.json
{
    "id":3,
    "doors": {
        "left": null,
        "right": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]},
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "powered", "complete": false, "colour": [150, 150, 255, 100]}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, {"id":8, "pos": "htl", "colour": [255, 100, 100, 100]}, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 4, 0, 0, 0, 0, 7],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 4, 0, 0, 0, 0, 7],
        [1, {"id":8, "pos": "hbl", "colour": [255, 100, 100, 100]}, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, {"id": 6, "colour": [150, 150, 255, 100], "flicked": false}, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, {"id":8, "pos": "hbl", "colour": [150, 255, 150, 100]}, {"id":8, "pos": "hbr", "colour": [150, 255, 150, 100]}, 1, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 4
        },
        {"name": "goblin",
        "x": 2,
        "y": 5
        },
        {"name": "goblin",
        "x": 3,
        "y": 5
        },
        {"name": "crate",
        "x": 4,
        "y": 3.5
        },
        {"name": "crate",
        "x": 4,
        "y": 4.5
        },
        {"name": "goblin",
        "x": 8,
        "y": 2
        },
        {"name": "goblin",
        "x": 8,
        "y": 7
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_1/8.json
{
    "id":8,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 1, {"id":8, "pos": "hbl", "colour": [255, 100, 100, 100]}, {"id":8, "pos": "hbr", "colour": [255, 100, 100, 100]}, 1, 4, 0, 1], 
        [1, 1, 1, 1, {"id": 5, "colour": [255, 100, 100, 100]}, {"id": 5, "colour": [255, 100, 100, 100]}, 1, 0, 0, 1], 
        [1, 0, 0, 1, {"id": 5, "colour": [150, 150, 255, 100]}, {"id": 5, "colour": [150, 150, 255, 100]}, 1, 1, 1, 1], 
        [1, 0, 4, 1, {"id":8, "pos": "htl", "colour": [150, 150, 255, 100]}, {"id":8, "pos": "htr", "colour": [150, 150, 255, 100]}, 1, {"id": 5, "colour": [150, 150, 255, 100]}, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 2,
        "y": 7
        },
        {"name": "goblin",
        "x": 7,
        "y": 2
        },
        {"name": "goblin",
        "x": 7,
        "y": 7
        },
        {"name": "item", 
        "x": 340, 
        "y": 340, 
        "item": "key", 
        "payload": {
            "colour": [150, 150, 255, 100]
            }
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_1/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": {"type": "empty", "complete": false, "num": 4, "colour": null},
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 4, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 4, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 1, 2, 0, 1, 0, 0, 7], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 7], 
        [1, 4, 4, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 4, 0, 0, 1, 0, 4, 1], 
        [1, 0, 0, 4, 0, 0, 1, 0, 2, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "crate",
        "x": 3,
        "y": 6.5
        },
        {"name": "crate",
        "x": 3,
        "y": 7.5
        },
        {"name": "crate",
        "x": 3,
        "y": 0.5
        },
        {"name": "crate",
        "x": 3,
        "y": 1.5
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_1/5.json
{
    "id":5,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null},
        "up": null,
        "down": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1], 
        [1, 0, 4, 0, 1, 0, 0, 0, 0, 1], 
        [7, 0, 0, 1, 1, 2, 0, 0, 0, 7], 
        [7, 0, 0, 0, 2, 1, 1, 0, 0, 7], 
        [1, 0, 0, 0, 0, 1, 0, 4, 0, 1], 
        [1, 0, 0, 0, 0, 1, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 6
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 5,
        "y": 8
        },
        {"name": "goblin",
        "x": 4,
        "y": 5
        },
        {"name": "goblin",
        "x": 6,
        "y": 3,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 255, 150, 100]},
                        "chance": 1
                        }]
                    }]
        },
        {"name": "goblin",
        "x": 1,
        "y": 2
        },
        {"name": "goblin",
        "x": 3,
        "y": 5
        }
    ]
}



File: projects/final/data/account_games/1_games/0_levels/rooms_1/9.json
{
    "id":9,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 5, "colour": null},
        "right": null,
        "up": {"type": "local_kill_count", "complete": false, "num": 5, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 1, 0, 1, 1, 0, 1, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 1, 0, 1, 1, 0, 1, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 6
        },
        {"name": "goblin",
        "x": 5,
        "y": 1
        },
        {"name": "goblin",
        "x": 5,
        "y": 5
        },
        {"name": "goblin",
        "x": 2,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_-1/player.json
{
    "lives": 3,
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



File: projects/final/data/account_games/1_games/1_levels/rooms_-1/1.json
{
    "id": 1, 
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null}, 
        "right": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]}, 
        "up": {"type": "keyhole", "complete": false, "colour": [255, 100, 100, 100]}, 
        "down": {"type": "kill_count", "complete": false, "num": 1, "colour": null}
        }, 
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 2, 2, 0, 0, 0, 0, {"id":5,"colour":[255, 100, 100, 100]}, {"id":6,"colour":[255, 100, 100, 100]}, 1], 
        [1, 2, {"id": 3, "pos": "vbr"}, 0, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, {"id": 8, "pos": "htl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 4, 0, 0, 7], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 4, {"id": 12, "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, {"id": 11, "pos": "htl", "colour": [255, 100, 100, 100]}, 0, 2, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 10, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
        ],
    
        "entities": [
            {"name": "goblin", "x": 8, "y": 4},
            {"name": "item", "x": 400, "y": 400, "item": "key", "payload": {"colour": [255, 100, 100, 100]}}
        ]
    }



File: projects/final/data/account_games/1_games/1_levels/rooms_-1/2.json
{
    "id":2,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "up": null,
        "down": null
        
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 1
        },
        {"name": "goblin",
        "x": 8,
        "y": 8
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_-1/layout.json
[   [0, 0, 0, 0, 0],
    [0, 0, 5, 0, 0],
    [0, 2, 1, 3, 0],
    [0, 0, 4, 0, 0],
    [0, 0, 0, 0, 0]
]



File: projects/final/data/account_games/1_games/1_levels/rooms_-1/3.json
{
    "id":3,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "right": null,
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 2, 2, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_-1/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 2, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 4, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, {"id": 3, "pos": "vtl"}, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_-1/5.json
{
    "id":5,
    "doors": {
        "left": null,
        "right": null,
        "up": null,
        "down": {"type": "kill_count", "complete": false, "num": 2, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 4, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_0/6.json
{
    "id":6,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [7, 0, 4, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 4, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 7,
        "y": 4
        },
        {"name": "goblin",
        "x": 7,
        "y": 5
        },
        {"name": "crate",
        "x":2,
        "y":3.5
        },
        {"name": "crate",
        "x":2,
        "y":4.5
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_0/7.json
{
    "id":7,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 1, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "item", "x": 400, "y": 400, "item": "key", "payload": {"colour": [255, 100, 100, 100]}}
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_0/10.json
{
    "id":10,
    "doors": {
        "left": {"type": "powered", "complete": false, "colour": [150, 150, 255, 100]},
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 1, 1, 1, 1, 1], 
        [7, 0, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, {"id": 5, "colour": [150, 150, 255, 100]}, 0, 0, 1], 
        [7, 0, 0, 0, 0, 1, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_0/player.json
{
    "lives": 3,
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



File: projects/final/data/account_games/1_games/1_levels/rooms_0/1.json
{
    "id": 1, 
    "doors": {
        "left": null, 
        "right": {"type": "kill_count", "complete": false, "num": 1, "colour": null}, 
        "up": null, 
        "down": null
        }, 
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, {"id": 3, "pos": "vtr"}, 0, 0, 1, 0, 0, 7], 
        [1, 0, 0, {"id": 3, "pos": "vbr"}, 0, 0, 1, 0, 0, 7], 
        [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ],
    
        "entities": [
            {"name": "goblin", "x": 8, "y": 4}
        ]
    }



File: projects/final/data/account_games/1_games/1_levels/rooms_0/11.json
{
    "id":11,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "kill_count", "complete": false, "num": 7, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 4,
        "y": 2
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_0/2.json
{
    "id":2,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "down": {"type": "keyhole", "complete": false, "colour": [255, 100, 100, 100]}
        
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 1
        },
        {"name": "goblin",
        "x": 8,
        "y": 8
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_0/layout.json
[   [0, 0, 0, 0, 0],
    [0, 4, 5, 6, 0],
    [1, 2, 0, 8, 11],
    [0, 3, 7, 9, 10],
    [0, 0, 0, 0, 0]
]



File: projects/final/data/account_games/1_games/1_levels/rooms_0/3.json
{
    "id":3,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 3, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, 10, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_0/8.json
{
    "id":8,
    "doors": {
        "left": null,
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, {"id":8, "pos": "vbl", "colour": [255, 100, 100, 100]}, {"id":8, "pos": "vbr", "colour": [255, 100, 100, 100]}, 1, 1, 1, 1], 
        [1, 0, {"id": 6, "colour": [255, 100, 100, 100], "flicked": false}, 0, 0, 0, 0, 2, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 1, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 1, 2, 2, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 1,
        "y": 1
        },
        {"name": "goblin",
        "x": 1.5,
        "y": 1
        },
        {"name": "goblin",
        "x": 2.3,
        "y": 1.5
        },
        {"name": "goblin",
        "x": 1,
        "y": 1.7
        },
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 1.4,
        "y": 2
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_0/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 4, "colour": null},
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 2, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 7],
        [1, 1, 1, 1, 1, 4, 1, 0, 0, 7],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, {"id": 3, "pos": "vtl"}, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_0/5.json
{
    "id":5,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [7, 0, 4, 0, 1, 0, 0, 0, 0, 7],
        [7, 0, 0, 0, 1, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_0/9.json
{
    "id":9,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 16, "colour": null},
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 1, {"id":8, "pos": "hbl", "colour": [150, 150, 255, 100]}, {"id":8, "pos": "hbr", "colour": [150, 150, 255, 100]}, 1, 0, 0, 1], 
        [1, 0, {"id": 6, "colour": [255, 100, 100, 100], "flicked": false}, 1, {"id":8, "pos": "hbl", "colour": [150, 255, 150, 100]}, {"id":8, "pos": "hbr", "colour": [150, 255, 150, 100]}, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, {"id": 6, "colour": [150, 150, 255, 100], "flicked": false}, 0, 0, 0, 0, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 6,
        "y": 3
        },
        {"name": "goblin",
        "x": 5,
        "y": 3
        },
        {"name": "goblin",
        "x": 4,
        "y": 3
        },
        {"name": "goblin",
        "x": 6,
        "y": 6
        },
        {"name": "goblin",
        "x": 5,
        "y": 6
        },
        {"name": "goblin",
        "x": 4,
        "y": 6
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_1/6.json
{
    "id":6,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "powered", "complete": false, "colour": [150, 255, 150, 100]}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 1, 1, 1, 1, 1, 1, 1], 
        [7, 0, 0, {"id":11, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 4, 0, 1], 
        [7, 0, 0, {"id":11, "pos": "vbl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 4, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 6
        },
        {"name": "goblin",
        "x": 6,
        "y": 0.5
        },
        {"name": "goblin",
        "x": 3,
        "y": 1
        },
        {"name": "goblin",
        "x": 5,
        "y": 1.5,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 150, 255, 100]},
                        "chance": 1
                        }]
                    }]
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_1/7.json
{
    "id":7,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 3, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 3, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [150, 150, 255, 100]}, 0, 0, 0, 1], 
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 1, 0, 1, 0, 0, 0, 1], 
        [1, 1, 0, 1, 0, 1, 0, 0, 0, 1], 
        [7, 0, 4, 1, 0, 1, 0, 0, 0, 7], 
        [7, 0, 0, 0, 0, 1, 0, 0, 0, 7], 
        [1, {"id":8, "pos": "htl", "colour": [255, 100, 100, 100]}, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 4, 0, 0, 0, 0, 0, {"id": 5, "colour": [150, 150, 255, 100]}, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 1, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 7,
        "y": 8,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 100, 100, 100]},
                        "chance": 1
                        }]
                    }]
        },
        {"name": "goblin",
        "x": 7,
        "y": 3
        },
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 6,
        "y": 2
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_1/10.json
{
    "id":10,
    "doors": {
        "left": {"type": "empty", "complete": false, "num": 1, "colour": null},
        "right": null,
        "up": {"type": "powered", "complete": false, "colour": [150, 255, 150, 100]},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, {"id": 5, "colour": [150, 255, 150, 100]}, 4, {"id":8, "pos": "vtr", "colour": [150, 150, 255, 100]}, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 4, {"id": 5, "colour": [255, 255, 150, 100]}, 1],
        [1, 0, 0, {"id":8, "pos": "vbr", "colour": [150, 150, 255, 100]}, 0, 0, {"id":8, "pos": "vbl", "colour": [255, 100, 100, 100]}, 0, 0, 1],
        [1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 4, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 255, 150, 100]}, 4, {"id": 5, "colour": [150, 150, 255, 100]}, 1],
        [1, 0, 0, 0, 0, 0, {"id":8, "pos": "vbl", "colour": [255, 255, 150, 100]}, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 7,
        "y": 2
        },
        {"name": "goblin",
        "x": 7,
        "y": 8
        },
        {"name": "item", 
        "x": 140, 
        "y": 160, 
        "item": "key", 
        "payload": {
            "colour": [150, 150, 255, 100]
            }
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_1/player.json
{
    "lives": 3,
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



File: projects/final/data/account_games/1_games/1_levels/rooms_1/1.json
{
    "id": 1, 
    "doors": {
        "left": null, 
        "right": {"type": "empty", "complete": false, "colour": null}, 
        "up": null, 
        "down": null
        }, 
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 1, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, {"id":8, "pos": "vtr", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 0, 1], 
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 1, 1, {"id":8, "pos": "hbl", "colour": [150, 255, 150, 100]}, {"id":8, "pos": "hbr", "colour": [150, 255, 150, 100]}, 1, 1, 1, 1], 
        [1, 0, 1, 0, 0, 0, 0, 0, {"id":8, "pos": "vtr", "colour": [150, 150, 255, 100]}, 7], 
        [1, 0, 1, 0, 0, 0, 0, 0, {"id":8, "pos": "vbr", "colour": [150, 150, 255, 100]}, 7], 
        [1, 4, 1, 1, {"id":11, "pos": "htl", "colour": [255, 255, 150, 100]}, {"id":11, "pos": "htr", "colour": [255, 255, 150, 100]}, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 1], 
        [1, {"id": 5, "colour": [150, 150, 255, 100]}, 1, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ], 
    
    "entities": [
        {"name": "goblin",
        "x": 7.5,
        "y": 4.5,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 255, 150, 100]},
                        "chance": 1
                        }]
                    }]
            }
        ]
    }



File: projects/final/data/account_games/1_games/1_levels/rooms_1/11.json
{
    "id":11,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 2, 0, 1, 0, 0, 1, 0, 4, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [255, 255, 150, 100]}, {"id":11, "pos": "htr", "colour": [255, 255, 150, 100]}, 1, 0, 0, 1],
        [1, 4, 0, 1, {"id":11, "pos": "htl", "colour": [255, 100, 100, 100]}, {"id":11, "pos": "htr", "colour": [255, 100, 100, 100]}, 1, 0, 0, 1],
        [1, 4, 0, 1, {"id":11, "pos": "htl", "colour": [150, 150, 255, 100]}, {"id":11, "pos": "htr", "colour": [150, 150, 255, 100]}, 1, 0, 0, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [150, 255, 150, 100]}, {"id":11, "pos": "htr", "colour": [150, 255, 150, 100]}, 1, 0, 2, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [255, 150, 255, 100]}, {"id":11, "pos": "htr", "colour": [255, 150, 255, 100]}, 1, 0, 2, 1],
        [1, 0, 0, 1, 0, 10, 1, 0, 4, 1],
        [1, 0, 4, 1, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "crate",
        "x": 1,
        "y": 3.5
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_1/2.json
{
    "id":2,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "up": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "down": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null}
        
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 2, 1, 0, 0, 1, 0, 0, 1],
        [1, 0, 1, 1, 0, 0, 1, 1, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [1, 0, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, 0, 0, 1, 0, 0, 1, 2, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 4,
        "y": 4
        },
        {"name": "goblin",
        "x": 4,
        "y": 5
        },
        {"name": "goblin",
        "x": 5,
        "y": 4
        },
        {"name": "goblin",
        "x": 5,
        "y": 5
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_1/layout.json
[   [0, 0, 0, 0, 0],
    [0, 4, 5, 6, 0],
    [1, 2,10, 8, 0],
    [0, 3, 7, 9, 0],
    [0,11, 0, 0, 0]
]



File: projects/final/data/account_games/1_games/1_levels/rooms_1/3.json
{
    "id":3,
    "doors": {
        "left": null,
        "right": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]},
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "powered", "complete": false, "colour": [150, 150, 255, 100]}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, {"id":8, "pos": "htl", "colour": [255, 100, 100, 100]}, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 4, 0, 0, 0, 0, 7],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 4, 0, 0, 0, 0, 7],
        [1, {"id":8, "pos": "hbl", "colour": [255, 100, 100, 100]}, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, {"id": 6, "colour": [150, 150, 255, 100], "flicked": false}, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, {"id":8, "pos": "hbl", "colour": [150, 255, 150, 100]}, {"id":8, "pos": "hbr", "colour": [150, 255, 150, 100]}, 1, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 4
        },
        {"name": "goblin",
        "x": 2,
        "y": 5
        },
        {"name": "goblin",
        "x": 3,
        "y": 5
        },
        {"name": "crate",
        "x": 4,
        "y": 3.5
        },
        {"name": "crate",
        "x": 4,
        "y": 4.5
        },
        {"name": "goblin",
        "x": 8,
        "y": 2
        },
        {"name": "goblin",
        "x": 8,
        "y": 7
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_1/8.json
{
    "id":8,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 1, {"id":8, "pos": "hbl", "colour": [255, 100, 100, 100]}, {"id":8, "pos": "hbr", "colour": [255, 100, 100, 100]}, 1, 4, 0, 1], 
        [1, 1, 1, 1, {"id": 5, "colour": [255, 100, 100, 100]}, {"id": 5, "colour": [255, 100, 100, 100]}, 1, 0, 0, 1], 
        [1, 0, 0, 1, {"id": 5, "colour": [150, 150, 255, 100]}, {"id": 5, "colour": [150, 150, 255, 100]}, 1, 1, 1, 1], 
        [1, 0, 4, 1, {"id":8, "pos": "htl", "colour": [150, 150, 255, 100]}, {"id":8, "pos": "htr", "colour": [150, 150, 255, 100]}, 1, {"id": 5, "colour": [150, 150, 255, 100]}, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 2,
        "y": 7
        },
        {"name": "goblin",
        "x": 7,
        "y": 2
        },
        {"name": "goblin",
        "x": 7,
        "y": 7
        },
        {"name": "item", 
        "x": 340, 
        "y": 340, 
        "item": "key", 
        "payload": {
            "colour": [150, 150, 255, 100]
            }
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_1/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": {"type": "empty", "complete": false, "num": 4, "colour": null},
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 4, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 4, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 1, 2, 0, 1, 0, 0, 7], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 7], 
        [1, 4, 4, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 4, 0, 0, 1, 0, 4, 1], 
        [1, 0, 0, 4, 0, 0, 1, 0, 2, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "crate",
        "x": 3,
        "y": 6.5
        },
        {"name": "crate",
        "x": 3,
        "y": 7.5
        },
        {"name": "crate",
        "x": 3,
        "y": 0.5
        },
        {"name": "crate",
        "x": 3,
        "y": 1.5
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_1/5.json
{
    "id":5,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null},
        "up": null,
        "down": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1], 
        [1, 0, 4, 0, 1, 0, 0, 0, 0, 1], 
        [7, 0, 0, 1, 1, 2, 0, 0, 0, 7], 
        [7, 0, 0, 0, 2, 1, 1, 0, 0, 7], 
        [1, 0, 0, 0, 0, 1, 0, 4, 0, 1], 
        [1, 0, 0, 0, 0, 1, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 6
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 5,
        "y": 8
        },
        {"name": "goblin",
        "x": 4,
        "y": 5
        },
        {"name": "goblin",
        "x": 6,
        "y": 3,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 255, 150, 100]},
                        "chance": 1
                        }]
                    }]
        },
        {"name": "goblin",
        "x": 1,
        "y": 2
        },
        {"name": "goblin",
        "x": 3,
        "y": 5
        }
    ]
}



File: projects/final/data/account_games/1_games/1_levels/rooms_1/9.json
{
    "id":9,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 5, "colour": null},
        "right": null,
        "up": {"type": "local_kill_count", "complete": false, "num": 5, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 1, 0, 1, 1, 0, 1, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 1, 0, 1, 1, 0, 1, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 6
        },
        {"name": "goblin",
        "x": 5,
        "y": 1
        },
        {"name": "goblin",
        "x": 5,
        "y": 5
        },
        {"name": "goblin",
        "x": 2,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_-1/player.json
{
    "lives": 3,
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



File: projects/final/data/account_games/default_games/default_levels/rooms_-1/1.json
{
    "id": 1, 
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null}, 
        "right": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]}, 
        "up": {"type": "keyhole", "complete": false, "colour": [255, 100, 100, 100]}, 
        "down": {"type": "kill_count", "complete": false, "num": 1, "colour": null}
        }, 
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 2, 2, 0, 0, 0, 0, {"id":5,"colour":[255, 100, 100, 100]}, {"id":6,"colour":[255, 100, 100, 100]}, 1], 
        [1, 2, {"id": 3, "pos": "vbr"}, 0, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, {"id": 8, "pos": "htl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 4, 0, 0, 7], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 4, {"id": 12, "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, {"id": 11, "pos": "htl", "colour": [255, 100, 100, 100]}, 0, 2, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 10, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
        ],
    
        "entities": [
            {"name": "goblin", "x": 8, "y": 4},
            {"name": "item", "x": 400, "y": 400, "item": "key", "payload": {"colour": [255, 100, 100, 100]}}
        ]
    }



File: projects/final/data/account_games/default_games/default_levels/rooms_-1/2.json
{
    "id":2,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "up": null,
        "down": null
        
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 1
        },
        {"name": "goblin",
        "x": 8,
        "y": 8
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_-1/layout.json
[   [0, 0, 0, 0, 0],
    [0, 0, 5, 0, 0],
    [0, 2, 1, 3, 0],
    [0, 0, 4, 0, 0],
    [0, 0, 0, 0, 0]
]



File: projects/final/data/account_games/default_games/default_levels/rooms_-1/3.json
{
    "id":3,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "right": null,
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 2, 2, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_-1/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 2, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 4, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, {"id": 3, "pos": "vtl"}, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_-1/5.json
{
    "id":5,
    "doors": {
        "left": null,
        "right": null,
        "up": null,
        "down": {"type": "kill_count", "complete": false, "num": 2, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 4, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_0/6.json
{
    "id":6,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [7, 0, 4, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 4, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 7,
        "y": 4
        },
        {"name": "goblin",
        "x": 7,
        "y": 5
        },
        {"name": "crate",
        "x":2,
        "y":3.5
        },
        {"name": "crate",
        "x":2,
        "y":4.5
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_0/7.json
{
    "id":7,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 1, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "item", "x": 400, "y": 400, "item": "key", "payload": {"colour": [255, 100, 100, 100]}}
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_0/10.json
{
    "id":10,
    "doors": {
        "left": {"type": "powered", "complete": false, "colour": [150, 150, 255, 100]},
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 1, 1, 1, 1, 1], 
        [7, 0, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, {"id": 5, "colour": [150, 150, 255, 100]}, 0, 0, 1], 
        [7, 0, 0, 0, 0, 1, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_0/player.json
{
    "lives": 3,
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



File: projects/final/data/account_games/default_games/default_levels/rooms_0/1.json
{
    "id": 1, 
    "doors": {
        "left": null, 
        "right": {"type": "kill_count", "complete": false, "num": 1, "colour": null}, 
        "up": null, 
        "down": null
        }, 
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, {"id": 3, "pos": "vtr"}, 0, 0, 1, 0, 0, 7], 
        [1, 0, 0, {"id": 3, "pos": "vbr"}, 0, 0, 1, 0, 0, 7], 
        [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ],
    
        "entities": [
            {"name": "goblin", "x": 8, "y": 4}
        ]
    }



File: projects/final/data/account_games/default_games/default_levels/rooms_0/11.json
{
    "id":11,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "kill_count", "complete": false, "num": 7, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 4,
        "y": 2
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_0/2.json
{
    "id":2,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 2, "colour": null},
        "down": {"type": "keyhole", "complete": false, "colour": [255, 100, 100, 100]}
        
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 1
        },
        {"name": "goblin",
        "x": 8,
        "y": 8
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_0/layout.json
[   [0, 0, 0, 0, 0],
    [0, 4, 5, 6, 0],
    [1, 2, 0, 8, 11],
    [0, 3, 7, 9, 10],
    [0, 0, 0, 0, 0]
]



File: projects/final/data/account_games/default_games/default_levels/rooms_0/3.json
{
    "id":3,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "kill_count", "complete": false, "num": 3, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, 10, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_0/8.json
{
    "id":8,
    "doors": {
        "left": null,
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, {"id":8, "pos": "vbl", "colour": [255, 100, 100, 100]}, {"id":8, "pos": "vbr", "colour": [255, 100, 100, 100]}, 1, 1, 1, 1], 
        [1, 0, {"id": 6, "colour": [255, 100, 100, 100], "flicked": false}, 0, 0, 0, 0, 2, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 1, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 1, 2, 2, 1, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 1,
        "y": 1
        },
        {"name": "goblin",
        "x": 1.5,
        "y": 1
        },
        {"name": "goblin",
        "x": 2.3,
        "y": 1.5
        },
        {"name": "goblin",
        "x": 1,
        "y": 1.7
        },
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 1.4,
        "y": 2
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_0/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": {"type": "kill_count", "complete": false, "num": 4, "colour": null},
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 2, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 7],
        [1, 1, 1, 1, 1, 4, 1, 0, 0, 7],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, {"id": 3, "pos": "vtl"}, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_0/5.json
{
    "id":5,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [7, 0, 4, 0, 1, 0, 0, 0, 0, 7],
        [7, 0, 0, 0, 1, 0, 0, 0, 0, 7],
        [1, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_0/9.json
{
    "id":9,
    "doors": {
        "left": {"type": "kill_count", "complete": false, "num": 16, "colour": null},
        "right": {"type": "empty", "complete": false, "colour": null},
        "up": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 1, {"id":8, "pos": "hbl", "colour": [150, 150, 255, 100]}, {"id":8, "pos": "hbr", "colour": [150, 150, 255, 100]}, 1, 0, 0, 1], 
        [1, 0, {"id": 6, "colour": [255, 100, 100, 100], "flicked": false}, 1, {"id":8, "pos": "hbl", "colour": [150, 255, 150, 100]}, {"id":8, "pos": "hbr", "colour": [150, 255, 150, 100]}, 1, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, {"id": 6, "colour": [150, 150, 255, 100], "flicked": false}, 0, 0, 0, 0, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 6,
        "y": 3
        },
        {"name": "goblin",
        "x": 5,
        "y": 3
        },
        {"name": "goblin",
        "x": 4,
        "y": 3
        },
        {"name": "goblin",
        "x": 6,
        "y": 6
        },
        {"name": "goblin",
        "x": 5,
        "y": 6
        },
        {"name": "goblin",
        "x": 4,
        "y": 6
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_1/6.json
{
    "id":6,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "right": null,
        "up": null,
        "down": {"type": "powered", "complete": false, "colour": [150, 255, 150, 100]}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 1, 1, 1, 1, 1, 1, 1], 
        [7, 0, 0, {"id":11, "pos": "vtl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 4, 0, 1], 
        [7, 0, 0, {"id":11, "pos": "vbl", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 0, 0, 0, 0, 4, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 6
        },
        {"name": "goblin",
        "x": 6,
        "y": 0.5
        },
        {"name": "goblin",
        "x": 3,
        "y": 1
        },
        {"name": "goblin",
        "x": 5,
        "y": 1.5,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 150, 255, 100]},
                        "chance": 1
                        }]
                    }]
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_1/7.json
{
    "id":7,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 3, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 3, "colour": null},
        "up": null,
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [150, 150, 255, 100]}, 0, 0, 0, 1], 
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 1, 0, 1, 0, 0, 0, 1], 
        [1, 1, 0, 1, 0, 1, 0, 0, 0, 1], 
        [7, 0, 4, 1, 0, 1, 0, 0, 0, 7], 
        [7, 0, 0, 0, 0, 1, 0, 0, 0, 7], 
        [1, {"id":8, "pos": "htl", "colour": [255, 100, 100, 100]}, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 4, 0, 0, 0, 0, 0, {"id": 5, "colour": [150, 150, 255, 100]}, 1], 
        [1, 0, 0, 0, 0, 0, 1, 0, 1, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 7,
        "y": 8,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 100, 100, 100]},
                        "chance": 1
                        }]
                    }]
        },
        {"name": "goblin",
        "x": 7,
        "y": 3
        },
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 6,
        "y": 2
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_1/10.json
{
    "id":10,
    "doors": {
        "left": {"type": "empty", "complete": false, "num": 1, "colour": null},
        "right": null,
        "up": {"type": "powered", "complete": false, "colour": [150, 255, 150, 100]},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, {"id": 5, "colour": [150, 255, 150, 100]}, 4, {"id":8, "pos": "vtr", "colour": [150, 150, 255, 100]}, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 100, 100, 100]}, 4, {"id": 5, "colour": [255, 255, 150, 100]}, 1],
        [1, 0, 0, {"id":8, "pos": "vbr", "colour": [150, 150, 255, 100]}, 0, 0, {"id":8, "pos": "vbl", "colour": [255, 100, 100, 100]}, 0, 0, 1],
        [1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 4, 0, 0, 0, {"id":8, "pos": "vtl", "colour": [255, 255, 150, 100]}, 4, {"id": 5, "colour": [150, 150, 255, 100]}, 1],
        [1, 0, 0, 0, 0, 0, {"id":8, "pos": "vbl", "colour": [255, 255, 150, 100]}, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 7,
        "y": 2
        },
        {"name": "goblin",
        "x": 7,
        "y": 8
        },
        {"name": "item", 
        "x": 140, 
        "y": 160, 
        "item": "key", 
        "payload": {
            "colour": [150, 150, 255, 100]
            }
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_1/player.json
{
    "lives": 3,
    "max_health": 30,
    "health": 30,
    "x": null,
    "y": null,
    "current_room": 1,
    "direction": "down",
    "speed": 6,
    "push_pull_speed": 3,
    "max_sprint_stamina": 45,
    "sprint_stamina": 45,
    "max_boost_time": 75,
    "boost_cooldown": 75,
    "boost_speed": 8,

    "mele_reach": 50,
    "mele_push_strength": 30,
    "attack_damage": 1,
    "max_attack_cooldown": 5,

    "inventory": [
        null, null, 
        null, null, null, 
        null, null, null, 
        null, null, null,
        null, null, null
        ],

    "holding_main_hand": true,

    "kills": 0

}



File: projects/final/data/account_games/default_games/default_levels/rooms_1/1.json
{
    "id": 1, 
    "doors": {
        "left": null, 
        "right": {"type": "empty", "complete": false, "colour": null}, 
        "up": null, 
        "down": null
        }, 
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 1, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, {"id":8, "pos": "vtr", "colour": [255, 100, 100, 100]}, 0, 0, 0, 0, 0, 0, 1], 
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 1, 1, {"id":8, "pos": "hbl", "colour": [150, 255, 150, 100]}, {"id":8, "pos": "hbr", "colour": [150, 255, 150, 100]}, 1, 1, 1, 1], 
        [1, 0, 1, 0, 0, 0, 0, 0, {"id":8, "pos": "vtr", "colour": [150, 150, 255, 100]}, 7], 
        [1, 0, 1, 0, 0, 0, 0, 0, {"id":8, "pos": "vbr", "colour": [150, 150, 255, 100]}, 7], 
        [1, 4, 1, 1, {"id":11, "pos": "htl", "colour": [255, 255, 150, 100]}, {"id":11, "pos": "htr", "colour": [255, 255, 150, 100]}, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 1], 
        [1, {"id": 5, "colour": [150, 150, 255, 100]}, 1, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ], 
    
    "entities": [
        {"name": "goblin",
        "x": 7.5,
        "y": 4.5,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 255, 150, 100]},
                        "chance": 1
                        }]
                    }]
            }
        ]
    }



File: projects/final/data/account_games/default_games/default_levels/rooms_1/11.json
{
    "id":11,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 2, 0, 1, 0, 0, 1, 0, 4, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [255, 255, 150, 100]}, {"id":11, "pos": "htr", "colour": [255, 255, 150, 100]}, 1, 0, 0, 1],
        [1, 4, 0, 1, {"id":11, "pos": "htl", "colour": [255, 100, 100, 100]}, {"id":11, "pos": "htr", "colour": [255, 100, 100, 100]}, 1, 0, 0, 1],
        [1, 4, 0, 1, {"id":11, "pos": "htl", "colour": [150, 150, 255, 100]}, {"id":11, "pos": "htr", "colour": [150, 150, 255, 100]}, 1, 0, 0, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [150, 255, 150, 100]}, {"id":11, "pos": "htr", "colour": [150, 255, 150, 100]}, 1, 0, 2, 1],
        [1, 0, 0, 1, {"id":11, "pos": "htl", "colour": [255, 150, 255, 100]}, {"id":11, "pos": "htr", "colour": [255, 150, 255, 100]}, 1, 0, 2, 1],
        [1, 0, 0, 1, 0, 10, 1, 0, 4, 1],
        [1, 0, 4, 1, 0, 0, 1, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "crate",
        "x": 1,
        "y": 3.5
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_1/2.json
{
    "id":2,
    "doors": {
        "left": {"type": "empty", "complete": false, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "up": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null},
        "down": {"type": "local_kill_count", "complete": false, "num": 4, "colour": null}
        
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 2, 1, 0, 0, 1, 0, 0, 1],
        [1, 0, 1, 1, 0, 0, 1, 1, 0, 1],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 7],
        [1, 0, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, 0, 0, 1, 0, 0, 1, 2, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 4,
        "y": 4
        },
        {"name": "goblin",
        "x": 4,
        "y": 5
        },
        {"name": "goblin",
        "x": 5,
        "y": 4
        },
        {"name": "goblin",
        "x": 5,
        "y": 5
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_1/layout.json
[   [0, 0, 0, 0, 0],
    [0, 4, 5, 6, 0],
    [1, 2,10, 8, 0],
    [0, 3, 7, 9, 0],
    [0,11, 0, 0, 0]
]



File: projects/final/data/account_games/default_games/default_levels/rooms_1/3.json
{
    "id":3,
    "doors": {
        "left": null,
        "right": {"type": "powered", "complete": false, "colour": [255, 100, 100, 100]},
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "powered", "complete": false, "colour": [150, 150, 255, 100]}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1],
        [1, {"id": 6, "colour": [150, 255, 150, 100], "flicked": false}, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, {"id":8, "pos": "htl", "colour": [255, 100, 100, 100]}, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 4, 0, 0, 0, 0, 7],
        [1, {"id": 5, "colour": [255, 100, 100, 100]}, 0, 0, 4, 0, 0, 0, 0, 7],
        [1, {"id":8, "pos": "hbl", "colour": [255, 100, 100, 100]}, 1, 1, 0, 0, 1, 1, 0, 1],
        [1, {"id": 6, "colour": [150, 150, 255, 100], "flicked": false}, 0, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 0, 0, {"id":8, "pos": "hbl", "colour": [150, 255, 150, 100]}, {"id":8, "pos": "hbr", "colour": [150, 255, 150, 100]}, 1, 0, 0, 1],
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 4
        },
        {"name": "goblin",
        "x": 2,
        "y": 5
        },
        {"name": "goblin",
        "x": 3,
        "y": 5
        },
        {"name": "crate",
        "x": 4,
        "y": 3.5
        },
        {"name": "crate",
        "x": 4,
        "y": 4.5
        },
        {"name": "goblin",
        "x": 8,
        "y": 2
        },
        {"name": "goblin",
        "x": 8,
        "y": 7
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_1/8.json
{
    "id":8,
    "doors": {
        "left": null,
        "right": null,
        "up": {"type": "empty", "complete": false, "colour": null},
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, {"id": 5, "colour": [255, 100, 100, 100]}, 1, {"id":8, "pos": "hbl", "colour": [255, 100, 100, 100]}, {"id":8, "pos": "hbr", "colour": [255, 100, 100, 100]}, 1, 4, 0, 1], 
        [1, 1, 1, 1, {"id": 5, "colour": [255, 100, 100, 100]}, {"id": 5, "colour": [255, 100, 100, 100]}, 1, 0, 0, 1], 
        [1, 0, 0, 1, {"id": 5, "colour": [150, 150, 255, 100]}, {"id": 5, "colour": [150, 150, 255, 100]}, 1, 1, 1, 1], 
        [1, 0, 4, 1, {"id":8, "pos": "htl", "colour": [150, 150, 255, 100]}, {"id":8, "pos": "htr", "colour": [150, 150, 255, 100]}, 1, {"id": 5, "colour": [150, 150, 255, 100]}, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 2,
        "y": 2
        },
        {"name": "goblin",
        "x": 2,
        "y": 7
        },
        {"name": "goblin",
        "x": 7,
        "y": 2
        },
        {"name": "goblin",
        "x": 7,
        "y": 7
        },
        {"name": "item", 
        "x": 340, 
        "y": 340, 
        "item": "key", 
        "payload": {
            "colour": [150, 150, 255, 100]
            }
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_1/4.json
{
    "id":4,
    "doors": {
        "left": null,
        "right": {"type": "empty", "complete": false, "num": 4, "colour": null},
        "up": null,
        "down": {"type": "empty", "complete": false, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 4, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 4, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 1, 1, 1, 1, 0, 0, 1], 
        [1, 0, 0, 1, 2, 0, 1, 0, 0, 7], 
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 7], 
        [1, 4, 4, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 4, 0, 0, 1, 0, 4, 1], 
        [1, 0, 0, 4, 0, 0, 1, 0, 2, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "crate",
        "x": 3,
        "y": 6.5
        },
        {"name": "crate",
        "x": 3,
        "y": 7.5
        },
        {"name": "crate",
        "x": 3,
        "y": 0.5
        },
        {"name": "crate",
        "x": 3,
        "y": 1.5
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_1/5.json
{
    "id":5,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null},
        "right": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null},
        "up": null,
        "down": {"type": "local_kill_count", "complete": false, "num": 8, "colour": null}
    },
    "squares": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1], 
        [1, 0, 4, 0, 1, 0, 0, 0, 0, 1], 
        [7, 0, 0, 1, 1, 2, 0, 0, 0, 7], 
        [7, 0, 0, 0, 2, 1, 1, 0, 0, 7], 
        [1, 0, 0, 0, 0, 1, 0, 4, 0, 1], 
        [1, 0, 0, 0, 0, 1, 0, 0, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 6
        },
        {"name": "goblin",
        "x": 2,
        "y": 8
        },
        {"name": "goblin",
        "x": 5,
        "y": 8
        },
        {"name": "goblin",
        "x": 4,
        "y": 5
        },
        {"name": "goblin",
        "x": 6,
        "y": 3,
        "drops": [{"rolls": 1,
                    "total": 1,
                    "drops": [{
                        "item": "key",
                        "payload": {"colour": [255, 255, 150, 100]},
                        "chance": 1
                        }]
                    }]
        },
        {"name": "goblin",
        "x": 1,
        "y": 2
        },
        {"name": "goblin",
        "x": 3,
        "y": 5
        }
    ]
}



File: projects/final/data/account_games/default_games/default_levels/rooms_1/9.json
{
    "id":9,
    "doors": {
        "left": {"type": "local_kill_count", "complete": false, "num": 5, "colour": null},
        "right": null,
        "up": {"type": "local_kill_count", "complete": false, "num": 5, "colour": null},
        "down": null
    },
    "squares": [
        [1, 1, 1, 1, 7, 7, 1, 1, 1, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 2, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 1, 0, 1, 1, 0, 1, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [7, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 0, 1, 0, 1, 1, 0, 1, 0, 1], 
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 2, 0, 0, 0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    "entities": [
        {"name": "goblin",
        "x": 8,
        "y": 4
        },
        {"name": "goblin",
        "x": 3,
        "y": 6
        },
        {"name": "goblin",
        "x": 5,
        "y": 1
        },
        {"name": "goblin",
        "x": 5,
        "y": 5
        },
        {"name": "goblin",
        "x": 2,
        "y": 4
        }
    ]
}



File: projects/final/data/squares/default_square.json
{
    "name": "None",
    "basic": true,
    "collidable": true,
    "animated": false,
    "break_animation": false,
    "textures": ["air"],
    "breakable": true,
    "strength": 20,
    "has_drops": false,
    "collision_size": [1,1],
    "relative_top_left": [0,0],
    "transparent": false,
    "size": [1,1],
    "texture_pos": [0,0]
}



File: projects/final/data/squares/squares_data.json
[
    {
        "id": 0,
        "name": "air",
        "basic": true,
        "collidable": false,
        "textures": ["air"],
        "transparent": true
    },

    {
        "id": 1,
        "name": "rock",
        "basic": true,
        "breakable": false,
        "textures": ["rock"],
        "size": [1, 1.5],
        "texture_pos": [0, -0.5]
    },

        {"id": 2,
        "name": "vase",
        "basic": true,
        "collidable": true,
        "collision_size": [0.4, 0.4],
        "break_animation": true,
        "textures": ["vase"],
        "strength": 2,
        "transparent": true,
        "has_drops": true,

        "drops": [{"rolls": 1,
                    "total": 5,
                    "drops": [{
                        "item": "stick",
                        "chance": 1
                        },
                    {
                        "item": "long_sword",
                        "chance": 1
                        },
                    {
                        "item": "metal_axe",
                        "chance": 1
                        },
                    {
                        "item": "dagger",
                        "chance": 1
                        },
                    {
                        "item": "mace",
                        "chance": 1
                        }]
                    },
                    {"rolls": 1,
                    "total": 9,
                    "drops": [{
                        "item": "wood_head",
                        "chance": 1
                        },
                    {
                        "item": "wood_chest",
                        "chance": 1
                        },
                    {
                        "item": "wood_feet",
                        "chance": 1
                        },
                    {
                        "item": "chain_head",
                        "chance": 1
                        },
                    {
                        "item": "chain_chest",
                        "chance": 1
                        },
                    {
                        "item": "chain_feet",
                        "chance": 1
                        },
                    {
                        "item": "metal_head",
                        "chance": 1
                        },
                    {
                        "item": "metal_chest",
                        "chance": 1
                        },
                    {
                        "item": "metal_feet",
                        "chance": 1
                        }
                    ]
                    }
                ]
    },

    {
        "id": 3,
        "name": "door",
        "basic": false
    },

    {
        "id": 4,
        "name": "crate",
        "basic": false
    },

    {
        "id": 5,
        "name": "button",
        "basic": false
    },

    {
        "id": 6,
        "name": "lever",
        "basic": false
    },

    {
        "id": 7,
        "name": "non_navigable_air",
        "basic": true,
        "collidable": true,
        "collision_size": [0,0],
        "textures": ["air"]
    },

    {
        "id": 8,
        "name": "mechanical_door",
        "basic": false
    },

    {
        "id": 9,
        "name": "objective_door",
        "basic": false
    },

    {
        "id": 10,
        "name": "ladder",
        "basic": false
    },

    {
        "id": 11,
        "name": "keyhole_door",
        "basic": false
    },

    {
        "id": 12,
        "name": "keyhole_wall",
        "basic": false
    }

]



File: projects/final/data/entities/enemies/goblin.json
{
    "health": 5,
    "walk_speed": 2,
    "run_speed": 4,
    "max_player_memory_range": [20, 100],
    "size": [150,150],
    "collision_box_size": [30, 20],
    "team": "enemy",
    "mele_reach": 90,
    "attack_damage": 4,
    "attack_cooldown": 30
}



Total files: 184
